<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/4.4.1" created="2016-02-16 08:12" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>小宝的技术锅</title>
	<link>http://www.autoref.cn</link>
	<description>为了奥托列夫的荣耀</description>
	<pubDate>Tue, 16 Feb 2016 08:12:44 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://www.autoref.cn</wp:base_site_url>
	<wp:base_blog_url>http://www.autoref.cn</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[x4niko]]></wp:author_login><wp:author_email><![CDATA[x4niko@163.com]]></wp:author_email><wp:author_display_name><![CDATA[小宝]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>

	<wp:category><wp:term_id>2</wp:term_id><wp:category_nicename><![CDATA[android]]></wp:category_nicename><wp:category_parent><![CDATA[]]></wp:category_parent><wp:cat_name><![CDATA[android]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>7</wp:term_id><wp:category_nicename><![CDATA[android-issues]]></wp:category_nicename><wp:category_parent><![CDATA[android]]></wp:category_parent><wp:cat_name><![CDATA[android issues]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>43</wp:term_id><wp:category_nicename><![CDATA[android-studio]]></wp:category_nicename><wp:category_parent><![CDATA[android]]></wp:category_parent><wp:cat_name><![CDATA[android studio]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>77</wp:term_id><wp:category_nicename><![CDATA[android%e5%8a%a8%e7%94%bb]]></wp:category_nicename><wp:category_parent><![CDATA[android]]></wp:category_parent><wp:cat_name><![CDATA[android动画]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>50</wp:term_id><wp:category_nicename><![CDATA[android%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91]]></wp:category_nicename><wp:category_parent><![CDATA[android]]></wp:category_parent><wp:cat_name><![CDATA[android应用开发]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>4</wp:term_id><wp:category_nicename><![CDATA[html5]]></wp:category_nicename><wp:category_parent><![CDATA[]]></wp:category_parent><wp:cat_name><![CDATA[HTML5]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>5</wp:term_id><wp:category_nicename><![CDATA[html5%e6%b8%b8%e6%88%8f%e5%bc%80%e5%8f%91]]></wp:category_nicename><wp:category_parent><![CDATA[html5]]></wp:category_parent><wp:cat_name><![CDATA[HTML5游戏开发]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>63</wp:term_id><wp:category_nicename><![CDATA[html%e5%9f%ba%e7%a1%80]]></wp:category_nicename><wp:category_parent><![CDATA[html5]]></wp:category_parent><wp:cat_name><![CDATA[HTML基础]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>3</wp:term_id><wp:category_nicename><![CDATA[ios]]></wp:category_nicename><wp:category_parent><![CDATA[]]></wp:category_parent><wp:cat_name><![CDATA[iOS]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>31</wp:term_id><wp:category_nicename><![CDATA[ios-issues]]></wp:category_nicename><wp:category_parent><![CDATA[ios]]></wp:category_parent><wp:cat_name><![CDATA[iOS issues]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>86</wp:term_id><wp:category_nicename><![CDATA[spring]]></wp:category_nicename><wp:category_parent><![CDATA[]]></wp:category_parent><wp:cat_name><![CDATA[Spring]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>6</wp:term_id><wp:category_nicename><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0]]></wp:category_nicename><wp:category_parent><![CDATA[ios]]></wp:category_parent><wp:cat_name><![CDATA[swift学习笔记]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>1</wp:term_id><wp:category_nicename><![CDATA[uncategorized]]></wp:category_nicename><wp:category_parent><![CDATA[]]></wp:category_parent><wp:cat_name><![CDATA[未分类]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>62</wp:term_id><wp:category_nicename><![CDATA[%e8%87%aa%e6%88%91%e4%bf%ae%e5%85%bb]]></wp:category_nicename><wp:category_parent><![CDATA[]]></wp:category_parent><wp:cat_name><![CDATA[自我修养]]></wp:cat_name></wp:category>
	<wp:tag><wp:term_id>79</wp:term_id><wp:tag_slug><![CDATA[alphaanimation]]></wp:tag_slug><wp:tag_name><![CDATA[AlphaAnimation]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>46</wp:term_id><wp:tag_slug><![CDATA[android]]></wp:tag_slug><wp:tag_name><![CDATA[android]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>44</wp:term_id><wp:tag_slug><![CDATA[android-studio]]></wp:tag_slug><wp:tag_name><![CDATA[android studio]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>55</wp:term_id><wp:tag_slug><![CDATA[arrays]]></wp:tag_slug><wp:tag_name><![CDATA[arrays]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>83</wp:term_id><wp:tag_slug><![CDATA[charles]]></wp:tag_slug><wp:tag_name><![CDATA[Charles]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>45</wp:term_id><wp:tag_slug><![CDATA[gradle]]></wp:tag_slug><wp:tag_name><![CDATA[gradle]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>64</wp:term_id><wp:tag_slug><![CDATA[html5]]></wp:tag_slug><wp:tag_name><![CDATA[html5]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>54</wp:term_id><wp:tag_slug><![CDATA[http]]></wp:tag_slug><wp:tag_name><![CDATA[http]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>58</wp:term_id><wp:tag_slug><![CDATA[ignore]]></wp:tag_slug><wp:tag_name><![CDATA[ignore]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>52</wp:term_id><wp:tag_slug><![CDATA[imagebutton]]></wp:tag_slug><wp:tag_name><![CDATA[ImageButton]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>8</wp:term_id><wp:tag_slug><![CDATA[ios]]></wp:tag_slug><wp:tag_name><![CDATA[iOS]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>59</wp:term_id><wp:tag_slug><![CDATA[litepal]]></wp:tag_slug><wp:tag_name><![CDATA[LitePal]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>71</wp:term_id><wp:tag_slug><![CDATA[onnewintent]]></wp:tag_slug><wp:tag_name><![CDATA[onNewIntent]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>33</wp:term_id><wp:tag_slug><![CDATA[outlet]]></wp:tag_slug><wp:tag_name><![CDATA[outlet]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>80</wp:term_id><wp:tag_slug><![CDATA[rotateanimation]]></wp:tag_slug><wp:tag_name><![CDATA[RotateAnimation]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>81</wp:term_id><wp:tag_slug><![CDATA[scaleanimation]]></wp:tag_slug><wp:tag_name><![CDATA[ScaleAnimation]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>76</wp:term_id><wp:tag_slug><![CDATA[singleinstance]]></wp:tag_slug><wp:tag_name><![CDATA[singleInstance]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>75</wp:term_id><wp:tag_slug><![CDATA[singletask]]></wp:tag_slug><wp:tag_name><![CDATA[singleTask]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>74</wp:term_id><wp:tag_slug><![CDATA[singletop]]></wp:tag_slug><wp:tag_name><![CDATA[singleTop]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>87</wp:term_id><wp:tag_slug><![CDATA[spring-mvc]]></wp:tag_slug><wp:tag_name><![CDATA[spring mvc]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>73</wp:term_id><wp:tag_slug><![CDATA[standard]]></wp:tag_slug><wp:tag_name><![CDATA[standard]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>32</wp:term_id><wp:tag_slug><![CDATA[storyboard]]></wp:tag_slug><wp:tag_name><![CDATA[StoryBoard]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>57</wp:term_id><wp:tag_slug><![CDATA[svn]]></wp:tag_slug><wp:tag_name><![CDATA[svn]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>9</wp:term_id><wp:tag_slug><![CDATA[swift]]></wp:tag_slug><wp:tag_name><![CDATA[swift]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>82</wp:term_id><wp:tag_slug><![CDATA[translateanimation]]></wp:tag_slug><wp:tag_name><![CDATA[TranslateAnimation]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>47</wp:term_id><wp:tag_slug><![CDATA[volley]]></wp:tag_slug><wp:tag_name><![CDATA[volley]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>56</wp:term_id><wp:tag_slug><![CDATA[xml]]></wp:tag_slug><wp:tag_name><![CDATA[xml]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>22</wp:term_id><wp:tag_slug><![CDATA[%e4%b8%8b%e6%a0%87%e8%84%9a%e6%9c%ac]]></wp:tag_slug><wp:tag_name><![CDATA[下标脚本]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>15</wp:term_id><wp:tag_slug><![CDATA[%e5%87%bd%e6%95%b0]]></wp:tag_slug><wp:tag_name><![CDATA[函数]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>67</wp:term_id><wp:tag_slug><![CDATA[%e5%88%86%e8%be%a8%e7%8e%87]]></wp:tag_slug><wp:tag_name><![CDATA[分辨率]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>78</wp:term_id><wp:tag_slug><![CDATA[%e5%8a%a8%e7%94%bb]]></wp:tag_slug><wp:tag_name><![CDATA[动画]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>38</wp:term_id><wp:tag_slug><![CDATA[%e5%8d%8f%e8%ae%ae]]></wp:tag_slug><wp:tag_name><![CDATA[协议]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>28</wp:term_id><wp:tag_slug><![CDATA[%e5%8f%98%e9%87%8f]]></wp:tag_slug><wp:tag_name><![CDATA[变量]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>30</wp:term_id><wp:tag_slug><![CDATA[%e5%8f%af%e9%80%89%e9%93%be%e5%bc%8f%e8%b0%83%e7%94%a8]]></wp:tag_slug><wp:tag_name><![CDATA[可选链式调用]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>72</wp:term_id><wp:tag_slug><![CDATA[%e5%90%af%e5%8a%a8%e6%a8%a1%e5%bc%8f]]></wp:tag_slug><wp:tag_name><![CDATA[启动模式]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>68</wp:term_id><wp:tag_slug><![CDATA[%e5%a4%9a%e5%b1%8f%e5%b9%95]]></wp:tag_slug><wp:tag_name><![CDATA[多屏幕]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>85</wp:term_id><wp:tag_slug><![CDATA[%e5%ad%97%e4%bd%93%e5%8a%a0%e7%b2%97]]></wp:tag_slug><wp:tag_name><![CDATA[字体加粗]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>11</wp:term_id><wp:tag_slug><![CDATA[%e5%ad%97%e7%ac%a6]]></wp:tag_slug><wp:tag_name><![CDATA[字符]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>12</wp:term_id><wp:tag_slug><![CDATA[%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:tag_slug><wp:tag_name><![CDATA[字符串]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>20</wp:term_id><wp:tag_slug><![CDATA[%e5%b1%9e%e6%80%a7]]></wp:tag_slug><wp:tag_name><![CDATA[属性]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>36</wp:term_id><wp:tag_slug><![CDATA[%e5%b5%8c%e5%a5%97%e7%b1%bb%e5%9e%8b]]></wp:tag_slug><wp:tag_name><![CDATA[嵌套类型]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>27</wp:term_id><wp:tag_slug><![CDATA[%e5%b8%b8%e9%87%8f]]></wp:tag_slug><wp:tag_name><![CDATA[常量]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>60</wp:term_id><wp:tag_slug><![CDATA[%e5%bc%80%e6%ba%90%e6%a1%86%e6%9e%b6]]></wp:tag_slug><wp:tag_name><![CDATA[开源框架]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>66</wp:term_id><wp:tag_slug><![CDATA[%e5%bf%ab%e6%8d%b7%e9%94%ae]]></wp:tag_slug><wp:tag_name><![CDATA[快捷键]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>37</wp:term_id><wp:tag_slug><![CDATA[%e6%89%a9%e5%b1%95]]></wp:tag_slug><wp:tag_name><![CDATA[扩展]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>14</wp:term_id><wp:tag_slug><![CDATA[%e6%8e%a7%e5%88%b6%e6%b5%81]]></wp:tag_slug><wp:tag_name><![CDATA[控制流]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>70</wp:term_id><wp:tag_slug><![CDATA[%e6%90%9c%e7%b4%a2]]></wp:tag_slug><wp:tag_name><![CDATA[搜索]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>10</wp:term_id><wp:tag_slug><![CDATA[%e6%93%8d%e4%bd%9c%e7%ac%a6]]></wp:tag_slug><wp:tag_name><![CDATA[操作符]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>61</wp:term_id><wp:tag_slug><![CDATA[%e6%95%b0%e6%8d%ae%e5%ba%93]]></wp:tag_slug><wp:tag_name><![CDATA[数据库]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>29</wp:term_id><wp:tag_slug><![CDATA[%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b]]></wp:tag_slug><wp:tag_name><![CDATA[数据类型]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>21</wp:term_id><wp:tag_slug><![CDATA[%e6%96%b9%e6%b3%95]]></wp:tag_slug><wp:tag_name><![CDATA[方法]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>24</wp:term_id><wp:tag_slug><![CDATA[%e6%9e%84%e9%80%a0%e8%bf%87%e7%a8%8b]]></wp:tag_slug><wp:tag_name><![CDATA[构造过程]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>25</wp:term_id><wp:tag_slug><![CDATA[%e6%9e%90%e6%9e%84%e8%bf%87%e7%a8%8b]]></wp:tag_slug><wp:tag_name><![CDATA[析构过程]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>17</wp:term_id><wp:tag_slug><![CDATA[%e6%9e%9a%e4%b8%be]]></wp:tag_slug><wp:tag_name><![CDATA[枚举]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>49</wp:term_id><wp:tag_slug><![CDATA[%e6%a1%86%e6%9e%b6]]></wp:tag_slug><wp:tag_name><![CDATA[框架]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>39</wp:term_id><wp:tag_slug><![CDATA[%e6%b3%9b%e5%9e%8b]]></wp:tag_slug><wp:tag_name><![CDATA[泛型]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>18</wp:term_id><wp:tag_slug><![CDATA[%e7%b1%bb]]></wp:tag_slug><wp:tag_name><![CDATA[类]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>35</wp:term_id><wp:tag_slug><![CDATA[%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2]]></wp:tag_slug><wp:tag_name><![CDATA[类型转换]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>19</wp:term_id><wp:tag_slug><![CDATA[%e7%bb%93%e6%9e%84%e4%bd%93]]></wp:tag_slug><wp:tag_name><![CDATA[结构体]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>23</wp:term_id><wp:tag_slug><![CDATA[%e7%bb%a7%e6%89%bf]]></wp:tag_slug><wp:tag_name><![CDATA[继承]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>84</wp:term_id><wp:tag_slug><![CDATA[%e7%bd%91%e7%bb%9c%e7%9b%91%e6%8e%a7]]></wp:tag_slug><wp:tag_name><![CDATA[网络监控]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>48</wp:term_id><wp:tag_slug><![CDATA[%e7%bd%91%e7%bb%9c%e9%80%9a%e4%bf%a1]]></wp:tag_slug><wp:tag_name><![CDATA[网络通信]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>26</wp:term_id><wp:tag_slug><![CDATA[%e8%87%aa%e5%8a%a8%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0]]></wp:tag_slug><wp:tag_name><![CDATA[自动引用计数]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>53</wp:term_id><wp:tag_slug><![CDATA[%e8%87%aa%e5%ae%9a%e4%b9%89%e6%8e%a7%e4%bb%b6]]></wp:tag_slug><wp:tag_name><![CDATA[自定义控件]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>40</wp:term_id><wp:tag_slug><![CDATA[%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6]]></wp:tag_slug><wp:tag_name><![CDATA[访问控制]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>88</wp:term_id><wp:tag_slug><![CDATA[%e8%af%b7%e6%b1%82%e5%8f%82%e6%95%b0]]></wp:tag_slug><wp:tag_name><![CDATA[请求参数]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>65</wp:term_id><wp:tag_slug><![CDATA[%e8%bd%ac%e4%b9%89%e5%ad%97%e7%ac%a6]]></wp:tag_slug><wp:tag_name><![CDATA[转义字符]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>69</wp:term_id><wp:tag_slug><![CDATA[%e8%bd%af%e9%94%ae%e7%9b%98]]></wp:tag_slug><wp:tag_name><![CDATA[软键盘]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>34</wp:term_id><wp:tag_slug><![CDATA[%e9%94%99%e8%af%af%e5%a4%84%e7%90%86]]></wp:tag_slug><wp:tag_name><![CDATA[错误处理]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>16</wp:term_id><wp:tag_slug><![CDATA[%e9%97%ad%e5%8c%85]]></wp:tag_slug><wp:tag_name><![CDATA[闭包]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>13</wp:term_id><wp:tag_slug><![CDATA[%e9%9b%86%e5%90%88]]></wp:tag_slug><wp:tag_name><![CDATA[集合]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>41</wp:term_id><wp:tag_slug><![CDATA[%e9%ab%98%e7%ba%a7%e8%bf%90%e7%ae%97%e7%ac%a6]]></wp:tag_slug><wp:tag_name><![CDATA[高级运算符]]></wp:tag_name></wp:tag>

	<generator>https://wordpress.org/?v=4.4.1</generator>

	<item>
		<title>关于</title>
		<link>http://www.autoref.cn/?page_id=2</link>
		<pubDate>Thu, 03 Dec 2015 07:16:06 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?page_id=2</guid>
		<description></description>
		<content:encoded><![CDATA[这是一个范例页面。它和博客文章不同，因为它的页面位置是固定的，同时会显示于您的博客导航栏（大多数主题中）。大多数人会新增一个“关于”页面向访客介绍自己。它可能类似下面这样：

<blockquote>我是一个很有趣的人，我创建了工厂和庄园。并且，顺便提一下，我的妻子也很好。</blockquote>

……或下面这样：

<blockquote>XYZ装置公司成立于1971年，公司成立以来，我们一直向市民提供高品质的装置。我们位于北京市，有超过2,000名员工，对北京市有着相当大的贡献。</blockquote>

作为一个新的WordPress用户，您可以前往<a href="http://120.25.204.37/wp-admin/">您的仪表盘</a>删除这个页面，并建立属于您的全新内容。祝您使用愉快！

<canvas id="myCanvas" width="200" height="100" style="border:1px solid #c3c3c3;">
Your browser does not support the canvas element.
</canvas>

<pre>
<script type="text/javascript">

var c=document.getElementById("myCanvas");
var cxt=c.getContext("2d");
cxt.moveTo(10,10);
cxt.lineTo(150,50);
cxt.lineTo(10,50);
cxt.stroke();

</script>
</pre>


<script type="text/javascript">

var c=document.getElementById("myCanvas");
var cxt=c.getContext("2d");
cxt.moveTo(10,10);
cxt.lineTo(150,50);
cxt.lineTo(10,50);
cxt.stroke();

</script>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>2</wp:post_id>
		<wp:post_date><![CDATA[2015-12-03 15:16:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-03 07:16:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[about]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记1：常量、变量和数据类型 (Constants and Variables)</title>
		<link>http://www.autoref.cn/?p=4</link>
		<pubDate>Wed, 18 Nov 2015 06:38:39 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=4</guid>
		<description></description>
		<content:encoded><![CDATA[按照常理，应该先打印一句“Hello World”。
<pre>print("Hello, swift!")
</pre>
对swift来说，这就是一个完整的程序，不需要为了输入输出或者字符串处理导入一个单独的库，也不需要main函数，全局作用域中的代码会被自动当做程序的入口。一条语句后面也不需要分号，加上也不影响，不过当一行写多条语句的时候就要用分号分开。
<pre>print("Hello, swift!"); print("Hello, world!")
</pre>
print在打印一行后会默认换行，要不换行的话，设置另一个参数terminator为""。
<pre>print("Hello, swift!", terminator:"") //不换行
</pre>
常量和变量不需要明确地指定类型，但在使用前需要先声明，常量声明用let，变量声明用var。可以一行声明多个常量或变量。
<pre>var myVariable = 0
myVariable = 1
let myConstant = 200

var a = 0.0, b = 1, c = 2.0
</pre>
关于常量或变量的命名，可以包含Unicode字符，不能包含空格、数学符号、箭头、制表符，也不能以数字开头。严格上不能用关键字作为名字，如果不得不这么做，可以给关键字名字加上反引号，但不建议。
<pre>let π = 3.14159 //正确
let 你好 = "你好世界" //正确
let 4digit //错误

var `let` = 0 // let为关键字，加上反引号作为变量名
`let` = 1
print(`let`) // 打印：1
</pre>
一般声明变量时需要给它赋值，以此来推断出它的类型。如果声明时不想赋值，可以先给变量提供一种类型，等需要的时候再赋值。
<pre>var welcomeMessage: String
welcomeMessage = "Hello" //赋值
</pre>
也可以一行定义多个相同类型的常量或变量，用逗号分开
<pre>var red, green, blue: Double
</pre>
swift包含类型有：整数Int，浮点数Double和Float，布尔值Bool和文本String，以及集合类型Array、Set和Dictionary。
整型分为8位、16位、 32位和64位，像UInt8为8位无符号整型，Int32为32位有符号整型。多数情况下不需要指定特定的整型，可以直接使用Int，在32位平台，Int的大小跟Int32相等，在64位平台，Int的大小跟Int64的相等。
浮点数有Double和Float两种，Double相当于一个64位浮点数，Float相当于一个32位浮点数。
swift是类型安全的语言，会根据赋的值推断出类型。
<pre>let pi = 3.14159 //会推断为Double，而不是Float类型
let anotherPi = 3 + 0.14159 //整数和浮点数相加会推断为Double
</pre>
整型的数值表示：
<pre>let decimalInteger = 18
let binaryInteger = 0b10010       // 二进制
let octalInteger = 0o22           // 八进制
let hexadecimalInteger = 0x12     // 十六进制
</pre>
浮点型的十进制数值不一定要有指数，底数用大写或者小写的e表示：
1.25e^2表示1.25 x 10^2或125.0
1.25e^-2表示1.25 x 10^-2或0.0125。
十六进制数值必须要有指数，用大写或小写的p做底数：
0xFp2表示15 x 2^2或60.0
0xFp-2表示15 x 2^-2或3.75
<pre>let decimalDouble = 12.1875
let exponentDouble = 1.21875e1     // 指数表示
let hexadecimalDouble = 0xC.3p0    // 十六进制
</pre>
上面的值都是12.1875。
想要方便地看出数值表示多少，可以在适当的位置给整数或者浮点数加0和下划线
<pre>
let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
</pre>

整型转换：Int8的存储范围为-128~127，UInt8的存储范围为0~255，如果存储的值超出范围就会报错
<pre>
let cannotBeNegative: UInt8 = -1 //错误
let tooBig: Int8 = Int8.max + 1  //错误
</pre>
下面的例子中，UInt8和UInt16是不同的类型，需要调用UInt16(one)转换为可以相加的类型
<pre>
let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOneError = twoThousand + one       //错误
let twoThousandAndOne = twoThousand + UInt16(one)    //正确
</pre>
整型和浮点型的转换要明确地表示
<pre>
// 整型转浮点型
let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine

// 浮点型转整型，小数点后面的数会被截掉
let integerPi = Int(pi)  // 打印：3

// 这句是正确的，因为3和0.14159还没有指定明确的类型
let anotherPi = 3 + 0.14159
</pre>
当现有类型的名字不太适合当前上下文定义时，可以给类型取一个别名
<pre>
typealias AnotherInt16 = Int16
var minAnotherInt16 = AnotherInt16.min
</pre>
稍微记录一下布尔值Bool
<pre>
let orangesAreOrange = true
let turnipsAreDelicious = false
</pre>

swift的元组组合多个值作为一个复合值，元组中的各个值可以是任何类型，每个值的类型也不用一样。元组中的值可以单独获取使用。
<pre>
let http404Error = (404, "Not Found")  // http404Error的类型是(Int, String)

let (statusCode, statusMessage) = http404Error
print(statusCode)         // 打印：404
print("statusMessage")    // 打印：Not Found

// 通过索引来获取，索引值从0开始
print(http404Error.0)
print(http404Error.1)

// 如果只需要部分值，其它不需要的用下划线_代替
let (justTheStatusCode, _) = http404Error   

// 也可以给元组值命名，方便读取
let http200Status = (statusCode: 200, description: "OK")
print(http200Status.statusCode)
print(http200Status.description)
</pre>

有时候复制可能会失败，比如：
<pre>
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// swift推断possibleNumber的类型为Int?，或者是可选的Int
</pre>
上面尝试将字符串possibleNumber转换成Int型，但是possibleNumber的值可能是"Hello, swift!"，所以它返回一个可选的类型Int?，表示它要么是Int型，要么什么都不是，也不可能是Bool或者String。

swift中得nil不是一个指针，它表示缺少一个类型的值，任何类型的可选值都可以设置为nil，但不能用于不可选的常量或变量。
<pre>
var serverResponseCode: Int? = 404
serverResponseCode = nil   // 现在serverResponseCode不包含值

var surveyAnswer: String?  // surveyAnswer没有默认值，自动设置为nil
</pre>
! 放在类型后面，表示强制的隐式转换。和?放在类型后面的行为比较类似，都是一个类型声明的语法。?声明的是Optional，而!声明的是一个Implicitly Unwrapped Optional类型，使得我们在确信返回值或者要传递的值不是空的时候，可以很方便的不需要做任何转换，直接使用。
<pre>
let possibleString: String? = "An optional string."
let forcedString: String = possibleString! // 需要感叹号
 
let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString // 不需要感叹号
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>4</wp:post_id>
		<wp:post_date><![CDATA[2015-11-18 14:38:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-18 06:38:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b01%ef%bc%9a%e5%b8%b8%e9%87%8f%e3%80%81%e5%8f%98%e9%87%8f%e5%92%8c%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b-constants-and-variables]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%8f%98%e9%87%8f"><![CDATA[变量]]></category>
		<category domain="post_tag" nicename="%e5%b8%b8%e9%87%8f"><![CDATA[常量]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b"><![CDATA[数据类型]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b01%e3%80%81%e5%b8%b8%e9%87%8f%e5%92%8c%e5%8f%98%e9%87%8f]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[post_views_count]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b01%ef%bc%9a%e5%b8%b8%e9%87%8f%e3%80%81%e5%8f%98%e9%87%8f%e5%92%8c%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记2：基本操作符 (Basic Operators)</title>
		<link>http://www.autoref.cn/?p=43</link>
		<pubDate>Thu, 19 Nov 2015 08:33:55 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=43</guid>
		<description></description>
		<content:encoded><![CDATA[操作符分为一元、二元和三元操作符。
一元：-a，!b，i++等
二元：+，-，*，/等
三元：a ? b : c

赋值操作符(=)：
<pre>let b = 10
var a = 5
a = b
// a等于10

let (x, y) = (1, 2)
// x等于1, y等于2
</pre>
算术操作符(+，-，*，/)：
<pre>1 + 2       // 3
5 - 3       // 2
2 * 3       // 6
10.0 / 2.5  // 4.0

"hello, " + "world"  // hello, world
</pre>
取余操作符(%)：
<pre>9 % 4    // 1
-9 % 4   // -1
8 % 2.5  // 0.5
</pre>
自增自减操作符(++，--)：
<pre>var i = 0
++i      // i等于1

var a = 0
let b = ++a  // a和b都等于1

let c = a++  // a等于2，c等于1
</pre>
一元加减运算符：
<pre>let minusSix = -6
let alsoMinusSix = +minusSix  // alsoMinusSix = -6

let three = 3
let minusThree = -three       // minusThree = -3
let plusThree = -minusThree   // plusThree = 3
</pre>
复合赋值运算符：
<pre>var a = 1
a += 2   // a = 3
</pre>
比较运算符：
<pre>1 == 1   // true
2 != 1   // true
2 > 1    // true
1 < 2    // true
1 >= 1   // true
2 <= 1   // false
</pre>
swift还有(=== and !==)运算符，来判断两个对象的引用是否也相同

三元操作符(a ? b : c)：
<pre>let contentHeight = 40
let hasHeader = true
let rowHeight = contentHeight + (hasHeader ? 50 : 20)
// rowHeight等于90
</pre>
Nil Coalescing操作符(a ?? b):
这个运算符有两个条件：
1、a必须是Optional类型的
2、b的类型必须要和a解包后的值类型一致
<pre>let c = a ?? b 
</pre>
对于上面的表达式，c的值是a或b中一个的值，当a解包后的值不为nil时，c就等于a，否则c等于b

范围操作符分为闭合范围和半开范围操作符：
<pre>for index in 1...5 {}

let names = ["Anna", "Alex", "Brian", "Jack"]
let count = names.count
for i in 0..<count {}
</pre>
逻辑操作符：逻辑非 (!a)，逻辑且 (a && b)，逻辑或 (a || b)
<pre>let allowedEntry = false
!allowedEntry  // true

let enteredDoorCode = true
let passedRetinaScan = false
enteredDoorCode && passedRetinaScan  // false

let hasDoorKey = false
let knowsOverridePassword = true
hasDoorKey || knowsOverridePassword  // true

// 混合使用
if enteredDoorCode && passedRetinaScan || hasDoorKey || knowsOverridePassword {}
// 插入圆括号
if (enteredDoorCode && passedRetinaScan) || hasDoorKey || knowsOverridePassword {} 
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>43</wp:post_id>
		<wp:post_date><![CDATA[2015-11-19 16:33:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-19 08:33:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b02%ef%bc%9a%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c%e7%ac%a6-basic-operators]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e6%93%8d%e4%bd%9c%e7%ac%a6"><![CDATA[操作符]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b01%ef%bc%9a%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c%e7%ac%a6]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b02%ef%bc%9a%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c%e7%ac%a6]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[post_views_count]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记3：字符和字符串 (Strings and Characters)</title>
		<link>http://www.autoref.cn/?p=53</link>
		<pubDate>Fri, 20 Nov 2015 12:25:20 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=53</guid>
		<description></description>
		<content:encoded><![CDATA[两种方式初始化一个空字符串：
<pre>
var emptyString = ""
var anotherEmptyString = String() 

emptyString.isEmpty  // 判断字符串是否为空
</pre>

可变字符串：
<pre>
var variableString = "Horse"
variableString += " and carriage"
print(variableString)  // 打印：Horse and carriage
</pre>

swift的字符串类型是值类型，当创建一个新的字符串类型，传递给一个函数或者方法，给变量或常量赋值时，只是拷贝了一份字符串的值，而不是传递原始值。

字符类型：
<pre>
let exclamationMark: Character = "!"
</pre>
字符串也可以由字符数组构造而成：
<pre>
let catCharacters: [Character] = ["H", "e", "l", "l", "o"]
let catString = String(catCharacters)
print(catString) //打印：Hello
</pre>
可以给字符串附加字符，但不能给字符附加字符或者字符串：
<pre>
var aha = "aha"

let exclamationMark: Character = "!"
aha.append(exclamationMark)
print(aha)  // 打印：aha!
</pre>

使用\()在字符串中插入值，括号内部的表达式不能包含未转义的双引号、反斜杠，也不能包含回车、换行符。：
<pre>
let multiplier = 3
let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"
</pre>

字符串特殊字符：\0 (null), \\ (反斜线), \t (水平制表符), \n (换行), \r (回车), \" (双引号) and \' (单引号)
<pre>
let dollarSign = "\u{24}"        // $,  Unicode：U+0024
</pre>
扩展字元簇（Extended Grapheme Clusters）
Grapheme是指某种自然语言中的最小单元，它并不一定有实际意义，但是它们组合成这种语言的单个字符。Swift语言的每个字符(Character)都是一个独立的扩展字元簇，一个扩展字元簇就是由一个或多个Unicode scalar(Unicode纯量)的有序排列从而组合成可读的字符。
比如：字母é可以是一个单独的Unicode scalar：U+00E9，也可以是多个纯量的组合：U+0065U+0301 （其中U+0065就是字母e）。在Swift中，这两种情况都认为是一个字符，因此获取字符串长度的时候(用全局函数count())，返回的值是相同的，这意味着字符串的改变并不一定意味着其长度发生变化。
注意区分这和OC中NSString的length的区别，NSString的长度是基于字符串在UTF-16编码表示时其中包含的16位的单元的个数，而不是Unicode扩展字元簇的数目。为了反映这个区别，NSString的length属性在Swift中用utf16Count函数来代替。
<pre>
var word = "cafe"
print("the number of characters in \(word) is \(word.characters.count)")
// 打印：the number of characters in cafe is 4
 
word += "\u{301}"
print("the number of characters in \(word) is \(word.characters.count)")
// 打印：the number of characters in café is 4
</pre>

字符串索引：
每一个字符串都有一个关联的索引(index)类型，String.index，它对应着字符串中的每一个字符的位置。
不同的字符可能会占用不同的内存空间数量，所以要知道字符的确定位置，就必须从字符串开头遍历每一个 Unicode 标量到字符串结尾。因此，Swift 的字符串不能用整数(integer)做索引。
使用startIndex属性可以获取字符串的第一个字符。使用endIndex属性可以获取最后的位置（其实endIndex在值上与字符串的长度相等）。如果字符串是空值，startIndex和endIndex是相等的。
通过调用String.Index的predecessor()方法，可以立即得到前面一个索引，调用successor()方法可以立即得到后面一个索引。
<pre>
let greeting = "Guten Tag!"
greeting[greeting.startIndex]                       // G
greeting[greeting.endIndex.predecessor()]           // !
greeting[greeting.startIndex.successor()]           // u
let index = greeting.startIndex.advancedBy(7)
greeting[index]                                     // a
</pre>

插入和移除字符串：
<pre>
var welcome = "hello"
welcome.insert("!", atIndex: welcome.endIndex)
// hello!

welcome.insertContentsOf(" there".characters, at: welcome.endIndex.predecessor())
// hello there!

welcome.removeAtIndex(welcome.endIndex.predecessor())
// hello there

let range = welcome.endIndex.advancedBy(-6)..<welcome.endIndex
welcome.removeRange(range)
// hello
</pre>

字符串对比：
<pre>
let quotation = "We're a lot alike, you and I."
let sameQuotation = "We're a lot alike, you and I."
quotation == sameQuotation  // true
</pre>

使用hasPrefix(_:)和hasSuffix(_:)判断一个字符串是否有某个前缀或后缀]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>53</wp:post_id>
		<wp:post_date><![CDATA[2015-11-20 20:25:20]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-20 12:25:20]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b03%ef%bc%9a%e5%ad%97%e7%ac%a6%e5%92%8c%e5%ad%97%e7%ac%a6%e4%b8%b2-strings-and-characters]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6"><![CDATA[字符]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[post_views_count]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b03%ef%bc%9a%e5%ad%97%e7%ac%a6%e5%92%8c%e5%ad%97%e7%ac%a6%e4%b8%b2]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记4：集合类型 (Collection Types)</title>
		<link>http://www.autoref.cn/?p=63</link>
		<pubDate>Sat, 21 Nov 2015 07:31:29 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=63</guid>
		<description></description>
		<content:encoded><![CDATA[swift提供三种基本的集合类型：Array, Set, 和Dictionary。
Array为有序值的集合，Set为无序的唯一值的集合，Dictionary为无序的键值对关联集合
<img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png" alt="swift三种基本的集合类型" />

Array：
<pre>
var someInts = [Int]()   // 创建一个Int的空数组
someInts.append(3)
someInts = []            // 现在为空数组，但类型还是[Int]

// 创建一个[Double]类型的数组，大小为3，默认值为[0.0, 0.0, 0.0]
var threeDoubles = [Double](count: 3, repeatedValue: 0.0)
// 再创建另外一个[Double]类型的数组
var anotherThreeDoubles = [Double](count: 3, repeatedValue: 2.5)
var sixDoubles = threeDoubles + anotherThreeDoubles
// 相加后类型推断为[Double], 值为[0.0, 0.0, 0.0, 2.5, 2.5, 2.5]

// 或者下面两种方式初始化
var shoppingList: [String] = ["Eggs", "Milk"]
var shoppingList = ["Eggs", "Milk"]
shoppingList.count    // 数组大小
shoppingList.isEmpty  // 是否为空

// 数组相加
shoppingList += ["Baking Powder"]
shoppingList += ["Chocolate Spread", "Cheese", "Butter"]
// 获取第一个值
var firstItem = shoppingList[0]
// 更改第一个值
shoppingList[0] = "Six eggs"
//  用"Bananas" and "Apples"替换索引4、5、6的"Chocolate Spread", "Cheese"和"Butter"
shoppingList[4...6] = ["Bananas", "Apples"]

// 在指定位置插入值
shoppingList.insert("Maple Syrup", atIndex: 0)
// 移除指定位置的值
let mapleSyrup = shoppingList.removeAtIndex(0)
// 移除最后一个值
let apples = shoppingList.removeLast()

// 遍历数组
for item in shoppingList {
    print(item)
}
for (index, value) in shoppingList.enumerate() {
    print("Item \(index + 1): \(value)")
}
</pre>

Set：
Set必须存储可哈希的类型， 如果a == b, 那么a.hashValue == b.hashValue。Swift’s 基本类型(String, Int, Double和Bool)默认都是可哈希的。
<pre>
// 创建一个空集合
var letters = Set<Character>()
// 插入值
letters.insert("a")
// 置空，还是Set<Character>类型
letters = []

// 两种初始化
var favoriteGenres: Set<String> = ["Rock", "Classical", "Hip hop"]
var favoriteGenres: Set = ["Rock", "Classical", "Hip hop"]

favoriteGenres.count        // 集合大小
favoriteGenres.isEmpty      // 是否为空

favoriteGenres.insert("Jazz")      // 插入值
favoriteGenres.remove("Rock")      // 删除值
favoriteGenres.contains("Funk")    // 判断是否包含某个值

// 遍历集合
for genre in favoriteGenres {
    print("\(genre)")
}
// 排序后遍历
for genre in favoriteGenres.sort() {
    print("\(genre)")
}
</pre>

基本的Set操作：
<img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png" alt="基本的Set操作" />

intersect(_:) 返回共同值的集合.
exclusiveOr(_:) 返回不同值的集合.
union(_:) 返回两个集合合并后的集合，忽略重复的值.
subtract(_:) 返回一个集合中得值不在另一个集合的值的集合.
<pre>
let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]
 
oddDigits.union(evenDigits).sort()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
oddDigits.intersect(evenDigits).sort()
// []
oddDigits.subtract(singleDigitPrimeNumbers).sort()
// [1, 9]
oddDigits.exclusiveOr(singleDigitPrimeNumbers).sort()
// [1, 2, 9]
</pre>

使用(==)判断两个集合所有的值是否相等
使用isSubsetOf(_:)判断一个集合是否为另一个集合的子集
使用isSupersetOf(_:)判断一个集合是否为另一个集合的母集
使用isStrictSubsetOf(_:)或isStrictSupersetOf(_:)判断一个集合是否为另一个集合的子集或母集，但两个集合不相等
使用isDisjointWith(_:)判断两个集合是否有共同的值，没有为true，反之false
<pre>
let houseAnimals: Set = ["dog", "cat"]
let farmAnimals: Set = ["cow", "chicken", "sheep", "dog", "cat"]
let cityAnimals: Set = ["bird", "mouse"]
 
houseAnimals.isSubsetOf(farmAnimals)
// true
farmAnimals.isSupersetOf(houseAnimals)
// true
farmAnimals.isDisjointWith(cityAnimals)
// true
</pre>

Dictionary：
和Set一样，Dictionary的值也要是可哈希的。
<pre>
// 创建一个空字典
var namesOfIntegers = [Int: String]()
namesOfIntegers[16] = "sixteen"
// 置空
namesOfIntegers = [:]

// 两种初始化
var airports: [String: String] = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]
var airports = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]

airports.count          // 字典大小
airports.isEmpty        // 判断是否为空

airports["LHR"] = "London"              // 增加一个字典值
airports["LHR"] = "London Heathrow"     // 修改字典值

// updateValue返回更新前的值
let oldValue = airports.updateValue("Dublin Airport", forKey: "DUB")

// removeValueForKey删除指定key的值，返回被删除的值，如果没有指定的key，则返回nil
let removedValue = airports.removeValueForKey("DUB")

// 遍历键值对
for (airportCode, airportName) in airports {
    print("\(airportCode): \(airportName)")
}
// 遍历键
for airportCode in airports.keys {
    print("Airport code: \(airportCode)")
}
// 遍历值
for airportName in airports.values {
    print("Airport name: \(airportName)")
}

// 分别对键值操作
let airportCodes = [String](airports.keys)      // ["YYZ", "LHR"]
let airportNames = [String](airports.values)    // ["Toronto Pearson", "London Heathrow"]
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>63</wp:post_id>
		<wp:post_date><![CDATA[2015-11-21 15:31:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-21 07:31:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b04%ef%bc%9a%e9%9b%86%e5%90%88%e7%b1%bb%e5%9e%8b-collection-types]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e9%9b%86%e5%90%88"><![CDATA[集合]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[post_views_count]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b04%ef%bc%9a%e9%9b%86%e5%90%88%e7%b1%bb%e5%9e%8b]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记5：控制流 (Control Flow)</title>
		<link>http://www.autoref.cn/?p=69</link>
		<pubDate>Sun, 22 Nov 2015 10:19:51 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=69</guid>
		<description></description>
		<content:encoded><![CDATA[For-In和For循环语句:
<pre>
for index in 1...5 {
    print("\(index) times 5 is \(index * 5)")
}
// 1 times 5 is 5
// 2 times 5 is 10
// 3 times 5 is 15
// 4 times 5 is 20
// 5 times 5 is 25

// 如果不需要一个系列里地每个值，可以用下划线_代替变量名
let base = 3
let power = 10
var answer = 1
for _ in 1...power {
    answer *= base
}
print("\(base) to the power of \(power) is \(answer)")
// 3 to the power of 10 is 59049

// 遍历数组
let names = ["Anna", "Alex", "Brian", "Jack"]
for name in names {
    print("Hello, \(name)!")
}
// Hello, Anna!
// Hello, Alex!
// Hello, Brian!
// Hello, Jack!

// 遍历字典
let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
for (animalName, legCount) in numberOfLegs {
    print("\(animalName)s have \(legCount) legs")
}
// ants have 6 legs
// cats have 4 legs
// spiders have 8 legs

// for循环
for var index = 0; index < 3; ++index {
    print("index is \(index)")
}
// index is 0
// index is 1
// index is 2
</pre>

While循环：
<pre>
let finalSquare = 25
var square = 0
while square < finalSquare {
    print(square)
}

repeat {
    print(square)
} while square < finalSquare
</pre>

if条件语句：
<pre>
var temperatureInFahrenheit = 30
if temperatureInFahrenheit <= 32 {
    print("It's very cold. Consider wearing a scarf.")
}
// It's very cold. Consider wearing a scarf.

temperatureInFahrenheit = 40
if temperatureInFahrenheit <= 32 {
    print("It's very cold. Consider wearing a scarf.")
} else {
    print("It's not that cold. Wear a t-shirt.")
}
// It's not that cold. Wear a t-shirt.

temperatureInFahrenheit = 90
if temperatureInFahrenheit <= 32 {
    print("It's very cold. Consider wearing a scarf.")
} else if temperatureInFahrenheit >= 86 {
    print("It's really warm. Don't forget to wear sunscreen.")
} else {
    print("It's not that cold. Wear a t-shirt.")
}
// It's really warm. Don't forget to wear sunscreen.
</pre>

switch条件语句：
<pre>
// 简单小写字母
let someCharacter: Character = "e"
switch someCharacter {
case "a", "e", "i", "o", "u":
    print("\(someCharacter) is a vowel")
case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
"n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
    print("\(someCharacter) is a consonant")
default:
    print("\(someCharacter) is not a vowel or a consonant")
}
// e is a vowel

// swift的switch语句的每个case中必须包含至少一个语句，下面的例子是错误的：
let anotherCharacter: Character = "a"
switch anotherCharacter {
case "a":
case "A":
    print("The letter A")
default:
    print("Not the letter A")
}
// 执行case "a"时会报错，该条件下没有可以执行的语句

// 间隔匹配
let approximateCount = 62
let countedThings = "moons orbiting Saturn"
var naturalCount: String
switch approximateCount {
case 0:
    naturalCount = "no"
case 1..<5:
    naturalCount = "a few"
case 5..<12:
    naturalCount = "several"
case 12..<100:
    naturalCount = "dozens of"
case 100..<1000:
    naturalCount = "hundreds of"
default:
    naturalCount = "many"
}
print("There are \(naturalCount) \(countedThings).")
// There are dozens of moons orbiting Saturn.

// 元组
let somePoint = (1, 1)
switch somePoint {
case (0, 0):
    print("(0, 0) is at the origin")
case (_, 0):
    print("(\(somePoint.0), 0) is on the x-axis")
case (0, _):
    print("(0, \(somePoint.1)) is on the y-axis")
case (-2...2, -2...2):
    print("(\(somePoint.0), \(somePoint.1)) is inside the box")
default:
    print("(\(somePoint.0), \(somePoint.1)) is outside of the box")
}
// (1, 1) is inside the box

// 值绑定，value临时绑定到case中的变量或常量
let anotherPoint = (2, 0)
switch anotherPoint {
case (let x, 0):
    print("on the x-axis with an x value of \(x)")
case (0, let y):
    print("on the y-axis with a y value of \(y)")
case let (x, y):
    print("somewhere else at (\(x), \(y))")
}
// on the x-axis with an x value of 2

// 使用Where来查验另外的条件
let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
case let (x, y) where x == y:
    print("(\(x), \(y)) is on the line x == y")
case let (x, y) where x == -y:
    print("(\(x), \(y)) is on the line x == -y")
case let (x, y):
    print("(\(x), \(y)) is just some arbitrary point")
}
// (1, -1) is on the line x == -y
</pre>

控制跳转语句：
continue
break
fallthrough
return
throw
<pre>
// continue
let puzzleInput = "great minds think alike"
var puzzleOutput = ""
for character in puzzleInput.characters {
    switch character {
    case "a", "e", "i", "o", "u", " ":
        continue
    default:
        puzzleOutput.append(character)
    }
}
print(puzzleOutput)
// grtmndsthnklk

// break
let numberSymbol: Character = "三"  // Simplified Chinese for the number 3
var possibleIntegerValue: Int?
switch numberSymbol {
case "1", "١", "一", "๑":
    possibleIntegerValue = 1
case "2", "٢", "二", "๒":
    possibleIntegerValue = 2
case "3", "٣", "三", "๓":
    possibleIntegerValue = 3
case "4", "٤", "四", "๔":
    possibleIntegerValue = 4
default:
    break
}
if let integerValue = possibleIntegerValue {
    print("The integer value of \(numberSymbol) is \(integerValue).")
} else {
    print("An integer value could not be found for \(numberSymbol).")
}
// The integer value of 三 is 3.

// Swift语言中的switch不会从上一个case分支跳转到下一个case分支中，只要第一个匹配到的case分支并执行完了语句，整个switch代码块就执行完了。如果需要跳转到下一个case，可以使用Fallthrough
let integerToDescribe = 5
var description = "The number \(integerToDescribe) is"
switch integerToDescribe {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += " a prime number, and also"
    fallthrough
default:
    description += " an integer."
}
print(description)
// The number 5 is a prime number, and also an integer.
</pre>

在swift中可以在其他循环和条件语句中内嵌循环和条件语句，labeled语句通过在冒号前放一个标签充当关键字，当使用break或continue时，可以跳转到指定关键字
<pre>
gameLoop: while square != finalSquare {
    if ++diceRoll == 7 { diceRoll = 1 }
    switch square + diceRoll {
    case finalSquare:
        // diceRoll will move us to the final square, so the game is over
        break gameLoop
    case let newSquare where newSquare > finalSquare:
        // diceRoll will move us beyond the final square, so roll again
        continue gameLoop
    default:
        // this is a valid move, so find out its effect
        square += diceRoll
        square += board[square]
    }
}
</pre>

guard语句，跟if语句一样，都需要一个布尔值来判定，但guard语句一定有else分句，当条件不是true的时候执行else。
<pre>
func greet(person: [String: String]) {
    guard let name = person["name"] else {
        return
    }
    
    print("Hello \(name)!")
    
    guard let location = person["location"] else {
        print("I hope the weather is nice near you.")
        return
    }
    
    print("I hope the weather is nice in \(location).")
}
 
greet(["name": "John"])
// Hello John!
// I hope the weather is nice near you.
greet(["name": "Jane", "location": "Cupertino"])
// Hello Jane!
// I hope the weather is nice in Cupertino.
</pre>

检查API是否可用
<pre>
if #available(iOS 9, OSX 10.10, *) {
    // 在iOS使用iOS 9 APIs on, 在OS X使用OS X v10.10 APIs
} else {
    // 老的API
}
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>69</wp:post_id>
		<wp:post_date><![CDATA[2015-11-22 18:19:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-22 10:19:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b05%ef%bc%9a%e6%8e%a7%e5%88%b6%e6%b5%81-control-flow]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e6%8e%a7%e5%88%b6%e6%b5%81"><![CDATA[控制流]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[post_views_count]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b05%ef%bc%9a%e6%8e%a7%e5%88%b6%e6%b5%81]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记6：函数 (Functions)</title>
		<link>http://www.autoref.cn/?p=72</link>
		<pubDate>Wed, 25 Nov 2015 11:55:12 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=72</guid>
		<description></description>
		<content:encoded><![CDATA[函数sayHello(_:)，一个String类型的参数personName，返回一个String类型的值：
<pre>
func sayHello(personName: String) -> String {
    let greeting = "Hello, " + personName + "!"
    return greeting
}

print(sayHello("Anna"))
// Hello, Anna!
</pre>

函数参数值和返回类型：
<pre>
// 没有参数；返回一个String类型值
func sayHelloWorld() -> String {
    return "hello, world"
}
// hello, world

// 多个参数，用逗号分隔，调用时，第二个参数开始需要写标签；返回一个String类型值
func sayHello(personName: String, alreadyGreeted: Bool) -> String {
    if alreadyGreeted {
        return sayHelloAgain(personName)
    } else {
        return sayHello(personName)
    }
}
print(sayHello("Tim", alreadyGreeted: true))
// Hello again, Tim!

// 没有返回值
func sayGoodbye(personName: String) {
    print("Goodbye, \(personName)!")
}
sayGoodbye("Dave")
// Goodbye, Dave!
// 严格的说，即使没有定义返回值，函数仍然会返回一个特殊值Void，这是一个简单的空元组，可以写成()

// 多个返回值
func minMax(array: [Int]) -> (min: Int, max: Int) {
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..<array.count] {
        if value < currentMin {
            currentMin = value
        } else if value > currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}
let bounds = minMax([8, -6, 2, 109, 3, 71])
print("min is \(bounds.min) and max is \(bounds.max)")
// min is -6 and max is 109
</pre>


如果函数返回一个没有值的元组类型，可以返回一个可选的元组，说明整个元组可能为nil，如返回(Int, Int)? 或 (String, Int, Bool)?。
一个可选的元组类型(Int, Int)?跟一个元组包含可选类型(Int?, Int?)不同，可选的元组类型(Int, Int)?是整个元组可选，不是在元组内的每个值可选。
<pre>
func minMax(array: [Int]) -> (min: Int, max: Int)? {
    if array.isEmpty { return nil }
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..<array.count] {
        if value < currentMin {
            currentMin = value
        } else if value > currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}
if let bounds = minMax([8, -6, 2, 109, 3, 71]) {
    print("min is \(bounds.min) and max is \(bounds.max)")
}
// min is -6 and max is 109
</pre>

函数参数名：函数参数包括外用参数名和本地参数名，外用参数名用来标记参数传递给函数调用，本地参数名在函数内使用。
<pre>
func someFunction(firstParameterName: Int, secondParameterName: Int) {
}
someFunction(1, secondParameterName: 2)
// 第一个参数默认删除外用参数名，第二个参数开始用本地参数名作为外部参数名

// 指定外用参数名：如果提供了一个外用参数名，在调用函数的时候一定要使用
func sayHello(to person: String, and anotherPerson: String) -> String {
    return "Hello \(person) and \(anotherPerson)!"
}
print(sayHello(to: "Bill", and: "Ted"))

// 第二个参数开始如果不想写外部参数名，可以用下划线代替
func someFunction(firstParameterName: Int, _ secondParameterName: Int) {
}
someFunction(1, 2)

// 默认参数值
func someFunction(parameterWithDefault: Int = 12) {
    print(parameterWithDefault)
}
someFunction(6) // 6
someFunction()  // 12

// 可变参数
func arithmeticMean(numbers: Double...) -> Double {
    var total: Double = 0
    for number in numbers {
        total += number
    }
    return total / Double(numbers.count)
}
arithmeticMean(1, 2, 3, 4, 5)       // 3.0
arithmeticMean(3, 8.25, 18.75)      // 10.0

// 常量和变量参数：函数的参数默认是常量，也可以在参数前面加var，来定义一个变量参数
func alignRight(var string: String, totalLength: Int, pad: Character) -> String {
    let amountToPad = totalLength - string.characters.count
    if amountToPad < 1 {
        return string
    }
    let padString = String(pad)
    for _ in 1...amountToPad {
        string = padString + string
    }
    return string
}
let originalString = "hello"
let paddedString = alignRight(originalString, totalLength: 10, pad: "-")
// paddedString = "-----hello"
// originalString = "hello"

// In-Out参数：变量参数只能在函数里面改变，如果需要参数在函数里改变后，在外面保持修改后的值，可以把参数定义为In-Out。In-out参数不能有默认值，可变参数也不能标记为inout，如果标记一个参数为In-Out，就不能同时标记为var或者let。
func swapTwoInts(inout a: Int, inout _ b: Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
// 传递参数时需要在前面加&
var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// someInt is now 107, and anotherInt is now 3
</pre>

函数类型：
<pre>
func addTwoInts(a: Int, _ b: Int) -> Int {
    return a + b
}
// 定义一个函数类型的常量或变量，然后给变量赋个合适的函数
var mathFunction: (Int, Int) -> Int = addTwoInts
print("Result: \(mathFunction(2, 3))")
// Result: 5

// 也可以省略类型
let anotherMathFunction = addTwoInts
// anotherMathFunction推断类型为(Int, Int) -> Int

// 函数类型作为参数类型
func printMathResult(mathFunction: (Int, Int) -> Int, _ a: Int, _ b: Int) {
    print("Result: \(mathFunction(a, b))")
}
printMathResult(addTwoInts, 3, 5)
// Result: 8

// 函数类型作为返回类型
func stepForward(input: Int) -> Int {
    return input + 1
}
func stepBackward(input: Int) -> Int {
    return input - 1
}
func chooseStepFunction(backwards: Bool) -> (Int) -> Int {
    return backwards ? stepBackward : stepForward
}
var currentValue = 3
let moveNearerToZero = chooseStepFunction(currentValue > 0)
// moveNearerToZero推断为stepBackward()函数
print("Counting to zero:")
while currentValue != 0 {
    print("\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}
print("zero!")
// 3...
// 2...
// 1...
// zero!

// 内嵌函数：可以帮上面两个函数stepForward和stepBackward嵌到chooseStepFunction里面去
func chooseStepFunction(backwards: Bool) -> (Int) -> Int {
    func stepForward(input: Int) -> Int { return input + 1 }
    func stepBackward(input: Int) -> Int { return input - 1 }
    return backwards ? stepBackward : stepForward
}
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>72</wp:post_id>
		<wp:post_date><![CDATA[2015-11-25 19:55:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-25 11:55:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b06%ef%bc%9a%e5%87%bd%e6%95%b0-functions]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%87%bd%e6%95%b0"><![CDATA[函数]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[post_views_count]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b06%ef%bc%9a%e5%87%bd%e6%95%b0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记7：闭包 (Closures)</title>
		<link>http://www.autoref.cn/?p=76</link>
		<pubDate>Thu, 26 Nov 2015 13:03:06 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=76</guid>
		<description></description>
		<content:encoded><![CDATA[闭包（Closures）是自包含的功能代码块，可以在代码中使用或者用来作为参数传值。
用Swift标准库中的sort方法来简化闭包写法  
sort函数有两种传参
参数一：数组  
参数二：一个闭包：带有两个参数，这两个参数类型与数组中的元素类型相同，返回值是Bool  
<pre>
// 第一种方式：使用函数  
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
func backwards(s1: String, _ s2: String) -> Bool {
    return s1 > s2
}
var reversed = names.sort(backwards)
// ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
</pre>

闭包表达式：
{ (parameters) -> return type in
    statements
}
<pre>
// 第二种方式：使用闭包方式  
reversed = names.sort({ (s1: String, s2: String) -> Bool in
    return s1 > s2
})
</pre>

根据上下文推断类型
因为排序闭包函数是作为sorted函数的参数进行传入的，Swift可以推断其参数和返回值的类型。 sorted期望第二个参数是类型为(String, String) -> Bool的函数，因此实际上String,String和Bool类型并不需要作为闭包表达式定义中的一部分。因为所有的类型都可以被正确推断，返回箭头(->)和围绕在参数周围的括号也可以被省略：
<pre>
reversed = names.sort( { s1, s2 in return s1 > s2 } )
</pre>
实际上任何情况下，通过内联闭包表达式构造的闭包作为参数传递给函数时，都可以推断出闭包的参数和返回值类型，这意味着几乎不需要利用完整格式构造任何内联闭包。

单表达式闭包隐式返回（Implicit Return From Single-Expression Clossures）
单行表达式闭包可以通过隐藏return关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：
<pre>
reversed = names.sort( { s1, s2 in s1 > s2 } )
</pre>

参数名称缩写（Shorthand Argument Names）
Swift 自动为内联函数提供了参数名称缩写功能，您可以直接通过$0,$1,$2来顺序调用闭包的参数。
如果您在闭包表达式中使用参数名称缩写，您可以在闭包参数列表中省略对其的定义，并且对应参数名称缩写的类型会通过函数类型进行推断。 in关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：
<pre>
reversed = names.sort( { $0 > $1 } )
// 在这个例子中，$0和$1表示闭包中第一个和第二个String类型的参数。
</pre>

运算符函数（Operator Functions）
还有一种更简短的方式来撰写上面例子中的闭包表达式。Swift的String类型定义了关于大于号 (>) 的字符串实现，其作为一个函数接受两个String类型的参数并返回Bool类型的值。可以简单地传递一个大于号，Swift可以自动推断出您想使用大于号的字符串函数实现：
<pre>
reversed = names.sort(>)
</pre>

尾随闭包（Trailing Closures）
如果您需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。 尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。
<pre>
func someFunctionThatTakesAClosure(closure: () -> Void) {
    // 函数体部分
}
// 下面是不使用尾随闭包进行函数调用
someFunctionThatTakesAClosure({
    // 闭包主体部分
})
// 下面是使用尾随闭包进行函数调用
someFunctionThatTakesAClosure() {
    // 闭包主体部分
}

// 注意： 如果函数只需要闭包表达式一个参数，当您使用尾随闭包时，至可以把()省略掉。
reversed = names.sort() { $0 > $1 }
reversed = names.sort { $0 > $1 }

// 当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。 举例来说，Swift的Array类型有一个map方法，其获取一个闭包表达式作为其唯一参数。 数组中的每一个元素调用一次该闭包函数，并返回该元素所映射的值(也可以是不同类型的值)。 具体的映射方式和返回值类型由闭包来指定。当提供给数组闭包函数后，map方法将返回一个新的数组，数组中包含了与原数组一一对应的映射后的值。
// 下例介绍了如何在map方法中使用尾随闭包将Int类型数组[16,58,510]转换为包含对应String类型的数组
let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]

let strings = numbers.map {
    (var number) -> String in
    var output = ""
    while number > 0 {
        output = digitNames[number % 10]! + output
        number /= 10
    }
    return output
}
// strings类型推断为[String]
// ["OneSix", "FiveEight", "FiveOneZero"]
// 注意： 字典digitNames下标后跟着一个叹号 (!)，因为字典下标返回一个可选值 (optional value)，表明即使该 key 不存在也不会查找失败。 在上例中，它保证了number % 10可以总是作为一个digitNames字典的有效下标 key。 因此叹号可以用于强制解析 (force-unwrap) 存储在可选下标项中的String类型值。
</pre>

捕获值（Capturing Values）
Swift最简单的闭包形式是嵌套函数，也就是定义在其他函数的函数体内的函数。 嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。
<pre>
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
//每次调用该函数的时候都会修改runningTotal的值，incrementor捕获了当前runningTotal变量的引用，而不是仅仅复制该变量的初始值。捕获一个引用保证了当makeIncrementor结束时候并不会消失，也保证了当下一次执行incrementor函数时，runningTotal可以继续增加。
// 定义一个叫做incrementByTen的常量，该常量指向一个每次调用会加10的incrementor函数
let incrementByTen = makeIncrementer(forIncrement: 10)
incrementByTen()      // 10
incrementByTen()      // 20
incrementByTen()      // 30
</pre>

闭包是引用类型（Closures Are Reference Types）
无论将函数/闭包赋值给一个常量还是变量，实际上都是将常量/变量的值设置为对应函数/闭包的引用。这也意味着如果将闭包赋值给了两个不同的常量/变量，两个值都会指向同一个闭包。
<pre>
let alsoIncrementByTen = incrementByTen
alsoIncrementByTen()      // 40
</pre>

非逃逸闭包(Nonescaping Closures)
当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，称该闭包从函数中逃逸。当定义接受闭包作为参数的函数时，你可以在参数名之前标注@noescape，用来指明这个闭包是不允许“逃逸”出这个函数的。
<pre>
func someFunctionWithNoescapeClosure(@noescape closure: () -> Void) {
    closure()
}
</pre>
举个例子，sort(_:)方法接受一个用来进行元素比较的闭包作为参数。这个参数被标注了@noescape，因为它确保自己在排序结束之后就没用了。
一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为 completion handler。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：
<pre>
var completionHandlers: [() -> Void] = []
func someFunctionWithEscapingClosure(completionHandler: () -> Void) {
    completionHandlers.append(completionHandler)
}
</pre>
someFunctionWithEscapingClosure(_:)函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果你试图将这个参数标注为@noescape，你将会获得一个编译错误。
将闭包标注为@noescape能在闭包中隐式地引用self
<pre>
class SomeClass {
    var x = 10
    func doSomething() {
        someFunctionWithEscapingClosure { self.x = 100 }
        someFunctionWithNoescapeClosure { x = 200 }
    }
}
 
let instance = SomeClass()
instance.doSomething()
print(instance.x)     // "200"
 
completionHandlers.first?()
print(instance.x)     // "100"
</pre>

自动闭包（Autoclosures）
自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够用一个普通的表达式来代替显式的闭包，从而省略闭包的花括号。
我们经常会调用一个接受闭包作为参数的函数，但是很少实现那样的函数。举个例子来说，assert(condition:message:file:line:)函数接受闭包作为它的condition参数和message参数；它的condition参数仅会在 debug 模式下被求值，它的message参数仅当condition参数为false时被计算求值。
自动闭包让你能够延迟求值，因为代码段不会被执行直到你调用这个闭包。延迟求值对于那些有副作用（Side Effect）和代价昂贵的代码来说是很有益处的，因为你能控制代码什么时候执行。下面的代码展示了闭包如何延时求值。
<pre>
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
print(customersInLine.count)
// prints "5"
 
let customerProvider = { customersInLine.removeAtIndex(0) }
print(customersInLine.count)
// prints "5"
 
print("Now serving \(customerProvider())!")
// prints "Now serving Chris!"
print(customersInLine.count)
// prints "4"
</pre>
尽管在闭包的代码中，customersInLine的第一个元素被移除了，不过在闭包被调用之前，这个元素是不会被移除的。如果这个闭包永远不被调用，那么在闭包里面的表达式将永远不会执行，那意味着列表中的元素永远不会被移除。请注意，customerProvider的类型不是String，而是() -> String，一个没有参数且返回值为String的函数。
将闭包作为参数传递给函数时，你能获得同样的延时求值行为。
<pre>
// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]
func serveCustomer(customerProvider: () -> String) {
    print("Now serving \(customerProvider())!")
}
serveCustomer( { customersInLine.removeAtIndex(0) } )
// prints "Now serving Alex!"
</pre>
serveCustomer(_:)接受一个返回@autoclosure特性暗含了@noescape特性，这个特性在非逃逸闭包一节中有描述。如果你想让这个闭包可以“逃逸”，则应该使用@autoclosure(escaping)特性.顾客名字的显式的闭包。下面这个版本的serveCustomer(_:)完成了相同的操作，不过它并没有接受一个显式的闭包，而是通过将参数标记为@autoclosure来接收一个自动闭包。现在你可以将该函数当做接受String类型参数的函数来调用。customerProvider参数将自动转化为一个闭包，因为该参数被标记了@autoclosure特性。
<pre>
// customersInLine is ["Ewa", "Barry", "Daniella"]
func serveCustomer(@autoclosure customerProvider: () -> String) {
    print("Now serving \(customerProvider())!")
}
serveCustomer(customersInLine.removeAtIndex(0))
// prints "Now serving Ewa!"
</pre>
注意：过度使用autoclosures会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。
<pre>
// customersInLine is ["Barry", "Daniella"]
var customerProviders: [() -> String] = []
func collectCustomerProviders(@autoclosure(escaping) customerProvider: () -> String) {
    customerProviders.append(customerProvider)
}
collectCustomerProviders(customersInLine.removeAtIndex(0))
collectCustomerProviders(customersInLine.removeAtIndex(0))
 
print("Collected \(customerProviders.count) closures.")
// prints "Collected 2 closures."
for customerProvider in customerProviders {
    print("Now serving \(customerProvider())!")
}
// prints "Now serving Barry!"
// prints "Now serving Daniella!"
</pre>
在上面的代码中，collectCustomerProviders(_:)函数并没有调用传入的customerProvider闭包，而是将闭包追加到了customerProviders数组中。这个数组定义在函数作用域范围外，这意味着数组内的闭包将会在函数返回之后被调用。因此，customerProvider参数必须允许“逃逸”出函数作用域。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>76</wp:post_id>
		<wp:post_date><![CDATA[2015-11-26 21:03:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-26 13:03:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b07%ef%bc%9a%e9%97%ad%e5%8c%85-closures]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e9%97%ad%e5%8c%85"><![CDATA[闭包]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[post_views_count]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b07%ef%bc%9a%e9%97%ad%e5%8c%85]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记8：枚举 (Enumerations)</title>
		<link>http://www.autoref.cn/?p=80</link>
		<pubDate>Thu, 26 Nov 2015 17:02:49 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=80</guid>
		<description></description>
		<content:encoded><![CDATA[Swift中的枚举不必给每一个枚举成员提供一个值，可以给枚举成员提供一个原始值，该值的类型可以是字符串，字符，或是一个整型值或浮点数。
枚举语法
<pre>enum SomeEnumeration {
    // 枚举定义放在这里
}
</pre>
用枚举表示指南针四个方向：
<pre>enum CompassPoint {
    case North
    case South
    case East
    case West
}
</pre>
枚举中定义的值（如 North，South，East和West）是这个枚举的成员值，使用case关键字来定义一个新的枚举成员值。在上面的CompassPoint例子中，North，South，East和West不会被隐式地赋值为0，1，2和3，这些枚举成员本身就是完整的值，这些值的类型是已经明确定义好的CompassPoint类型。
多个成员值可以出现在同一行上，用逗号隔开：
<pre>enum Planet {
    case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
}
</pre>
像Swift中其他类型一样，它们的名字（例如CompassPoint和Planet）应该以一个大写字母开头。
<pre>
var directionToHead = CompassPoint.West
</pre>
directionToHead的类型可以在它被CompassPoint的某个值初始化时推断出来，一旦directionToHead被声明为CompassPoint类型，可以使用更简短的点语法将其设置为另一个CompassPoint的值：
<pre>
directionToHead = .East
</pre>
使用switch语句匹配单个枚举值：
<pre>directionToHead = .South
switch directionToHead {
    case .North:
        print("Lots of planets have a north")
    case .South:
        print("Watch out for penguins")
    case .East:
        print("Where the sun rises")
    case .West:
        print("Where the skies are blue")
}
// 输出 "Watch out for penguins”
</pre>

关联值（Associated Values）
可以定义Swift枚举来存储任意类型的关联值，如果需要的话，每个枚举成员的关联值类型可以各不相同。
在Swift中，使用如下方式定义表示两种关联值类型的枚举：
<pre>enum Barcode {
    case UPCA(Int, Int, Int, Int)
    case QRCode(String)
}
</pre>
以上理解为：“定义一个名为Barcode的枚举类型，它的一个成员值是具有(Int，Int，Int，Int)类型关联值的UPCA，另一个成员值是具有String类型关联值的QRCode。”这个定义不提供任何Int或String类型的关联值，它只是定义了，当Barcode常量和变量等于Barcode.UPCA或Barcode.QRCode时，可以存储的关联值的类型。
然后可以使用任意一种关联值类型来创建，例如：
<pre>var productBarcode = Barcode.UPCA(8, 85909, 51226, 3)
</pre>
上面的例子创建了一个名为productBarcode的变量，并将Barcode.UPCA赋值给它，关联的元组值为(8, 85909, 51226, 3)。
再如：
<pre>productBarcode = .QRCode("ABCDEFGHIJKLMNOP")
</pre>
这时，原始的Barcode.UPCA和其整数关联值被新的Barcode.QRCode和其字符串关联值所替代。Barcode类型的常量和变量可以存储一个.UPCA或者一个.QRCode（连同它们的关联值），但是在同一时间只能存储这两个值中的一个。

可以在switch的case分支代码中提取每个关联值作为一个常量（用let前缀）或者作为一个变量（用var前缀）来使用：
<pre>switch productBarcode {
case .UPCA(let numberSystem, let manufacturer, let product, let check):
    print("UPC-A: \(numberSystem), \(manufacturer), \(product), \(check).")
case .QRCode(let productCode):
    print("QR code: \(productCode).")
}
// 输出 "QR code: ABCDEFGHIJKLMNOP."
</pre>
如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，可以只在成员名称前标注一个let或者var：
<pre>switch productBarcode {
case let .UPCA(numberSystem, manufacturer, product, check):
    print("UPC-A: \(numberSystem), \(manufacturer), \(product), \(check).")
case let .QRCode(productCode):
    print("QR code: \(productCode).")
}
// 输出 "QR code: ABCDEFGHIJKLMNOP."
</pre>

原始值（Raw Values）
作为关联值的替代选择，枚举成员可以被默认值（称为原始值）预填充，这些原始值的类型必须相同。

使用 ASCII 码作为原始值的枚举：
<pre>enum ASCIIControlCharacter: Character {
    case Tab = "\t"
    case LineFeed = "\n"
    case CarriageReturn = "\r"
}
</pre>
枚举类型ASCIIControlCharacter的原始值类型被定义为Character，并设置了一些比较常见的ASCII控制字符。原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。
注意：原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，像上述三个 ASCII 码。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值可以变化。

原始值的隐式赋值（Implicitly Assigned Raw Values）
在使用原始值为整数或者字符串类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift会自动赋值。
当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个枚举成员没有设置原始值，其原始值将为0。
<pre>enum Planet: Int {
    case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
}
</pre>
在上面的例子中，Plant.Mercury的显式原始值为1，Planet.Venus的隐式原始值为2，依次类推。

当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。
<pre>enum CompassPoint: String {
    case North, South, East, West
}
</pre>
上面例子中，CompassPoint.South拥有隐式原始值South，依次类推。

使用枚举成员的rawValue属性可以访问该枚举成员的原始值：
<pre>let earthsOrder = Planet.Earth.rawValue
// earthsOrder 值为 3

let sunsetDirection = CompassPoint.West.rawValue
// sunsetDirection 值为 "West"
</pre>

使用原始值初始化枚举实例（Initializing from a Raw Value）
如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做rawValue的参数，参数类型即为原始值类型，返回值则是枚举成员或nil。可以使用这个初始化方法来创建一个新的枚举实例。
利用原始值7创建了枚举成员Uranus：
<pre>
let possiblePlanet = Planet(rawValue: 7)
// possiblePlanet类型为Planet?，值为Planet.Uranus
</pre>
并非所有Int值都可以找到一个匹配的行星。因此，原始值构造器总是返回一个可选的枚举成员。在上面的例子中，possiblePlanet是Planet?类型，或者说“可选的Planet”。
<pre>
let positionToFind = 9
if let somePlanet = Planet(rawValue: positionToFind) {
   switch somePlanet {
      case .Earth:
         print("Mostly harmless")
      default:
         print("Not a safe place for humans")
   }
} else {
   print("There isn't a planet at position \(positionToFind)")
}
// 输出 "There isn't a planet at position 9
</pre>

递归枚举（Recursive Enumerations）
递归枚举（recursive enumeration）是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。在枚举成员前加上indirect来表示该成员可递归。
下面的例子中，枚举类型存储了简单的算术表达式：

<pre>
enum ArithmeticExpression {
   case Number(Int)
   indirect case Addition(ArithmeticExpression, ArithmeticExpression)
   indirect case Multiplication(ArithmeticExpression, ArithmeticExpression)
}
</pre>
也可以在枚举类型开头加上indirect关键字来表明它的所有成员都是可递归的：
<pre>
indirect enum ArithmeticExpression {
   case Number(Int)
   case Addition(ArithmeticExpression, ArithmeticExpression)
   case Multiplication(ArithmeticExpression, ArithmeticExpression)
}
</pre>
上面定义的枚举类型可以存储三种算术表达式：纯数字、两个表达式相加、两个表达式相乘。枚举成员Addition和Multiplication的关联值也是算术表达式。

要操作具有递归性质的数据结构，可以使用递归函数。例如，下面是一个对算术表达式求值的函数：
<pre>
func evaluate(expression: ArithmeticExpression) -&gt; Int {
   switch expression {
      case .Number(let value):
         return value
      case .Addition(let left, let right):
         return evaluate(left) + evaluate(right)
      case .Multiplication(let left, let right):
         return evaluate(left) * evaluate(right)
   }
}

// 计算 (5 + 4) * 2
let five = ArithmeticExpression.Number(5)
let four = ArithmeticExpression.Number(4)
let sum = ArithmeticExpression.Addition(five, four)
let product = ArithmeticExpression.Multiplication(sum, ArithmeticExpression.Number(2))
print(evaluate(product))
// 输出 "18"
</pre>
该函数如果遇到纯数字，就直接返回该数字的值。如果遇到的是加法或乘法运算，则分别计算左边表达式和右边表达式的值，然后相加或相乘。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>80</wp:post_id>
		<wp:post_date><![CDATA[2015-11-27 01:02:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-26 17:02:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b08%ef%bc%9a%e6%9e%9a%e4%b8%be]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e6%9e%9a%e4%b8%be"><![CDATA[枚举]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[post_views_count]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记9：类和结构体 (Classes and Structures)</title>
		<link>http://www.autoref.cn/?p=82</link>
		<pubDate>Sat, 28 Nov 2015 02:49:54 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=82</guid>
		<description></description>
		<content:encoded><![CDATA[类和结构体对比
共同处：
1、定义属性用于存储值
2、定义方法用于提供功能
3、定义附属脚本用于访问值
4、定义构造器用于生成初始化值
5、通过扩展以增加默认实现的功能
6、实现协议以提供某种标准功能

与结构体相比，类还有如下的附加功能：
1、继承允许一个类继承另一个类的特征
2、类型转换允许在运行时检查和解释一个类实例的类型
3、解构器允许一个类实例释放任何其所被分配的资源
4、引用计数允许对一个类的多次引用
注意：结构体总是通过被复制的方式在代码中传递，不使用引用计数。

定义语法
类和结构体有着类似的定义方式。我们通过关键字class和struct来分别表示类和结构体：
<pre>
class SomeClass {
   // class definition goes here
}
struct SomeStructure {
   // structure definition goes here
}
</pre>
注意：在每次定义一个新类或者结构体的时候，实际上是定义了一个新的Swift类型。因此使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），以便符合标准Swift类型的大写命名风格（如String，Int和Bool）。相反的，使用lowerCamelCase这种方式为属性和方法命名（如framerate和incrementCount），以便和类型名区分。
以下是定义结构体和定义类的示例：
<pre>
struct Resolution {
   var width = 0
   var height = 0
}

class VideoMode {
   var resolution = Resolution()
   var interlaced = false
   var frameRate = 0.0
   var name: String?
}
</pre>

类和结构体实例
生成结构体和类实例的语法非常相似：
<pre>
let someResolution = Resolution()
let someVideoMode = VideoMode()
</pre>

属性访问
通过使用点语法（dot syntax），访问实例的属性：
<pre>
print("The width of someResolution is \(someResolution.width)")
// 输出 "The width of someResolution is 0"
</pre>
也可以访问子属性，如VideoMode中Resolution属性的width属性：
<pre>
print("The width of someVideoMode is \(someVideoMode.resolution.width)")
// 输出 "The width of someVideoMode is 0"
</pre>
也可以使用点语法为变量属性赋值：
<pre>
// 允许直接设置结构体属性的子属性
someVideoMode.resolution.width = 1280
print("The width of someVideoMode is now \(someVideoMode.resolution.width)")
// 输出 "The width of someVideoMode is now 1280"
</pre>

结构体类型的成员逐一构造器（Memberwise Initializers for Structure Types）
所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：
<pre>
let vga = Resolution(width:640, height: 480)
</pre>
与结构体不同，类实例没有默认的成员逐一构造器。

结构体和枚举是值类型
值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。
实际上，在Swift中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。

在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。
<pre>
let hd = Resolution(width: 1920, height: 1080)
var cinema = hd     // cinema的值其实是hd的一个拷贝副本，而不是hd本身
</pre>

枚举也遵循相同的行为准则：
<pre>
enum CompassPoint {
   case North, South, East, West
}
var currentDirection = CompassPoint.West
let rememberedDirection = currentDirection
currentDirection = .East
if rememberedDirection == .West {
   print("The remembered direction is still .West")
}
// 输出 "The remembered direction is still .West"
</pre>
上例中rememberedDirection被赋予了currentDirection的值，实际上它被赋予的是值的一个拷贝。赋值过程结束后再修改currentDirection的值并不影响rememberedDirection所储存的原始值的拷贝。

类是引用类型
与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。
下面这个示例，使用了之前定义的VideoMode类：
<pre>
let tenEighty = VideoMode()
tenEighty.resolution = hd
tenEighty.interlaced = true
tenEighty.name = "1080i"
tenEighty.frameRate = 25.0

// tenEighty被赋予名为alsoTenEighty的新常量，同时对alsoTenEighty的帧率进行修改
let alsoTenEighty = tenEighty
alsoTenEighty.frameRate = 30.0

print("The frameRate property of tenEighty is now \(tenEighty.frameRate)")
// 输出 "The frameRate property of theEighty is now 30.0"
// 因为类是引用类型，所以tenEight和alsoTenEight实际上引用的是相同的VideoMode实例
</pre>
需要注意的是tenEighty和alsoTenEighty被声明为常量而不是变量。然而你依然可以改变tenEighty.frameRate和alsoTenEighty.frameRate，因为tenEighty和alsoTenEighty这两个常量的值并未改变。它们并不“存储”这个VideoMode实例，而仅仅是对VideoMode实例的引用。所以，改变的是被引用的VideoMode的frameRate属性，而不是引用VideoMode的常量的值。

恒等运算符
因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。
运用等价于（===）和不等价于（!==）这两个运算符检测两个常量或者变量是否引用同一个实例：
<pre>
if tenEighty === alsoTenEighty {
   print("tenEighty and alsoTenEighty refer to the same Resolution instance.")
}
//输出 "tenEighty and alsoTenEighty refer to the same Resolution instance."
</pre>
注意“等价于”（用三个等号表示，===）与“等于”（用两个等号表示，==）的不同：
1、“等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。
2、“等于”表示两个实例的值“相等”或“相同”。

类和结构体的选择
结构体实例总是通过值传递，类实例总是通过引用传递，这意味两者适用不同的任务。
按照通用的准则，当符合一条或多条以下条件时，考虑构建结构体：
1、该数据结构的主要目的是用来封装少量相关简单数据值。
2、有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。
3、该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。
4、该数据结构不需要去继承另一个既有类型的属性或者行为。

字符串(String)、数组(Array)、和字典(Dictionary)类型的赋值与复制行为
Swift中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>82</wp:post_id>
		<wp:post_date><![CDATA[2015-11-28 10:49:54]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-28 02:49:54]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b09%ef%bc%9a%e7%b1%bb%e5%92%8c%e7%bb%93%e6%9e%84%e4%bd%93-classes-and-structures]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e7%b1%bb"><![CDATA[类]]></category>
		<category domain="post_tag" nicename="%e7%bb%93%e6%9e%84%e4%bd%93"><![CDATA[结构体]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[post_views_count]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>3</wp:comment_id>
			<wp:comment_author><![CDATA[seo plugin]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[esepyqgua@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.SEORankingLinks.com/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[107.172.5.145]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-01-07 03:28:35]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-01-06 19:28:35]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Hello Web Admin, I noticed that your On-Page SEO is is missing a few factors, for one you do not use all three H tags in your post, also I notice that you are not using bold or italics properly in your SEO optimization. On-Page SEO means more now than ever since the new Google update: Panda. No longer are backlinks and simply pinging or sending out a RSS feed the key to getting Google PageRank or Alexa Rankings, You now NEED On-Page SEO. So what is good On-Page SEO?First your keyword must appear in the title.Then it must appear in the URL.You have to optimize your keyword and make sure that it has a nice keyword density of 3-5% in your article with relevant LSI (Latent Semantic Indexing). Then you should spread all H1,H2,H3 tags in your article.Your Keyword should appear in your first paragraph and in the last sentence of the page. You should have relevant usage of Bold and italics of your keyword.There should be one internal link to a page on your blog and you should have one image with an alt tag that has your keyword....wait there's even more Now what if i told you there was a simple Wordpress plugin that does all the On-Page SEO, and automatically for you? That's right AUTOMATICALLY, just watch this 4minute video for more information at. <a href="http://www.SEORankingLinks.com" rel="nofollow">Seo Plugin</a>]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>swift学习笔记10：属性 (Properties)</title>
		<link>http://www.autoref.cn/?p=85</link>
		<pubDate>Sun, 29 Nov 2015 08:07:38 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=85</guid>
		<description></description>
		<content:encoded><![CDATA[存储属性
简单来说，一个存储属性就是存储在特定类或结构体的实例里的一个常量或变量。存储属性可以是变量存储属性（用关键字var定义），也可以是常量存储属性（用关键字let定义）。
下面的例子定义了一个名为FixedLengthRange的结构体，它描述了一个在创建后无法修改值域宽度的区间：
<pre>
struct FixedLengthRange {
   var firstValue: Int
   let length: Int
}
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
// 该区间表示整数0，1，2
rangeOfThreeItems.firstValue = 6
// 该区间现在表示整数6，7，8
</pre>
FixedLengthRange的实例包含一个名为firstValue的变量存储属性和一个名为length的常量存储属性。在上面的例子中，length在创建实例的时候被初始化，因为它是一个常量存储属性，所以之后无法修改它的值。

常量结构体的存储属性
如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使定义了变量存储属性：
<pre>
let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
// 该区间表示整数0，1，2，3
rangeOfFourItems.firstValue = 6
// 会报错。因为rangeOfFourItems被声明成了常量（用let关键字），即使firstValue是一个变量属性，也不能修改它。
</pre>
这是由于结构体属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。属于引用类型的类则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。

延迟存储属性
延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性，在属性声明前使用lazy来标示一个延迟存储属性。
注意：必须将延迟存储属性声明成变量（使用var关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。

下面的例子使用了延迟存储属性来避免复杂类中不必要的初始化：
<pre>
class DataImporter {
   /*
   DataImporter 是一个负责将外部文件中的数据导入的类。
   这个类的初始化会消耗不少时间。
   */
   var fileName = "data.txt"
   // 这里会提供数据导入功能
}

class DataManager {
   lazy var importer = DataImporter()
   var data = [String]()
   // 这里会提供数据管理功能
}

let manager = DataManager()
manager.data.append("Some data")
manager.data.append("Some more data")
// DataImporter 实例的 importer 属性还没有被创建
</pre>
DataManager管理数据时也可能不从文件中导入数据。所以当DataManager的实例被创建时，没必要创建一个DataImporter的实例，更明智的做法是第一次用到DataImporter的时候才去创建它。
由于使用了lazy，importer属性只有在第一次被访问的时候才被创建。比如访问它的属性fileName时：
<pre>
print(manager.importer.fileName)
// DataImporter 实例的 importer 属性现在被创建了
// 输出 "data.txt”
</pre>
注意：如果一个被标记为lazy的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。

计算属性
除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。
<pre>
struct Point {
   var x = 0.0, y = 0.0
}

struct Size {
   var width = 0.0, height = 0.0
}

struct Rect {
   var origin = Point()
   var size = Size()
   var center: Point {
      get {
         let centerX = origin.x + (size.width / 2)
         let centerY = origin.y + (size.height / 2)
         return Point(x: centerX, y: centerY)
      }
      set(newCenter) {
         origin.x = newCenter.x - (size.width / 2)
         origin.y = newCenter.y - (size.height / 2)
      }
   }
}

var square = Rect(origin: Point(x: 0.0, y: 0.0),
size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
print("square.origin is now at (\(square.origin.x), \(square.origin.y))")
// 输出 "square.origin is now at (10.0, 10.0)”
</pre>

便捷setter声明
如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称newValue。下面是使用了便捷setter声明的Rect结构体代码：
<pre>
struct AlternativeRect {
   var origin = Point()
   var size = Size()
   var center: Point {
      get {
         let centerX = origin.x + (size.width / 2)
         let centerY = origin.y + (size.height / 2)
         return Point(x: centerX, y: centerY)
      }
      set {
         origin.x = newValue.x - (size.width / 2)
         origin.y = newValue.y - (size.height / 2)
      }
   }
}
</pre>

只读计算属性
只有 getter 没有 setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。必须使用var关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let关键字只用来声明常量属性，表示初始化后再也无法修改的值。
只读计算属性的声明可以去掉get关键字和花括号：
<pre>
struct Cuboid {
   var width = 0.0, height = 0.0, depth = 0.0
   var volume: Double {
      return width * height * depth
   }
}
let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
print("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")
// 输出 "the volume of fourByFiveByTwo is 40.0"
</pre>

属性观察器
属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，甚至新值和当前值相同的时候也不例外。
可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。
注意：不需要为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化。
可以为属性添加如下的一个或全部观察器：
1、willSet在新的值被设置之前调用
2、didSet在新的值被设置之后立即调用
willSet观察器会将新的属性值作为常量参数传入，在willSet的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称newValue表示。类似地，didSet观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名oldValue。
注意：父类的属性在子类的构造器中被赋值时，它在父类中的willSet和didSet观察器会被调用。

这里是一个willSet和didSet的实际例子，其中定义了一个名为StepCounter的类，用来统计一个人步行时的总步数。这个类可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。
<pre>
class StepCounter {
   var totalSteps: Int = 0 {
      willSet(newTotalSteps) {
         print("About to set totalSteps to \(newTotalSteps)")
      }
      didSet {
         if totalSteps > oldValue {
            print("Added \(totalSteps - oldValue) steps")
         }
      }
   }
}

let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
stepCounter.totalSteps = 360
// About to set totalSteps to 360
// Added 160 steps
stepCounter.totalSteps = 896
// About to set totalSteps to 896
// Added 536 steps
</pre>
如果在一个属性的didSet观察器里为它赋值，这个值会替换之前设置的值。

全局变量和局部变量
计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。
全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy修饰符。
局部范围的常量或变量从不延迟计算。

类型属性
实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。
也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性。
类型属性用于定义某个类型所有实例共享的数据，比如所有实例都能用的一个常量（就像 C 语言中的静态常量），或者所有实例都能访问的一个变量（就像 C 语言中的静态变量）。
存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。
注意：跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。
存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用lazy修饰符。

类型属性语法
在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。
使用关键字static来定义类型属性。在为类定义计算型类型属性时，可以改用关键字class来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法：
<pre>
struct SomeStructure {
   static var storedTypeProperty = "Some value."
   static var computedTypeProperty: Int {
      return 1
   }
}

enum SomeEnumeration {
   static var storedTypeProperty = "Some value."
   static var computedTypeProperty: Int {
      return 6
   }
}

class SomeClass {
   static var storedTypeProperty = "Some value."
   static var computedTypeProperty: Int {
      return 27
   }

   class var overrideableComputedTypeProperty: Int {
      return 107
   }
}

print(SomeStructure.storedTypeProperty)
// 输出 "Some value."
SomeStructure.storedTypeProperty = "Another value."
print(SomeStructure.storedTypeProperty)
// 输出 "Another value.”
print(SomeEnumeration.computedTypeProperty)
// 输出 "6"
print(SomeClass.computedTypeProperty)
// 输出 "27"
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>85</wp:post_id>
		<wp:post_date><![CDATA[2015-11-29 16:07:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-11-29 08:07:38]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b010%ef%bc%9a%e5%b1%9e%e6%80%a7-properties]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%b1%9e%e6%80%a7"><![CDATA[属性]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记11：方法（Methods）</title>
		<link>http://www.autoref.cn/?p=87</link>
		<pubDate>Tue, 01 Dec 2015 14:12:06 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=87</guid>
		<description></description>
		<content:encoded><![CDATA[在Swift中，不仅能选择是否要定义一个类/结构体/枚举，还能灵活地在创建的类型（类/结构体/枚举）上定义方法。

实例方法 (Instance Methods)
实例方法是属于某个特定类、结构体或者枚举类型实例的方法。
定义一个简单的Counter类，对一个动作发生的次数进行计数：
<pre>
class Counter {
   var count = 0
   func increment() {
      ++count
   }
   func incrementBy(amount: Int) {
      count += amount
   }
   func reset() {
      count = 0
   }
}

// 用点语法（dot syntax）调用实例方法
let counter = Counter()
// 初始计数值是0
counter.increment()
// 计数值现在是1
counter.incrementBy(5)
// 计数值现在是6
counter.reset()
// 计数值现在是0
</pre>

方法的局部参数名称和外部参数名称 (Local and External Parameter Names for Methods)
函数参数可以同时有一个局部名称（在函数体内部使用）和一个外部名称（在调用函数时使用）。
定义了一个更复杂的incrementBy(_:)方法：
<pre>
class Counter {
   var count: Int = 0
   func incrementBy(amount: Int, numberOfTimes: Int) {
      count += amount * numberOfTimes
   }
}
</pre>
incrementBy(_:numverOfTimes:)方法有两个参数： amount和numberOfTimes。默认情况下，Swift只把amount当作一个局部名称，但是把numberOfTimes即看作局部名称又看作外部名称。下面调用这个方法：
<pre>
let counter = Counter()
counter.incrementBy(5, numberOfTimes: 3)
// counter 的值现在是 15
</pre>

修改方法的外部参数名称(Modifying External Parameter Name Behavior for Methods)
有时为方法的第一个参数提供一个外部参数名称是非常有用的，尽管这不是默认的行为。你自己可以为第一个参数添加一个显式的外部名称。如果不想为方法的第二个及后续的参数提供一个外部名称，可以通过使用下划线（_）作为该参数的显式外部名称，这样做将覆盖默认行为。

self 属性(The self Property)
类型的每一个实例都有一个隐含属性叫做self，self完全等同于该实例本身。可以在一个实例的实例方法中使用这个隐含的self属性来引用当前实例。
上面例子中的increment方法还可以这样写：
<pre>
func increment() {
   self.count++
}
</pre>
使用这条规则的主要场景是实例方法的某个参数名称与实例的某个属性名称相同的时候。在这种情况下，参数名称享有优先权，并且在引用属性时必须使用一种更严格的方式。这时你可以使用self属性来区分参数名称和属性名称。
下面的例子中，self消除方法参数x和实例属性x之间的歧义：
<pre>
struct Point {
   var x = 0.0, y = 0.0
   func isToTheRightOfX(x: Double) -> Bool {
      return self.x > x
   }
}
let somePoint = Point(x: 4.0, y: 5.0)
if somePoint.isToTheRightOfX(1.0) {
   print("This point is to the right of the line where x == 1.0")
}
// 打印输出: This point is to the right of the line where x == 1.0
</pre>

在实例方法中修改值类型(Modifying Value Types from Within Instance Methods)
结构体和枚举是值类型。一般情况下，值类型的属性不能在它的实例方法中被修改。
但是，如果确实需要在某个特定的方法中修改结构体或者枚举的属性，可以选择变异(mutating)这个方法，然后方法就可以从方法内部改变它的属性；并且它做的任何改变在方法结束时还会保留在原始结构中。方法还可以给它隐含的self属性赋值一个全新的实例，这个新实例在方法结束后将替换原来的实例。
要使用变异方法，将关键字mutating 放到方法的func关键字之前就可以了：
<pre>
struct Point {
   var x = 0.0, y = 0.0
   mutating func moveByX(deltaX: Double, y deltaY: Double) {
      x += deltaX
      y += deltaY
   }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveByX(2.0, y: 3.0)
print("The point is now at (\(somePoint.x), \(somePoint.y))")
// 打印输出: "The point is now at (3.0, 4.0)"
</pre>
注意，不能在结构体类型的常量上调用可变方法，因为其属性不能被改变，即使属性是变量属性：
<pre>
let fixedPoint = Point(x: 3.0, y: 3.0)
fixedPoint.moveByX(2.0, y: 3.0)
// 这里将会报告一个错误
</pre>

在可变方法中给 self 赋值(Assigning to self Within a Mutating Method)
可变方法能够赋给隐含属性self一个全新的实例。上面Point的例子可以用下面的方式改写：
<pre>
struct Point {
   var x = 0.0, y = 0.0
   mutating func moveByX(deltaX: Double, y deltaY: Double) {
      self = Point(x: x + deltaX, y: y + deltaY)
   }
}
</pre>
新版的可变方法moveByX(_:y:)创建了一个新的结构（它的 x 和 y 的值都被设定为目标值）。调用这个版本的方法和调用上个版本的最终结果是一样的。

枚举的可变方法可以把self设置为同一枚举类型中不同的成员：
<pre>
enum TriStateSwitch {
   case Off, Low, High
   mutating func next() {
      switch self {
         case Off:
            self = Low
         case Low:
            self = High
         case High:
            self = Off
      }
   }
}
var ovenLight = TriStateSwitch.Low
ovenLight.next()
// ovenLight 现在等于 .High
ovenLight.next()
// ovenLight 现在等于 .Off
</pre>

类型方法 (Type Methods)
实例方法是被类型的某个实例调用的方法。也可以定义类型本身调用的方法，这种方法就叫做类型方法。声明结构体和枚举的类型方法，在方法的func关键字之前加上关键字static。类可能会用关键字class来允许子类重写父类的方法实现。
在SomeClass类上调用类型方法的例子：
<pre>
class SomeClass {
   static func someTypeMethod() {
      // type method implementation goes here
   }
}
SomeClass.someTypeMethod()
</pre>
在类型方法的方法体中，self指向这个类型本身，而不是类型的某个实例。这意味着你可以用self来消除类型属性和类型方法参数之间的歧义（类似于我们在前面处理实例属性和实例方法参数时做的那样）。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>87</wp:post_id>
		<wp:post_date><![CDATA[2015-12-01 22:12:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-01 14:12:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b011%ef%bc%9a%e6%96%b9%e6%b3%95%ef%bc%88methods%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e6%96%b9%e6%b3%95"><![CDATA[方法]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记12：下标脚本（Subscripts）</title>
		<link>http://www.autoref.cn/?p=89</link>
		<pubDate>Thu, 03 Dec 2015 02:27:35 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=89</guid>
		<description></description>
		<content:encoded><![CDATA[下标脚本语法
下标脚本允许你通过在实例名称后面的方括号中传入一个或者多个索引值来对实例进行存取。语法类似于实例方法语法和计算型属性语法的混合。与定义实例方法类似，定义下标脚本使用subscript关键字，指定一个或多个入参和返回类型。与实例方法不同的是，下标脚本可以设定为读写或只读。这种行为由 getter 和 setter 实现，有点类似计算型属性：
<pre>
subscript(index: Int) -> Int {
    get {
      // 返回一个适当的 Int 类型的值
    }

    set(newValue) {
      // 执行适当的赋值操作
    }
}
</pre>
newValue的类型和下标脚本的返回类型相同。如同计算型属性，可以不指定 setter 的参数（newValue）。如果不指定参数，setter 会提供一个名为newValue的默认参数。

如同只读计算型属性，可以省略只读下标脚本的get关键字。下面代码演示了只读下标脚本的实现，这里定义了一个TimesTable结构体，用来表示传入整数的乘法表：
<pre>
struct TimesTable {
    let multiplier: Int
    subscript(index: Int) -> Int {
        return multiplier * index
    }
}
let threeTimesTable = TimesTable(multiplier: 3)
print("six times three is \(threeTimesTable[6])")
// 输出 "six times three is 18"
</pre>

下标脚本用法
下标脚本的确切含义取决于使用场景。下标脚本通常作为访问集合（collection），列表（list）或序列（sequence）中元素的快捷方式。可以针对自己特定的类或结构体的功能来自由地以最恰当的方式实现下标脚本。

例如，Swift的Dictionary类型实现下标脚本用于对其实例中储存的值进行存取操作。为字典设值时，在下标脚本中使用和字典的键类型相同的键，并把一个和字典的值类型相同的值赋给这个下标脚本：
<pre>
var numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
numberOfLegs["bird"] = 2
</pre>
上例定义一个名为numberOfLegs的变量，并用一个包含三对键值的字典字面量初始化它。numberOfLegs字典的类型被推断为[String: Int]。字典创建完成后，该例子通过下标脚本将String类型的键bird和Int类型的值2添加到字典中。
注意：Swift 的Dictionary类型的下标脚本接受并返回可选类型的值。上例中的numberOfLegs字典通过下标脚本返回的是一个Int?或者说“可选的int”。Dictionary类型之所以如此实现下标脚本，是因为不是每个键都有个对应的值，同时这也提供了一种通过键删除对应值的方式，只需将键对应的值赋值为nil即可。

下标脚本选项
下标脚本可以接受任意数量的入参，并且这些入参可以是任意类型。下标脚本的返回值也可以是任意类型。下标脚本可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。
一个类或结构体可以根据自身需要提供多个下标脚本实现，使用下标脚本时将通过入参的数量和类型进行区分，自动匹配合适的下标脚本，这就是下标脚本的重载。
虽然接受单一入参的下标脚本是最常见的，但也可以根据情况定义接受多个入参的下标脚本。例如下例定义了一个Matrix结构体，用于表示一个Double类型的二维矩阵。Matrix结构体的下标脚本接受两个整型参数：
<pre>
struct Matrix {
    let rows: Int, columns: Int
    var grid: [Double]
    init(rows: Int, columns: Int) {
        self.rows = rows
        self.columns = columns
        grid = Array(count: rows * columns, repeatedValue: 0.0)
    }
    func indexIsValidForRow(row: Int, column: Int) -> Bool {
        return row >= 0 && row < rows && column >= 0 && column < columns
    }
    subscript(row: Int, column: Int) -> Double {
        get {
            assert(indexIsValidForRow(row, column: column), "Index out of range")
            return grid[(row * columns) + column]
        }
        set {
            assert(indexIsValidForRow(row, column: column), "Index out of range")
            grid[(row * columns) + column] = newValue
        }
    }
}
</pre>
Matrix提供了一个接受两个入参的构造方法，入参分别是rows和columns，创建了一个足够容纳rows * columns个Double类型的值的数组。通过传入数组长度和初始值0.0到数组的构造器，将矩阵中每个位置的值初始化为0.0。
可以通过传入合适的row和column的数量来构造一个新的Matrix实例：
<pre>
// 创建一个Matrix实例来表示两行两列的矩阵
var matrix = Matrix(rows: 2, columns: 2)
// 将row和column的值传入下标脚本来为矩阵设值，下标脚本的入参使用逗号分隔
matrix[0, 1] = 1.5
matrix[1, 0] = 3.2

// Matrix包含了一个名为indexIsValidForRow(_:column:)的便利方法，用来检查入参row和column的值是否在矩阵范围内
let someValue = matrix[2, 2]
// 断言将会触发，因为 [2, 2] 已经超过了 matrix 的范围
</pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>89</wp:post_id>
		<wp:post_date><![CDATA[2015-12-03 10:27:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-03 02:27:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b012%ef%bc%9a%e4%b8%8b%e6%a0%87%e8%84%9a%e6%9c%ac%ef%bc%88subscripts%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e4%b8%8b%e6%a0%87%e8%84%9a%e6%9c%ac"><![CDATA[下标脚本]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记13：继承（Inheritance）</title>
		<link>http://www.autoref.cn/?p=91</link>
		<pubDate>Sat, 05 Dec 2015 03:53:24 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=91</guid>
		<description></description>
		<content:encoded><![CDATA[一个类可以继承（inherit）另一个类的方法（methods），属性（properties）和其它特性。当一个类继承其它类时，继承类叫子类（subclass），被继承类叫超类（或父类，superclass）。在Swift中，继承是区分「类」与其它类型的一个基本特征。

定义一个基类（Base class）
不继承于其它类的类，称之为基类（base calss）。Swift中的类并不是从一个通用的基类继承而来。如果不为定义的类指定一个超类的话，这个类就自动成为基类。
<pre>
class Vehicle {
    var currentSpeed = 0.0
    var description: String {
        return "traveling at \(currentSpeed) miles per hour"
    }
    func makeNoise() {
        // 什么也不做
    }
}

let someVehicle = Vehicle()
print("Vehicle: \(someVehicle.description)")
// Vehicle: traveling at 0.0 miles per hour
</pre>

子类生成（Subclassing）
子类生成（Subclassing）指的是在一个已有类的基础上创建一个新的类。子类继承超类的特性，并且可以进一步完善，还可以为子类添加新的特性。
为了指明某个类的超类，将超类名写在子类名的后面，用冒号分隔：
<pre>
// 定义一个叫Bicycle的子类，继承成父类Vehicle，新的Bicycle类自动获得Vehicle类的所有特性
class Bicycle: Vehicle {
    var hasBasket = false
}

// 为特定的Bicycle实例设置hasBasket属性为ture
let bicycle = Bicycle()
bicycle.hasBasket = true

// 修改Bicycle实例所继承的currentSpeed属性，和查询实例所继承的description属性
bicycle.currentSpeed = 15.0
print("Bicycle: \(bicycle.description)")
// Bicycle: traveling at 15.0 miles per hour
</pre>

子类还可以继续被其它类继承，下面的示例为Bicycle创建了一个名为Tandem（双人自行车）的子类：
<pre>
class Tandem: Bicycle {
    var currentNumberOfPassengers = 0
}

// 创建一个Tandem的实例，可以使用它所有的新属性和继承的属性，还能查询从Vehicle继承来的只读属性description
let tandem = Tandem()
tandem.hasBasket = true
tandem.currentNumberOfPassengers = 2
tandem.currentSpeed = 22.0
print("Tandem: \(tandem.description)")
// Tandem: traveling at 22.0 miles per hour
</pre>

重写（Overriding）
子类可以为继承来的实例方法（instance method），类方法（class method），实例属性（instance property），或下标脚本（subscript）提供自己定制的实现（implementation）。这种行为叫重写（overriding）。
如果要重写某个特性，需要在重写定义的前面加上override关键字，任何缺少override关键字的重写都会在编译时被诊断为错误。
override关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保重写定义是正确的。

定义Vehicle的一个新的子类Train，它重写了从Vehicle类继承来的makeNoise()方法：
<pre>
class Train: Vehicle {
    override func makeNoise() {
        print("Choo Choo")
    }
}

let train = Train()
train.makeNoise()
// 打印 "Choo Choo"
</pre>

重写属性的 Getters 和 Setters
可以提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查重写的属性是与超类中同名同类型的属性相匹配的。
可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 getter 和 setter。但是不可以将一个继承来的读写属性重写为一个只读属性。
如果在重写属性中提供了setter，那么也一定要提供 getter。如果不想在重写版本中的 getter 里修改继承来的属性值，可以直接通过super.someProperty来返回继承来的值，其中someProperty是要重写的属性的名字。
<pre>
class Car: Vehicle {
    var gear = 1
    override var description: String {
        return super.description + " in gear \(gear)"
    }
}

let car = Car()
car.currentSpeed = 25.0
car.gear = 3
print("Car: \(car.description)")
// Car: traveling at 25.0 miles per hour in gear 3
</pre>

重写属性观察器（Property Observer）
不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供willSet或didSet实现是不恰当。
此外还要注意，不可以同时提供重写的setter和重写的属性观察器。如果想观察属性值的变化，并且已经为那个属性提供了定制的 setter，那么在setter中就可以观察到任何值变化了。
定义一个新类叫AutomaticCar，它是Car的子类。AutomaticCar表示自动挡汽车，它可以根据当前的速度自动选择合适的挡位:
<pre>
class AutomaticCar: Car {
    override var currentSpeed: Double {
        didSet {
            gear = Int(currentSpeed / 10.0) + 1
        }
    }
}

let automatic = AutomaticCar()
automatic.currentSpeed = 35.0
print("AutomaticCar: \(automatic.description)")
// AutomaticCar: traveling at 35.0 miles per hour in gear 4
</pre>

防止重写
可以通过把方法，属性或下标脚本标记为final来防止它们被重写，只需要在声明关键字前加上final修饰符即可（例如：final var，final func，final class func，以及final subscript）。
如果重写了final方法，属性或下标脚本，在编译时会报错。在类扩展中的方法，属性或下标脚本也可以在扩展的定义里标记为 final。
可以通过在关键字class前添加final修饰符（final class）来将整个类标记为 final 的。这样的类是不可被继承的，试图继承这样的类会导致编译报错。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>91</wp:post_id>
		<wp:post_date><![CDATA[2015-12-05 11:53:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-05 03:53:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b013%ef%bc%9a%e7%bb%a7%e6%89%bf%ef%bc%88inheritance%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e7%bb%a7%e6%89%bf"><![CDATA[继承]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>5</wp:comment_id>
			<wp:comment_author><![CDATA[Sandra]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[qmjfwblvir@udkdoles.net]]></wp:comment_author_email>
			<wp:comment_author_url>http://bbqr.me/4fj5</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[23.94.173.64]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-01-18 07:26:39]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-01-17 23:26:39]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Hi my name is Sandra and I just wanted to drop you a quick note here instead of calling you. I came to your swift学习笔记13：继承（Inheritance） | 小宝的技术锅 page and noticed you could have a lot more hits. I have found that the key to running a successful website is making sure the visitors you are getting are interested in your niche. There is a company that you can get targeted traffic from and they let you try their service for free for 7 days. I managed to get over 300 targeted visitors to day to my website. Visit them here: http://www.arvut.org/1/dft]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>swift学习笔记14：构造过程（Initialization）</title>
		<link>http://www.autoref.cn/?p=93</link>
		<pubDate>Mon, 07 Dec 2015 14:47:33 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=93</guid>
		<description></description>
		<content:encoded><![CDATA[存储属性的初始赋值
类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值。
注意：当为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者（property observers）。

构造器
构造器在创建某个特定类型的新实例时被调用。它的最简形式类似于一个不带任何参数的实例方法，以关键字init命名：
<pre>
init() {
    // 在此处执行构造过程
}
</pre>
定义一个用来保存华氏温度的结构体Fahrenheit，它拥有一个Double类型的存储型属性temperature：
<pre>
struct Fahrenheit {
    var temperature: Double
    init() {
        temperature = 32.0
    }
}
var f = Fahrenheit()
print("The default temperature is \(f.temperature)° Fahrenheit")
// 输出 "The default temperature is 32.0° Fahrenheit”
</pre>

可以使用更简单的方式在定义结构体Fahrenheit时为属性temperature设置默认值：
<pre>
struct Fahrenheit {
    var temperature = 32.0
}
</pre>

构造参数
可以通过输入参数和可选类型的属性来自定义构造过程，也可以在构造过程中修改常量属性。自定义构造过程时，可以在定义中提供构造参数，指定所需值的类型和名字。构造参数的功能和语法跟函数和方法的参数相同。
定义一个包含摄氏度温度的结构体Celsius。它定义了两个不同的构造器：init(fromFahrenheit:)和init(fromKelvin:)，二者分别通过接受不同温标下的温度值来创建新的实例：
<pre>
struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius 是 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius 是 0.0”
</pre>
第一个构造器拥有一个构造参数，其外部名字为fromFahrenheit，内部名字为fahrenheit；第二个构造器也拥有一个构造参数，其外部名字为fromKelvin，内部名字为kelvin。


参数的内部名称和外部名称
跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字。如果在定义构造器时没有提供参数的外部名字，Swift会为每个构造器的参数自动生成一个跟内部名字相同的外部名。

定义一个结构体Color，它包含了三个常量：red、green和blue。这些属性可以存储0.0到1.0之间的值，用来指示颜色中红、绿、蓝成分的含量。
<pre>
struct Color {
    let red, green, blue: Double
    // 第一个构造器，其中包含三个Double类型的构造参数
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
    // 第二个构造器，它只包含名为white的Double类型的参数
    init(white: Double) {
        red   = white
        green = white
        blue  = white
    }
}

// 两种构造器都能用于创建一个新的Color实例，需要为构造器每个外部参数传值：
let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
let halfGray = Color(white: 0.5)

// 如果不通过外部参数名字传值，是没法调用这个构造器的。只要构造器定义了某个外部参数名，就必须使用它，忽略它将导致编译错误
let veryGreen = Color(0.0, 1.0, 0.0)
// 报编译时错误，需要外部名称
</pre>

不带外部名的构造器参数
如果不希望为构造器的某个参数提供外部名字，可以使用下划线(_)来显式描述它的外部名，以此重写上面所说的默认行为。
下面是之前Celsius例子的扩展，跟之前相比添加了一个带有Double类型参数的构造器，其外部名用_代替：
<pre>
struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
    init(_ celsius: Double){
        temperatureInCelsius = celsius
    }
}
let bodyTemperature = Celsius(37.0)
// bodyTemperature.temperatureInCelsius 为 37.0
</pre>

可选属性类型
如果定制的类型包含一个逻辑上允许取值为空的存储型属性——无论是因为它无法在初始化时赋值，还是因为它在之后某个时间点可以赋值为空——都需要将它定义为可选类型optional type。可选类型的属性将自动初始化为nil，表示这个属性是有意在初始化时设置为空的。
下面例子中定义了类SurveyQuestion，它包含一个可选字符串属性response：
<pre>
class SurveyQuestion {
    var text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")
cheeseQuestion.ask()
// 输出 "Do you like cheese?"
cheeseQuestion.response = "Yes, I do like cheese."
</pre>

构造过程中常量属性的修改
可以在构造过程中的任意时间点修改常量属性的值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。
对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。
<pre>
class SurveyQuestion {
    let text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}

let beetsQuestion = SurveyQuestion(text: "How about beets?")
beetsQuestion.ask()
// 输出 "How about beets?"
beetsQuestion.response = "I also like beets. (But not with cheese.)"
</pre>

默认构造器
如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么Swift会给这些结构体或类提供一个默认构造器。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。
下面例子中创建了一个类ShoppingListItem，它封装了购物清单中的某一物品的属性：名字（name）、数量（quantity）和购买状态 purchase state：
<pre>
class ShoppingListItem {
    var name: String?
    var quantity = 1
    var purchased = false
}
var item = ShoppingListItem()
</pre>

结构体的逐一成员构造器
逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。
下面例子中定义了一个结构体Size，它包含两个属性width和height。Swift 可以根据这两个属性的初始赋值0.0自动推导出它们的类型为Double。
<pre>
struct Size {
    var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)
</pre>

值类型的构造器代理
构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重复。
构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给提供给它的构造器。类则不同，它可以继承自其它类，这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。
对于值类型，可以使用self.init在自定义的构造器中引用类型中的其它构造器。并且只能在构造器内部调用self.init。

下面例子将定义一个结构体Rect，用来代表几何矩形。这个例子需要两个辅助的结构体Size和Point，它们各自为其所有的属性提供了初始值0.0。
<pre>
struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}

// 三种方式为Rect创建实例
struct Rect {
    var origin = Point()
    var size = Size()
    // 使用被初始化为默认值的origin和size属性来初始化
    init() {}
    // 提供指定的origin和size实例来初始化
    init(origin: Point, size: Size) {
        self.origin = origin
        self.size = size
    }
    // 提供指定的center和size来初始化
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}

let basicRect = Rect()
// basicRect 的 origin 是 (0.0, 0.0)，size 是 (0.0, 0.0)

let originRect = Rect(origin: Point(x: 2.0, y: 2.0),
    size: Size(width: 5.0, height: 5.0))
// originRect 的 origin 是 (2.0, 2.0)，size 是 (5.0, 5.0)

let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
    size: Size(width: 3.0, height: 3.0))
// centerRect 的 origin 是 (2.5, 2.5)，size 是 (3.0, 3.0)
</pre>

类的继承和构造过程
类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值。
Swift为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们分别是指定构造器和便利构造器。

指定构造器和便利构造器
指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。
便利构造器是类中比较次要的、辅助型的构造器。可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。

指定构造器和便利构造器的语法
<pre>
// 类的指定构造器的写法跟值类型简单构造器一样
init(parameters) {
    statements
}

// 便利构造器也采用相同样式的写法，但需要在init关键字之前放置convenience关键字，并使用空格将它们俩分开
convenience init(parameters) {
    statements
}
</pre>

类的构造器代理规则
为了简化指定构造器和便利构造器之间的调用关系，Swift采用以下三条规则来限制构造器之间的代理调用：
规则 1：指定构造器必须调用其直接父类的的指定构造器。
规则 2：便利构造器必须调用同一类中定义的其它构造器。
规则 3：便利构造器必须最终导致一个指定构造器被调用。

构造器的继承和重写
Swift中的子类默认情况下不会继承父类的构造器。Swift的这种机制可以防止一个父类的简单构造器被一个更专业的子类继承，并被错误地用来创建子类的实例。

注意
父类的构造器仅会在安全和适当的情况下被继承。具体内容请参考后续章节构造器的自动继承。
假如希望自定义的子类中能提供一个或多个跟父类相同的构造器，可以在子类中提供这些构造器的自定义实现。
当在编写一个和父类中指定构造器相匹配的子类构造器时，实际上是在重写父类的这个指定构造器。因此，必须在定义子类构造器时带上override修饰符。即使重写的是系统自动提供的默认构造器，也需要带上override修饰符。
正如重写属性，方法或者是下标脚本，override修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确。
当重写一个父类的指定构造器时，总是需要写override修饰符，即使子类将父类的指定构造器重写为了便利构造器。
相反，如果编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器（每个规则都在上文类的构造器代理规则有所描述），因此，严格意义上来讲，子类并未对一个父类构造器提供重写。最后的结果就是，在子类中“重写”一个父类便利构造器时，不需要加override前缀。

在下面的例子中定义了一个叫Vehicle的基类。基类中声明了一个存储型属性numberOfWheels，它是值为0的Int类型的存储型属性。numberOfWheels属性用于创建名为descrpiption的String类型的计算型属性：
<pre>
class Vehicle {
    var numberOfWheels = 0
    var description: String {
        return "\(numberOfWheels) wheel(s)"
    }
}

// Vehicle类只为存储型属性提供默认值，而不自定义构造器。因此，它会自动获得一个默认构造器。自动获得的默认构造器总会是类中的指定构造器，它可以用于创建numberOfWheels为0的Vehicle实例
let vehicle = Vehicle()
print("Vehicle: \(vehicle.description)")
// Vehicle: 0 wheel(s)
</pre>

下面例子中定义了一个Vehicle的子类Bicycle：
<pre>
class Bicycle: Vehicle {
    override init() {
        super.init()
        numberOfWheels = 2
    }
}
</pre>
子类Bicycle定义了一个自定义指定构造器init()。这个指定构造器和父类的指定构造器相匹配，所以Bicycle中的指定构造器需要带上override修饰符。
Bicycle的构造器init()以调用super.init()方法开始，这个方法的作用是调用Bicycle的父类Vehicle的默认构造器。这样可以确保Bicycle在修改属性之前，它所继承的属性numberOfWheels能被Vehicle类初始化。在调用super.init()之后，属性numberOfWheels的原值被新值2替换。
如果创建一个Bicycle实例，可以调用继承的description计算型属性去查看属性numberOfWheels是否有改变：
<pre>
let bicycle = Bicycle()
print("Bicycle: \(bicycle.description)")
// Bicycle: 2 wheel(s)
</pre>
注意：子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。

构造器的自动继承
如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。
假设为子类中引入的所有新属性都提供了默认值，以下 2 个规则适用：
规则 1：如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。
规则 2：如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器。（即使属性没有默认值，只要实现了父类的所有指定构造器，就会自动继承父类的所有便利构造器）
注意：对于规则 2，子类可以将父类的指定构造器实现为便利构造器。

指定构造器和便利构造器实践
接下来的例子将在实践中展示指定构造器、便利构造器以及构造器的自动继承。这个例子定义了包含三个类Food、RecipeIngredient以及ShoppingListItem的类层次结构，并将演示它们的构造器是如何相互作用的。
类层次中的基类是Food，它是一个简单的用来封装食物名字的类。Food类引入了一个叫做name的String类型的属性，并且提供了两个构造器来创建Food实例：
<pre>
class Food {
    var name: String
    init(name: String) {
        self.name = name
    }
    convenience init() {
        self.init(name: "[Unnamed]")
    }
}
</pre>
类类型没有默认的逐一成员构造器，所以Food类提供了一个接受单一参数name的指定构造器。这个构造器可以使用一个特定的名字来创建新的Food实例：
<pre>
let namedMeat = Food(name: "Bacon")
// namedMeat 的名字是 Bacon
</pre>
Food类中的构造器init(name: String)被定义为一个指定构造器，因为它能确保Food实例的所有存储型属性都被初始化。Food类没有父类，所以init(name: String)构造器不需要调用super.init()来完成构造过程。
Food类同样提供了一个没有参数的便利构造器init()。这个init()构造器为新食物提供了一个默认的占位名字，通过横向代理到指定构造器init(name: String)并给参数name传值[Unnamed]来实现：
<pre>
let mysteryMeat = Food()
// mysteryMeat 的名字是 [Unnamed]
</pre>

类层级中的第二个类是Food的子类RecipeIngredient。RecipeIngredient类构建了食谱中的一味调味剂。它引入了Int类型的属性quantity（以及从Food继承过来的name属性），并且定义了两个构造器来创建RecipeIngredient实例：
<pre>
class RecipeIngredient: Food {
    var quantity: Int
    init(name: String, quantity: Int) {
        self.quantity = quantity
        super.init(name: name)
    }
    override convenience init(name: String) {
        self.init(name: name, quantity: 1)
    }
}
</pre>
RecipeIngredient类拥有一个指定构造器init(name: String, quantity: Int)，它可以用来填充RecipeIngredient实例的所有属性值。这个构造器一开始先将传入的quantity参数赋值给quantity属性，这个属性也是唯一在RecipeIngredient中新引入的属性。随后，构造器向上代理到父类Food的init(name: String)。这个过程满足两段式构造过程中的安全检查 1。
RecipeIngredient还定义了一个便利构造器init(name: String)，它只通过name来创建RecipeIngredient的实例。这个便利构造器假设任意RecipeIngredient实例的quantity为1，所以不需要显式指明数量即可创建出实例。这个便利构造器的定义可以更加方便和快捷地创建实例，并且避免了创建多个quantity为1的RecipeIngredient实例时的代码重复。这个便利构造器只是简单地横向代理到类中的指定构造器，并为quantity参数传递1。
注意，RecipeIngredient的便利构造器init(name: String)使用了跟Food中指定构造器init(name: String)相同的参数。由于这个便利构造器重写了父类的指定构造器init(name: String)，因此必须在前面使用override修饰符（参见构造器的继承和重写）。
尽管RecipeIngredient将父类的指定构造器重写为了便利构造器，它依然提供了父类的所有指定构造器的实现。因此，RecipeIngredient会自动继承父类的所有便利构造器。
在这个例子中，RecipeIngredient的父类是Food，它有一个便利构造器init()。这个便利构造器会被RecipeIngredient继承。这个继承版本的init()在功能上跟Food提供的版本是一样的，只是它会代理到RecipeIngredient版本的init(name: String)而不是Food提供的版本。
所有的这三种构造器都可以用来创建新的RecipeIngredient实例：
<pre>
let oneMysteryItem = RecipeIngredient()
let oneBacon = RecipeIngredient(name: "Bacon")
let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)
</pre>

类层级中第三个也是最后一个类是RecipeIngredient的子类，叫做ShoppingListItem。这个类构建了购物单中出现的某一种调味料。
购物单中的每一项总是从未购买状态开始的。为了呈现这一事实，ShoppingListItem引入了一个布尔类型的属性purchased，它的默认值是false。ShoppingListItem还添加了一个计算型属性description，它提供了关于ShoppingListItem实例的一些文字描述：
<pre>
class ShoppingListItem: RecipeIngredient {
    var purchased = false
    var description: String {
        var output = "\(quantity) x \(name)"
        output += purchased ? " ✔" : " ✘"
        return output
    }
}
</pre>
注意：ShoppingListItem没有定义构造器来为purchased提供初始值，因为添加到购物单的物品的初始状态总是未购买。
由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，ShoppingListItem将自动继承所有父类中的指定构造器和便利构造器。
可以使用全部三个继承来的构造器来创建ShoppingListItem的新实例：
<pre>
var breakfastList = [
    ShoppingListItem(),
    ShoppingListItem(name: "Bacon"),
    ShoppingListItem(name: "Eggs", quantity: 6),
]
breakfastList[0].name = "Orange juice"
breakfastList[0].purchased = true
for item in breakfastList {
    print(item.description)
}
// 1 x orange juice ✔
// 1 x bacon ✘
// 6 x eggs ✘
</pre>
如上所述，例子中通过字面量方式创建了一个数组breakfastList，它包含了三个ShoppingListItem实例，因此数组的类型也能被自动推导为[ShoppingListItem]。在数组创建完之后，数组中第一个ShoppingListItem实例的名字从[Unnamed]更改为Orange juice，并标记为已购买。打印数组中每个元素的描述显示了它们都已按照预期被赋值。

可失败构造器
如果一个类、结构体或枚举类型的对象，在构造过程中有可能失败，则为其定义一个可失败构造器。这里所指的“失败”是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。
为了妥善处理这种构造过程中可能会失败的情况。可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在init关键字后面加添问号(init?)。
注意：可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。可失败构造器会创建一个类型为自身类型的可选类型的对象。通过return nil语句来表明可失败构造器在何种情况下应该“失败”。
注意：严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此只是用return nil表明可失败构造器构造失败，而不要用关键字return来表明构造成功。
下例中，定义了一个名为Animal的结构体，其中有一个名为species的String类型的常量属性。同时该结构体还定义了一个接受一个名为species的String类型参数的可失败构造器。这个可失败构造器检查传入的参数是否为一个空字符串。如果为空字符串，则构造失败。否则，species属性被赋值，构造成功。
<pre>
struct Animal {
    let species: String
    init?(species: String) {
        if species.isEmpty { return nil }
        self.species = species
    }
}
</pre>
可以通过该可失败构造器来构建一个Animal的实例，并检查构造过程是否成功：
<pre>
let someCreature = Animal(species: "Giraffe")
// someCreature 的类型是 Animal? 而不是 Animal

if let giraffe = someCreature {
    print("An animal was initialized with a species of \(giraffe.species)")
}
// 打印 "An animal was initialized with a species of Giraffe"
</pre>
如果给该可失败构造器传入一个空字符串作为其参数，则会导致构造失败：
<pre>
let anonymousCreature = Animal(species: "")
// anonymousCreature 的类型是 Animal?, 而不是 Animal

if anonymousCreature == nil {
    print("The anonymous creature could not be initialized")
}
// 打印 "The anonymous creature could not be initialized"
</pre>
注意：空字符串（如""，而不是"Giraffe"）和一个值为nil的可选类型的字符串是两个完全不同的概念。上例中的空字符串（""）其实是一个有效的，非可选类型的字符串。这里我们之所以让Animal的可失败构造器构造失败，只是因为对于Animal这个类的species属性来说，它更适合有一个具体的值，而不是空字符串。

枚举类型的可失败构造器
可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。
下例中，定义了一个名为TemperatureUnit的枚举类型。其中包含了三个可能的枚举成员(Kelvin，Celsius，和Fahrenheit)，以及一个根据Character值找出所对应的枚举成员的可失败构造器：
<pre>
enum TemperatureUnit {
    case Kelvin, Celsius, Fahrenheit
    init?(symbol: Character) {
        switch symbol {
        case "K":
            self = .Kelvin
        case "C":
            self = .Celsius
        case "F":
            self = .Fahrenheit
        default:
            return nil
        }
    }
}
</pre>
可以利用该可失败构造器在三个枚举成员中获取一个相匹配的枚举成员，当参数的值不能与任何枚举成员相匹配时，则构造失败：
<pre>
let fahrenheitUnit = TemperatureUnit(symbol: "F")
if fahrenheitUnit != nil {
    print("This is a defined temperature unit, so initialization succeeded.")
}
// 打印 "This is a defined temperature unit, so initialization succeeded."

let unknownUnit = TemperatureUnit(symbol: "X")
if unknownUnit == nil {
    print("This is not a defined temperature unit, so initialization failed.")
}
// 打印 "This is not a defined temperature unit, so initialization failed."
</pre>

带原始值的枚举类型的可失败构造器
带原始值的枚举类型会自带一个可失败构造器init?(rawValue:)，该可失败构造器有一个名为rawValue的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。
因此上面的TemperatureUnit的例子可以重写为：
<pre>
enum TemperatureUnit: Character {
    case Kelvin = "K", Celsius = "C", Fahrenheit = "F"
}

let fahrenheitUnit = TemperatureUnit(rawValue: "F")
if fahrenheitUnit != nil {
    print("This is a defined temperature unit, so initialization succeeded.")
}
// 打印 "This is a defined temperature unit, so initialization succeeded."

let unknownUnit = TemperatureUnit(rawValue: "X")
if unknownUnit == nil {
    print("This is not a defined temperature unit, so initialization failed.")
}
// 打印 "This is not a defined temperature unit, so initialization failed."
</pre>

类的可失败构造器
值类型（也就是结构体或枚举）的可失败构造器，可以在构造过程中的任意时间点触发构造失败。比如在前面的例子中，结构体Animal的可失败构造器在构造过程一开始就触发了构造失败，甚至在species属性被初始化前。
而对类而言，可失败构造器只能在类引入的所有存储型属性被初始化后，以及构造器代理调用完成后，才能触发构造失败。
下面例子展示了如何在类的可失败构造器中使用隐式解包可选类型来满足上述要求：
<pre>
class Product {
    let name: String!
    init?(name: String) {
        self.name = name
        if name.isEmpty { return nil }
    }
}
</pre>
上面定义的Product类和之前的Animal结构体很相似。Product类有一个不能为空字符串的常量属性name。为了强制这个要求，Product类使用了可失败构造器确保这个属性的值不是空字符串后，才允许构造成功。
毕竟，Product是一个类而不是结构体，这意味着不同于Animal，Product类的所有可失败构造器必须给name属性一个初始值，然后才能触发构造失败。
上面的例子中，Product类的name属性被定义为隐式解包可选字符串类型（String!）。因为它是一个可选类型，所以它在构造过程中被赋值前，具有默认值nil。这个默认值nil意味着Product类引入的所有存储型属性都有一个有效的初始值。因此，一旦传入一个空字符串，该可失败构造器可以在name属性被赋值前触发构造失败。
因为name属性是一个常量，所以一旦构造成功，name属性肯定有一个非nil的值。即使它被定义为隐式解包可选类型，也完全可以放心大胆地直接访问，而不用检查name属性的值是否为nil：
<pre>
if let bowTie = Product(name: "bow tie") {
    // 不需要检查 bowTie.name 是否为 nil
    print("The product's name is \(bowTie.name)")
}
// 打印 "The product's name is bow tie"
</pre>

构造失败的传递
类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。
无论是向上代理还是横向代理，如果代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。
注意：可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，可以增加一个可能的失败状态到现有的构造过程中。
下面这个例子，定义了一个名为CartItem的Product类的子类。这个类建立了一个在线购物车中的物品的模型，它有一个名为quantity的常量存储型属性，并确保该属性的值至少为1：
<pre>
class CartItem: Product {
    let quantity: Int!
    init?(name: String, quantity: Int) {
        self.quantity = quantity
        super.init(name: name)
        if quantity < 1 { return nil }
    }
}
</pre>
和Product类中的name属性类似，CartItem类中的quantity属性也是隐式解包可选类型。这意味着在构造过程中，该属性在被赋予特定的值之前能有一个默认的初始值nil。
该可失败构造器以向上代理到父类的可失败构造器init(name:)开始。这满足了可失败构造器在触发构造失败前必须总是完成构造器代理调用这个条件。
如果由于name的值为空字符串而导致父类的可失败构造器构造失败，则CartIem类的整个构造过程都将立即失败，之后的构造代码将不会再被执行。如果父类构造成功，CartIem的可失败构造器会进一步验证quantity的值是否不小于1。
如果构造一个name的值为非空字符串，quantity的值不小于1的CartItem实例，则可成功构造：
<pre>
if let twoSocks = CartItem(name: "sock", quantity: 2) {
    print("Item: \(twoSocks.name), quantity: \(twoSocks.quantity)")
}
// 打印 "Item: sock, quantity: 2"
</pre>
如果试图构造一个quantity的值为0的CartItem实例, 则CartItem的可失败构造器会触发构造失败：
<pre>
if let zeroShirts = CartItem(name: "shirt", quantity: 0) {
    print("Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)")
} else {
    print("Unable to initialize zero shirts")
}
// 打印 "Unable to initialize zero shirts"
</pre>
类似的，如果试图构造一个name的值为空字符串的CartItem实例，则父类Product的可失败构造器会触发构造失败：
<pre>
if let oneUnnamed = CartItem(name: "", quantity: 1) {
    print("Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)")
} else {
    print("Unable to initialize one unnamed product")
}
// 打印 "Unable to initialize one unnamed product"
</pre>

重写一个可失败构造器
如同其它的构造器，可以在子类中重写父类的可失败构造器。或者也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。
注意：当用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。
注意：可以用非可失败构造器重写可失败构造器，但反过来却不行。
下例定义了一个名为Document的类，name属性的值必须为一个非空字符串或nil，但不能是一个空字符串：
<pre>
class Document {
    var name: String?
    // 该构造器创建了一个 name 属性的值为 nil 的 document 实例
    init() {}
    // 该构造器创建了一个 name 属性的值为非空字符串的 document 实例
    init?(name: String) {
        self.name = name
        if name.isEmpty { return nil }
    }
}
</pre>
下面这个例子，定义了一个Document类的子类AutomaticallyNamedDocument。这个子类重写了父类的两个指定构造器，确保了无论是使用init()构造器，还是使用init(name:)构造器并为参数传递空字符串，生成的实例中的name属性总有初始"[Untitled]"：
<pre>
class AutomaticallyNamedDocument: Document {
    override init() {
        super.init()
        self.name = "[Untitled]"
    }
    override init(name: String) {
        super.init()
        if name.isEmpty {
            self.name = "[Untitled]"
        } else {
            self.name = name
        }
    }
}
</pre>
AutomaticallyNamedDocument用一个非可失败构造器init(name:)重写了父类的可失败构造器init?(name:)。因为子类用另一种方式处理了空字符串的情况，所以不再需要一个可失败构造器，因此子类用一个非可失败构造器代替了父类的可失败构造器。

可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。比如，下面的UntitledDocument子类的name属性的值总是"[Untitled]"，它在构造过程中使用了父类的可失败构造器init?(name:)：
<pre>
class UntitledDocument: Document {
    override init() {
        super.init(name: "[Untitled]")!
    }
}
</pre>
在这个例子中，如果在调用父类的可失败构造器init?(name:)时传入的是空字符串，那么强制解包操作会引发运行时错误。不过，因为这里是通过非空的字符串常量来调用它，所以并不会发生运行时错误。

可失败构造器 init!
通常来说我们通过在init关键字后添加问号的方式（init?）来定义一个可失败构造器，但也可以通过在init后面添加惊叹号的方式来定义一个可失败构造器（(init!)），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。
可以在init?中代理到init!，反之亦然。也可以用init?重写init!，反之亦然。还可以用init代理到init!，不过，一旦init!构造失败，则会触发一个断言。

必要构造器
在类的构造器前添加required修饰符表明所有该类的子类都必须实现该构造器：
<pre>
class SomeClass {
    required init() {
        // 构造器的实现代码
    }
}
</pre>
在子类重写父类的必要构造器时，必须在子类的构造器前也添加required修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加override修饰符：
<pre>
class SomeSubclass: SomeClass {
    required init() {
        // 构造器的实现代码
    }
}
</pre>

注意：如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现。
通过闭包或函数设置属性的默认值
如果某个存储型属性的默认值需要一些定制或设置，可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。
这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。
下面介绍了如何用闭包为属性提供默认值：
<pre>
class SomeClass {
    let someProperty: SomeType = {
        // 在这个闭包中给 someProperty 创建一个默认值
        // someValue 必须和 SomeType 类型相同
        return someValue
    }()
}
</pre>
注意闭包结尾的大括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。
注意：如果使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着不能在闭包里访问其它属性，即使这些属性有默认值。同样，也不能使用隐式的self属性，或者调用任何实例方法。
下面例子中定义了一个结构体Checkerboard，它构建了西洋跳棋游戏的棋盘：

西洋跳棋棋盘
西洋跳棋游戏在一副黑白格交替的10x10的棋盘中进行。为了呈现这副游戏棋盘，Checkerboard结构体定义了一个属性boardColors，它是一个包含100个Bool值的数组。在数组中，值为true的元素表示一个黑格，值为false的元素表示一个白格。数组中第一个元素代表棋盘上左上角的格子，最后一个元素代表棋盘上右下角的格子。
boardColor数组是通过一个闭包来初始化并设置颜色值的：
<pre>
struct Checkerboard {
    let boardColors: [Bool] = {
        var temporaryBoard = [Bool]()
        var isBlack = false
        for i in 1...10 {
            for j in 1...10 {
                temporaryBoard.append(isBlack)
                isBlack = !isBlack
            }
            isBlack = !isBlack
        }
        return temporaryBoard
    }()
    func squareIsBlackAtRow(row: Int, column: Int) -> Bool {
        return boardColors[(row * 10) + column]
    }
}
</pre>
每当一个新的Checkerboard实例被创建时，赋值闭包会被执行，boardColors的默认值会被计算出来并返回。上面例子中描述的闭包将计算出棋盘中每个格子对应的颜色，并将这些值保存到一个临时数组temporaryBoard中，最后在构建完成时将此数组作为闭包返回值返回。这个返回的数组会保存到boardColors中，并可以通过工具函数squareIsBlackAtRow来查询：
<pre>
let board = Checkerboard()
print(board.squareIsBlackAtRow(0, column: 1))
// 打印 "true"
print(board.squareIsBlackAtRow(9, column: 9))
// 打印 "false"
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>93</wp:post_id>
		<wp:post_date><![CDATA[2015-12-07 22:47:33]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-07 14:47:33]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b014%ef%bc%9a%e6%9e%84%e9%80%a0%e8%bf%87%e7%a8%8b%ef%bc%88initialization%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e6%9e%84%e9%80%a0%e8%bf%87%e7%a8%8b"><![CDATA[构造过程]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记15：析构过程（Deinitialization）</title>
		<link>http://www.autoref.cn/?p=96</link>
		<pubDate>Tue, 08 Dec 2015 16:00:15 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=96</guid>
		<description></description>
		<content:encoded><![CDATA[析构器只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字deinit来标示，类似于构造器要用init来标示。
在类的定义中，每个类最多只能有一个析构器，而且析构器不带任何参数，如下所示：
<pre>
deinit {
    // 执行析构过程
}
</pre>
析构器是在实例释放发生前被自动调用。不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。
因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件）。

析构器实践
这是一个析构器实践的例子。这个例子描述了一个简单的游戏，这里定义了两种新类型，分别是Bank和Player。Bank类管理一种虚拟硬币，确保流通的硬币数量永远不可能超过 10,000。在游戏中有且只能有一个Bank存在，因此Bank用类来实现，并使用静态属性和静态方法来存储和管理其当前状态。
<pre>
class Bank {
    static var coinsInBank = 10_000
    static func vendCoins(var numberOfCoinsToVend: Int) -> Int {
        numberOfCoinsToVend = min(numberOfCoinsToVend, coinsInBank)
        coinsInBank -= numberOfCoinsToVend
        return numberOfCoinsToVend
    }
    static func receiveCoins(coins: Int) {
        coinsInBank += coins
    }
}
</pre>
Bank使用coinsInBank属性来跟踪它当前拥有的硬币数量。Bank还提供了两个方法，vendCoins(_:)和receiveCoins(_:)，分别用来处理硬币的分发和收集。
vendCoins(_:)方法在Bank对象分发硬币之前检查是否有足够的硬币。如果硬币不足，Bank对象会返回一个比请求时小的数字（如果Bank对象中没有硬币了就返回0）。vendCoins方法声明numberOfCoinsToVend为一个变量参数，这样就可以在方法体内部修改分发的硬币数量，而不需要定义一个新的变量。vendCoins方法返回一个整型值，表示提供的硬币的实际数量。
receiveCoins(_:)方法只是将Bank对象接收到的硬币数目加回硬币存储中。
Player类描述了游戏中的一个玩家。每一个玩家在任意时间都有一定数量的硬币存储在他们的钱包中。这通过玩家的coinsInPurse属性来表示：
<pre>
class Player {
    var coinsInPurse: Int
    init(coins: Int) {
        coinsInPurse = Bank.vendCoins(coins)
    }
    func winCoins(coins: Int) {
        coinsInPurse += Bank.vendCoins(coins)
    }
    deinit {
        Bank.receiveCoins(coinsInPurse)
    }
}
</pre>
每个Player实例在初始化的过程中，都从Bank对象获取指定数量的硬币。如果没有足够的硬币可用，Player实例可能会收到比指定数量少的硬币.
Player类定义了一个winCoins(_:)方法，该方法从Bank对象获取一定数量的硬币，并把它们添加到玩家的钱包。Player类还实现了一个析构器，这个析构器在Player实例释放前被调用。在这里，析构器的作用只是将玩家的所有硬币都返还给Bank对象：
<pre>
var playerOne: Player? = Player(coins: 100)
print("A new player has joined the game with \(playerOne!.coinsInPurse) coins")
// 打印 "A new player has joined the game with 100 coins"
print("There are now \(Bank.coinsInBank) coins left in the bank")
// 打印 "There are now 9900 coins left in the bank"
</pre>
创建一个Player实例的时候，会向Bank对象请求 100 个硬币，如果有足够的硬币可用的话。这个Player实例存储在一个名为playerOne的可选类型的变量中。这里使用了一个可选类型的变量，因为玩家可以随时离开游戏，设置为可选使可以追踪玩家当前是否在游戏中。
因为playerOne是可选的，所以访问其coinsInPurse属性来打印钱包中的硬币数量时，使用感叹号（!）来解包：
<pre>
playerOne!.winCoins(2_000)
print("PlayerOne won 2000 coins & now has \(playerOne!.coinsInPurse) coins")
// 输出 "PlayerOne won 2000 coins & now has 2100 coins"
print("The bank now only has \(Bank.coinsInBank) coins left")
// 输出 "The bank now only has 7900 coins left"
</pre>
这里，玩家已经赢得了 2,000 枚硬币，所以玩家的钱包中现在有 2,100 枚硬币，而Bank对象只剩余 7,900 枚硬币。
<pre>
playerOne = nil
print("PlayerOne has left the game")
// 打印 "PlayerOne has left the game"
print("The bank now has \(Bank.coinsInBank) coins")
// 打印 "The bank now has 10000 coins"
</pre>
玩家现在已经离开了游戏。这通过将可选类型的playerOne变量设置为nil来表示，意味着“没有Player实例”。当这一切发生时，playerOne变量对Player实例的引用被破坏了。没有其它属性或者变量引用Player实例，因此该实例会被释放，以便回收内存。在这之前，该实例的析构器被自动调用，玩家的硬币被返还给银行。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>96</wp:post_id>
		<wp:post_date><![CDATA[2015-12-09 00:00:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-08 16:00:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b015%ef%bc%9a%e6%9e%90%e6%9e%84%e8%bf%87%e7%a8%8b%ef%bc%88deinitialization%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e6%9e%90%e6%9e%84%e8%bf%87%e7%a8%8b"><![CDATA[析构过程]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Android OpenGL ES 2.0 一、</title>
		<link>http://www.autoref.cn/?p=234</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=234</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>234</wp:post_id>
		<wp:post_date><![CDATA[2015-12-22 11:49:44]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>首页</title>
		<link>http://www.autoref.cn/?p=251</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=251</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>251</wp:post_id>
		<wp:post_date><![CDATA[2016-01-16 16:58:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_orphaned]]></wp:meta_key>
			<wp:meta_value><![CDATA[1452934720]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[http://www.autoref.cn/]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[251]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[custom]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://www.autoref.cn/?p=252</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=252</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>252</wp:post_id>
		<wp:post_date><![CDATA[2016-01-16 16:58:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type><![CDATA[nav_menu_item]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object_id]]></wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_menu_item_parent]]></wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_type]]></wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_target]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_classes]]></wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_object]]></wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_xfn]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_url]]></wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_menu_item_orphaned]]></wp:meta_key>
			<wp:meta_value><![CDATA[1452934720]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Android补间动画（Tweened Animations）</title>
		<link>http://www.autoref.cn/?p=260</link>
		<pubDate>Fri, 22 Jan 2016 10:23:27 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=260</guid>
		<description></description>
		<content:encoded><![CDATA[Android补间动画类型有：AlphaAnimation（透明度动画）、RotateAnimation（旋转动画）、 ScaleAnimation（尺寸伸缩动画）、TranslateAnimation（位置移动动画）。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>260</wp:post_id>
		<wp:post_date><![CDATA[2016-01-22 18:23:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-22 10:23:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="alphaanimation"><![CDATA[AlphaAnimation]]></category>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="post_tag" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android%e5%8a%a8%e7%94%bb"><![CDATA[android动画]]></category>
		<category domain="post_tag" nicename="rotateanimation"><![CDATA[RotateAnimation]]></category>
		<category domain="post_tag" nicename="scaleanimation"><![CDATA[ScaleAnimation]]></category>
		<category domain="post_tag" nicename="translateanimation"><![CDATA[TranslateAnimation]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e7%94%bb"><![CDATA[动画]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记16：自动引用计数（Automatic Reference Counting）</title>
		<link>http://www.autoref.cn/?p=98</link>
		<pubDate>Fri, 11 Dec 2015 03:40:02 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=98</guid>
		<description></description>
		<content:encoded><![CDATA[Swift 使用自动引用计数（ARC）机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 内存管理机制会一直起作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。

然而，在少数情况下，ARC 为了能帮助你管理内存，需要更多的关于你的代码之间关系的信息。本章描述了这些情况，并且为你示范怎样启用 ARC 来管理你的应用程序的内存。

注意
引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。

自动引用计数的工作机制
当你每次创建一个类的新的实例的时候，ARC 会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息，以及这个实例所有相关属性的值。

此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。

然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。

为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。

为了使上述成为可能，无论你将实例赋值给属性、常量或变量，它们都会创建此实例的强引用。之所以称之为“强”引用，是因为它会将实例牢牢地保持住，只要强引用还在，实例是不允许被销毁的。


自动引用计数实践
下面的例子展示了自动引用计数的工作机制。例子以一个简单的Person类开始，并定义了一个叫name的常量属性：
<pre>
class Person {
    let name: String
    init(name: String) {
        self.name = name
        print("\(name) is being initialized")
    }
    deinit {
        print("\(name) is being deinitialized")
    }
}
</pre>

Person类有一个构造函数，此构造函数为实例的name属性赋值，并打印一条消息以表明初始化过程生效。Person类也拥有一个析构函数，这个析构函数会在实例被销毁时打印一条消息。

接下来的代码片段定义了三个类型为Person?的变量，用来按照代码片段中的顺序，为新的Person实例建立多个引用。由于这些变量是被定义为可选类型（Person?，而不是Person），它们的值会被自动初始化为nil，目前还不会引用到Person类的实例。
<pre>
var reference1: Person?
var reference2: Person?
var reference3: Person?
</pre>

现在你可以创建Person类的新实例，并且将它赋值给三个变量中的一个：
<pre>
reference1 = Person(name: "John Appleseed")
// prints "John Appleseed is being initialized”
</pre>

应当注意到当你调用Person类的构造函数的时候，“John Appleseed is being initialized”会被打印出来。由此可以确定构造函数被执行。

由于Person类的新实例被赋值给了reference1变量，所以reference1到Person类的新实例之间建立了一个强引用。正是因为这一个强引用，ARC 会保证Person实例被保持在内存中不被销毁。

如果你将同一个Person实例也赋值给其他两个变量，该实例又会多出两个强引用：
<pre>
reference2 = reference1
reference3 = reference1
</pre>

现在这一个Person实例已经有三个强引用了。

如果你通过给其中两个变量赋值nil的方式断开两个强引用（包括最先的那个强引用），只留下一个强引用，Person实例不会被销毁：
<pre>
reference1 = nil
reference2 = nil
</pre>

在你清楚地表明不再使用这个Person实例时，即第三个也就是最后一个强引用被断开时，ARC 会销毁它：
<pre>
reference3 = nil
// 打印 “John Appleseed is being deinitialized”
</pre>

类实例之间的循环强引用
在上面的例子中，ARC 会跟踪你所新创建的Person实例的引用数量，并且会在Person实例不再被需要时销毁它。

然而，我们可能会写出一个类实例的强引用数永远不能变成0的代码。如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的循环强引用。

你可以通过定义类之间的关系为弱引用或无主引用，以替代强引用，从而解决循环强引用的问题。具体的过程在解决类实例之间的循环强引用中有描述。不管怎样，在你学习怎样解决循环强引用之前，很有必要了解一下它是怎样产生的。

下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：Person和Apartment，用来建模公寓和它其中的居民：
<pre>
class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) is being deinitialized") }
}
class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    var tenant: Person?
    deinit { print("Apartment \(unit) is being deinitialized") }
}
</pre>

每一个Person实例有一个类型为String，名字为name的属性，并有一个可选的初始化为nil的apartment属性。apartment属性是可选的，因为一个人并不总是拥有公寓。

类似的，每个Apartment实例有一个叫number，类型为Int的属性，并有一个可选的初始化为nil的tenant属性。tenant属性是可选的，因为一栋公寓并不总是有居民。

这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这让你能够知晓Person和Apartment的实例是否像预期的那样被销毁。

接下来的代码片段定义了两个可选类型的变量john和unit4A，并分别被设定为下面的Apartment和Person的实例。这两个变量都被初始化为nil，这正是可选的优点：
<pre>
var john: Person?
var unit4A: Apartment?
现在你可以创建特定的Person和Apartment实例并将赋值给john和unit4A变量：

john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")
</pre>

现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号是用来展开和访问可选变量john和unit4A中的实例，这样实例的属性才能被赋值：
<pre>
john!.apartment = unit4A
unit4A!.tenant = john
</pre>

不幸的是，这两个实例关联后会产生一个循环强引用。Person实例现在有了一个指向Apartment实例的强引用，而Apartment实例也有了一个指向Person实例的强引用。因此，当你断开john和unit4A变量所持有的强引用时，引用计数并不会降为0，实例也不会被 ARC 销毁：
<pre>
john = nil
unit4A = nil
</pre>

注意，当你把这两个变量设为nil时，没有任何一个析构函数被调用。循环强引用会一直阻止Person和Apartment类实例的销毁，这就在你的应用程序中造成了内存泄漏。
Person和Apartment实例之间的强引用关系保留了下来并且不会被断开。

解决实例之间的循环强引用
Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weak reference）和无主引用（unowned reference）。

弱引用和无主引用允许循环引用中的一个实例引用另外一个实例而不保持强引用。这样实例能够互相引用而不产生循环强引用。

对于生命周期中会变为nil的实例使用弱引用。相反地，对于初始化赋值后再也不会被赋值为nil的实例，使用无主引用。

弱引用

弱引用不会对其引用的实例保持强引用，因而不会阻止 ARC 销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上weak关键字表明这是一个弱引用。

在实例的生命周期中，如果某些时候引用没有值，那么弱引用可以避免循环强引用。如果引用总是有值，则可以使用无主引用，在无主引用中有描述。在上面Apartment的例子中，一个公寓的生命周期中，有时是没有“居民”的，因此适合使用弱引用来解决循环强引用。

注意
弱引用必须被声明为变量，表明其值能在运行时被修改。弱引用不能被声明为常量。
因为弱引用可以没有值，你必须将每一个弱引用声明为可选类型。在 Swift 中，推荐使用可选类型描述可能没有值的类型。

因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为nil。你可以像其他可选值一样，检查弱引用的值是否存在，你将永远不会访问已销毁的实例的引用。

下面的例子跟上面Person和Apartment的例子一致，但是有一个重要的区别。这一次，Apartment的tenant属性被声明为弱引用：
<pre>
class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) is being deinitialized") }
}
class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print("Apartment \(unit) is being deinitialized") }
}
</pre>

然后跟之前一样，建立两个变量（john和unit4A）之间的强引用，并关联两个实例：
<pre>
var john: Person?
var unit4A: Apartment?

john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")

john!.apartment = unit4A
unit4A!.tenant = john
</pre>

Person实例依然保持对Apartment实例的强引用，但是Apartment实例只持有对Person实例的弱引用。这意味着当你断开john变量所保持的强引用时，再也没有指向Person实例的强引用了：

由于再也没有指向Person实例的强引用，该实例会被销毁：
<pre>
john = nil
// 打印 “John Appleseed is being deinitialized”
</pre>

唯一剩下的指向Apartment实例的强引用来自于变量unit4A。如果你断开这个强引用，再也没有指向Apartment实例的强引用了：

由于再也没有指向Apartment实例的强引用，该实例也会被销毁：
<pre>
unit4A = nil
// 打印 “Apartment 4A is being deinitialized”
</pre>

上面的两段代码展示了变量john和unit4A在被赋值为nil后，Person实例和Apartment实例的析构函数都打印出“销毁”的信息。这证明了引用循环被打破了。

注意
在使用垃圾收集的系统里，弱指针有时用来实现简单的缓冲机制，因为没有强引用的对象只会在内存压力触发垃圾收集时才被销毁。但是在 ARC 中，一旦值的最后一个强引用被移除，就会被立即销毁，这导致弱引用并不适合上面的用途。

无主引用

和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字unowned表示这是一个无主引用。

由于无主引用是非可选类型，你不需要在使用它的时候将它展开。无主引用总是可以被直接访问。不过 ARC 无法在实例被销毁后将无主引用设为nil，因为非可选类型的变量不允许被赋值为nil。

注意
如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。使用无主引用，你必须确保引用始终指向一个未销毁的实例。
还需要注意的是如果你试图访问实例已经被销毁的无主引用，Swift 确保程序会直接崩溃，而不会发生无法预期的行为。所以你应当避免这样的事情发生。
下面的例子定义了两个类，Customer和CreditCard，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。

Customer和CreditCard之间的关系与前面弱引用例子中Apartment和Person的关系略微不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，Customer类有一个可选类型的card属性，但是CreditCard类有一个非可选类型的customer属性。

此外，只能通过将一个number值和customer实例传递给CreditCard构造函数的方式来创建CreditCard实例。这样可以确保当创建CreditCard实例时总是有一个customer实例与之关联。

由于信用卡总是关联着一个客户，因此将customer属性定义为无主引用，用以避免循环强引用：
<pre>
class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { print("\(name) is being deinitialized") }
}
class CreditCard {
    let number: UInt64
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { print("Card #\(number) is being deinitialized") }
}
</pre>

注意
CreditCard类的number属性被定义为UInt64类型而不是Int类型，以确保number属性的存储量在 32 位和 64 位系统上都能足够容纳 16 位的卡号。
下面的代码片段定义了一个叫john的可选类型Customer变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为nil：
<pre>
var john: Customer?
</pre>

现在你可以创建Customer类的实例，用它初始化CreditCard实例，并将新创建的CreditCard实例赋值为客户的card属性：
<pre>
john = Customer(name: "John Appleseed")
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</pre>

Customer实例持有对CreditCard实例的强引用，而CreditCard实例持有对Customer实例的无主引用。

由于customer的无主引用，当你断开john变量持有的强引用时，再也没有指向Customer实例的强引用了：

由于再也没有指向Customer实例的强引用，该实例被销毁了。其后，再也没有指向CreditCard实例的强引用，该实例也随之被销毁了：
<pre>
john = nil
// 打印 “John Appleseed is being deinitialized”
// 打印 ”Card #1234567890123456 is being deinitialized”
</pre>

最后的代码展示了在john变量被设为nil后Customer实例和CreditCard实例的构造函数都打印出了“销毁”的信息。


无主引用以及隐式解析可选属性

上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。

Person和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。

Customer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。

然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。

这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。

下面的例子定义了两个类，Country和City，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系，Country类拥有一个capitalCity属性，而City类有一个country属性：
<pre>
class Country {
    let name: String
    var capitalCity: City!
    init(name: String, capitalName: String) {
        self.name = name
        self.capitalCity = City(name: capitalName, country: self)
    }
}
class City {
    let name: String
    unowned let country: Country
    init(name: String, country: Country) {
        self.name = name
        self.country = country
    }
}
</pre>

为了建立两个类的依赖关系，City的构造函数接受一个Country实例作为参数，并且将实例保存到country属性。

Country的构造函数调用了City的构造函数。然而，只有Country的实例完全初始化后，Country的构造函数才能把self传给City的构造函数。（在两段式构造过程中有具体描述）

为了满足这种需求，通过在类型结尾处加上感叹号（City!）的方式，将Country的capitalCity属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样，capitalCity属性的默认值为nil，但是不需要展开它的值就能访问它。（在隐式解析可选类型中有描述）

由于capitalCity默认值为nil，一旦Country的实例在构造函数中给name属性赋值后，整个初始化过程就完成了。这意味着一旦name属性被赋值后，Country的构造函数就能引用并传递隐式的self。Country的构造函数在赋值capitalCity时，就能将self作为参数传递给City的构造函数。

以上的意义在于你可以通过一条语句同时创建Country和City的实例，而不产生循环强引用，并且capitalCity的属性能被直接访问，而不需要通过感叹号来展开它的可选值：
<pre>
var country = Country(name: "Canada", capitalName: "Ottawa")
print("\(country.name)'s capital city is called \(country.capitalCity.name)")
// 打印 “Canada's capital city is called Ottawa”
</pre>

在上面的例子中，使用隐式解析可选值意味着满足了类的构造函数的两个构造阶段的要求。capitalCity属性在初始化完成后，能像非可选值一样使用和存取，同时还避免了循环强引用。


闭包引起的循环强引用
前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破这些循环强引用。

循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如self.someProperty，或者闭包中调用了实例的某个方法，例如self.someMethod()。这两种情况都导致了闭包“捕获”self，从而产生了循环强引用。

循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你是将这个闭包的引用赋值给了属性。实质上，这跟之前的问题是一样的——两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。

Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closuer capture list）。同样的，在学习如何用闭包捕获列表破坏循环强引用之前，先来了解一下这里的循环强引用是如何产生的，这对我们很有帮助。

下面的例子为你展示了当一个闭包引用了self后是如何产生一个循环强引用的。例子中定义了一个叫HTMLElement的类，用一种简单的模型表示 HTML 文档中的一个单独的元素：
<pre>
class HTMLElement {

    let name: String
    let text: String?

    lazy var asHTML: Void -> String = {
        if let text = self.text {
            return "<\(self.name)>\(text)</\(self.name)>"
        } else {
            return "<\(self.name) />"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        print("\(name) is being deinitialized")
    }

}
</pre>

HTMLElement类定义了一个name属性来表示这个元素的名称，例如代表段落的“p”，或者代表换行的“br”。HTMLElement还定义了一个可选属性text，用来设置 HTML 元素呈现的文本。

除了上面的两个属性，HTMLElement还定义了一个lazy属性asHTML。这个属性引用了一个将name和text组合成 HTML 字符串片段的闭包。该属性是Void -> String类型，或者可以理解为“一个没有参数，返回String的函数”。

默认情况下，闭包赋值给了asHTML属性，这个闭包返回一个代表 HTML 标签的字符串。如果text值存在，该标签就包含可选值text；如果text不存在，该标签就不包含文本。对于段落元素，根据text是“some text”还是nil，闭包会返回"<p>some text</p>"或者"<p />"。

可以像实例方法那样去命名、使用asHTML属性。然而，由于asHTML是闭包而不是实例方法，如果你想改变特定 HTML 元素的处理方式的话，可以用自定义的闭包来取代默认值。

例如，可以将一个闭包赋值给asHTML属性，这个闭包能在text属性是nil时使用默认文本，这是为了避免返回一个空的 HTML 标签：
<pre>
let heading = HTMLElement(name: "h1")
let defaultText = "some default text"
heading.asHTML = {
    return "<\(heading.name)>\(heading.text ?? defaultText)</\(heading.name)>"
}
print(heading.asHTML())
// 打印 “<h1>some default text</h1>”
</pre>

注意
asHTML声明为lazy属性，因为只有当元素确实需要被处理为 HTML 输出的字符串时，才需要使用asHTML。也就是说，在默认的闭包中可以使用self，因为只有当初始化完成以及self确实存在后，才能访问lazy属性。
HTMLElement类只提供了一个构造函数，通过name和text（如果有的话）参数来初始化一个新元素。该类也定义了一个析构函数，当HTMLElement实例被销毁时，打印一条消息。

下面的代码展示了如何用HTMLElement类创建实例并打印消息：
<pre>
var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
print(paragraph!.asHTML())
// 打印 “hello, world”
</pre>

注意
上面的paragraph变量定义为可选类型的HTMLElement，因此我们可以赋值nil给它来演示循环强引用。
不幸的是，上面写的HTMLElement类产生了类实例和作为asHTML默认值的闭包之间的循环强引用。

实例的asHTML属性持有闭包的强引用。但是，闭包在其闭包体内使用了self（引用了self.name和self.text），因此闭包捕获了self，这意味着闭包又反过来持有了HTMLElement实例的强引用。这样两个对象就产生了循环强引用。（更多关于闭包捕获值的信息，请参考值捕获）。

注意
虽然闭包多次使用了self，它只捕获HTMLElement实例的一个强引用。
如果设置paragraph变量为nil，打破它持有的HTMLElement实例的强引用，HTMLElement实例和它的闭包都不会被销毁，也是因为循环强引用：
<pre>
paragraph = nil
</pre>

注意，HTMLElement的析构函数中的消息并没有被打印，证明了HTMLElement实例并没有被销毁。

解决闭包引起的循环强引用
在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。

注意
Swift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者self.someMethod()（而不只是someProperty或someMethod()）。这提醒你可能会一不小心就捕获了self。

定义捕获列表

捕获列表中的每一项都由一对元素组成，一个元素是weak或unowned关键字，另一个元素是类实例的引用（例如self）或初始化过的变量（如delegate = self.delegate!）。这些项在方括号中用逗号分开。

如果闭包有参数列表和返回类型，把捕获列表放在它们前面：
<pre>
lazy var someClosure: (Int, String) -> String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -> String in
    // 这里是闭包的函数体
}
</pre>

如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字in放在闭包最开始的地方：
<pre>
lazy var someClosure: Void -> String = {
    [unowned self, weak delegate = self.delegate!] in
    // 这里是闭包的函数体
}
</pre>

弱引用和无主引用

在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为无主引用。

相反的，在被捕获的引用可能会变为nil时，将闭包内的捕获定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为nil。这使我们可以在闭包体内检查它们是否存在。

注意
如果被捕获的引用绝对不会变为nil，应该用无主引用，而不是弱引用。
前面的HTMLElement例子中，无主引用是正确的解决循环强引用的方法。这样编写HTMLElement类来避免循环强引用：
<pre>
class HTMLElement {

    let name: String
    let text: String?

    lazy var asHTML: Void -> String = {
        [unowned self] in
        if let text = self.text {
            return "<\(self.name)>\(text)</\(self.name)>"
        } else {
            return "<\(self.name) />"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        print("\(name) is being deinitialized")
    }

}
</pre>

上面的HTMLElement实现和之前的实现一致，除了在asHTML闭包中多了一个捕获列表。这里，捕获列表是[unowned self]，表示“将self捕获为无主引用而不是强引用”。

和之前一样，我们可以创建并打印HTMLElement实例：
<pre>
var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
print(paragraph!.asHTML())
// 打印 “<p>hello, world</p>”
</pre>

这一次，闭包以无主引用的形式捕获self，并不会持有HTMLElement实例的强引用。如果将paragraph赋值为nil，HTMLElement实例将会被销毁，并能看到它的析构函数打印出的消息：
<pre>
paragraph = nil
// 打印 “p is being deinitialized”
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>98</wp:post_id>
		<wp:post_date><![CDATA[2015-12-11 11:40:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-11 03:40:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b016%ef%bc%9a%e8%87%aa%e5%8a%a8%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%ef%bc%88automatic-reference-counting%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e8%87%aa%e5%8a%a8%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0"><![CDATA[自动引用计数]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记17：可选链式调用（Optional Chaining）</title>
		<link>http://www.autoref.cn/?p=101</link>
		<pubDate>Sun, 13 Dec 2015 09:22:49 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=101</guid>
		<description></description>
		<content:encoded><![CDATA[可选链式调用（Optional Chaining）是一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是nil，那么调用将返回nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为nil，整个调用链都会失败，即返回nil。
Swift 的可选链式调用可以应用于任意类型，并且能检查调用是否成功。

使用可选链式调用代替强制展开
通过在想调用的属性、方法、或下标的可选值（optional value）后面放一个问号（?），可以定义一个可选链。这一点很像在可选值后面放一个叹号（!）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。
为了反映可选链式调用可以在空值（nil）上调用的事实，不论这个调用的属性、方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。可以利用这个返回值来判断可选链式调用是否调用成功，如果调用有返回值则说明调用成功，返回nil则说明调用失败。
特别地，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是Int类型，则会变为Int?类型。

下面几段代码将解释可选链式调用和强制展开的不同。
首先定义两个类Person和Residence：
<pre>
class Person {
    var residence: Residence?
}

class Residence {
    var numberOfRooms = 1
}
</pre>
Residence有一个Int类型的属性numberOfRooms，其默认值为1。Person具有一个可选的residence属性，其类型为Residence?。
如果创建一个新的Person实例，因为它的residence属性是可选的，john属性将初始化为nil：
<pre>
let john = Person()
</pre>
如果使用叹号（!）强制展开获得这个john的residence属性中的numberOfRooms值，会触发运行时错误，因为这时residence没有可以展开的值：
<pre>
let roomCount = john.residence!.numberOfRooms
// 这会引发运行时错误
</pre>
john.residence为非nil值的时候，上面的调用会成功，并且把roomCount设置为Int类型的房间数量。正如上面提到的，当residence为nil的时候上面这段代码会触发运行时错误。

可选链式调用提供了另一种访问numberOfRooms的方式，使用问号（?）来替代原来的叹号（!）：
<pre>
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// 打印 “Unable to retrieve the number of rooms.”
</pre>
在residence后面添加问号之后，Swift 就会在residence不为nil的情况下访问numberOfRooms。
因为访问numberOfRooms有可能失败，可选链式调用会返回Int?类型，或称为“可选的 Int”。如上例所示，当residence为nil的时候，可选的Int将会为nil，表明无法访问numberOfRooms。访问成功时，可选的Int值会通过可选绑定展开，并赋值给非可选类型的roomCount常量。

要注意的是，即使numberOfRooms是非可选的Int时，这一点也成立。只要使用可选链式调用就意味着numberOfRooms会返回一个Int?而不是Int。

可以将一个Residence的实例赋给john.residence，这样它就不再是nil了：
<pre>
john.residence = Residence()
</pre>
john.residence现在包含一个实际的Residence实例，而不再是nil。如果试图使用先前的可选链式调用访问numberOfRooms，它现在将返回值为1的Int?类型的值：
<pre>
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// 打印 “John's residence has 1 room(s).”
</pre>

为可选链式调用定义模型类
通过使用可选链式调用可以调用多层属性、方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性、方法或下标。

下面这段代码定义了四个模型类，这些例子包括多层可选链式调用。为了方便说明，在Person和Residence的基础上增加了Room类和Address类，以及相关的属性、方法以及下标。
Person类的定义基本保持不变：
<pre>
class Person {
    var residence: Residence?
}
</pre>
Residence类比之前复杂些，增加了一个名为rooms的变量属性，该属性被初始化为[Room]类型的空数组：
<pre>
class Residence {
    var rooms = [Room]()
    var numberOfRooms: Int {
        return rooms.count
    }
    subscript(i: Int) -> Room {
        get {
            return rooms[i]
        }
        set {
            rooms[i] = newValue
        }
    }
    func printNumberOfRooms() {
        print("The number of rooms is \(numberOfRooms)")
    }
    var address: Address?
}
</pre>

现在Residence有了一个存储Room实例的数组，numberOfRooms属性被实现为计算型属性，而不是存储型属性。numberOfRooms属性简单地返回rooms数组的count属性的值。
Residence还提供了访问rooms数组的快捷方式，即提供可读写的下标来访问rooms数组中指定位置的元素。
此外，Residence还提供了printNumberOfRooms()方法，这个方法的作用是打印numberOfRooms的值。
最后，Residence还定义了一个可选属性address，其类型为Address?。Address类的定义在下面会说明。

Room类是一个简单类，其实例被存储在rooms数组中。该类只包含一个属性name，以及一个用于将该属性设置为适当的房间名的初始化函数：
<pre>
class Room {
    let name: String
    init(name: String) { self.name = name }
}
</pre>

最后一个类是Address，这个类有三个String?类型的可选属性。buildingName以及buildingNumber属性分别表示某个大厦的名称和号码，第三个属性street表示大厦所在街道的名称：
<pre>
class Address {
    var buildingName: String?
    var buildingNumber: String?
    var street: String?
    func buildingIdentifier() -> String? {
        if buildingName != nil {
            return buildingName
        } else if buildingNumber != nil && street != nil {
            return "\(buildingNumber) \(street)"
        } else {
            return nil
        }
    }
}
</pre>

Address类提供了buildingIdentifier()方法，返回值为String?。 如果buildingName有值则返回buildingName。或者，如果buildingNumber和street均有值则返回buildingNumber。否则，返回nil。

通过可选链式调用访问属性
正如使用可选链式调用代替强制展开中所述，可以通过可选链式调用在一个可选值上访问它的属性，并判断访问是否成功。
下面的代码创建了一个Person实例，然后像之前一样，尝试访问numberOfRooms属性：
<pre>
let john = Person()
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// 打印 “Unable to retrieve the number of rooms.”
</pre>
因为john.residence为nil，所以这个可选链式调用依旧会像先前一样失败。

还可以通过可选链式调用来设置属性值：
<pre>
let someAddress = Address()
someAddress.buildingNumber = "29"
someAddress.street = "Acacia Road"
john.residence?.address = someAddress
</pre>
在这个例子中，通过john.residence来设定address属性也会失败，因为john.residence当前为nil。
上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，等号右侧的代码不会被执行。对于上面的代码来说，很难验证这一点，因为像这样赋值一个常量没有任何副作用。下面的代码完成了同样的事情，但是它使用一个函数来创建Address实例，然后将该实例返回用于赋值。该函数会在返回前打印“Function was called”，这使能验证等号右侧的代码是否被执行。
<pre>
func createAddress() -> Address {
    print("Function was called.")

    let someAddress = Address()
    someAddress.buildingNumber = "29"
    someAddress.street = "Acacia Road"

    return someAddress
}
john.residence?.address = createAddress()
</pre>
没有任何打印消息，可以看出createAddress()函数并未被执行。

通过可选链式调用调用方法
可以通过可选链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值。
Residence类中的printNumberOfRooms()方法打印当前的numberOfRooms值，如下所示：
<pre>
func printNumberOfRooms() {
    print("The number of rooms is \(numberOfRooms)")
}
</pre>
这个方法没有返回值。然而，没有返回值的方法具有隐式的返回类型Void，如无返回值函数中所述。这意味着没有返回值的方法也会返回()，或者说空的元组。
如果在可选值上通过可选链式调用来调用这个方法，该方法的返回类型会是Void?，而不是Void，因为通过可选链式调用得到的返回值都是可选的。这样我们就可以使用if语句来判断能否成功调用printNumberOfRooms()方法，即使方法本身没有定义返回值。通过判断返回值是否为nil可以判断调用是否成功：
<pre>
if john.residence?.printNumberOfRooms() != nil {
    print("It was possible to print the number of rooms.")
} else {
    print("It was not possible to print the number of rooms.")
}
// 打印 “It was not possible to print the number of rooms.”
</pre>
同样的，可以据此判断通过可选链式调用为属性赋值是否成功。在上面的通过可选链式调用访问属性的例子中，我们尝试给john.residence中的address属性赋值，即使residence为nil。通过可选链式调用给属性赋值会返回Void?，通过判断返回值是否为nil就可以知道赋值是否成功：
<pre>
if (john.residence?.address = someAddress) != nil {
    print("It was possible to set the address.")
} else {
    print("It was not possible to set the address.")
}
// 打印 “It was not possible to set the address.”
</pre>

通过可选链式调用访问下标
通过可选链式调用，我们可以在一个可选值上访问下标，并且判断下标调用是否成功。
注意：通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。
下面这个例子用下标访问john.residence属性存储的Residence实例的rooms数组中的第一个房间的名称，因为john.residence为nil，所以下标调用失败了：
<pre>
if let firstRoomName = john.residence?[0].name {
    print("The first room name is \(firstRoomName).")
} else {
    print("Unable to retrieve the first room name.")
}
// 打印 “Unable to retrieve the first room name.”
</pre>
在这个例子中，问号直接放在john.residence的后面，并且在方括号的前面，因为john.residence是可选值。
类似的，可以通过下标，用可选链式调用来赋值：
<pre>
john.residence?[0] = Room(name: "Bathroom")
</pre>
这次赋值同样会失败，因为residence目前是nil。

如果创建一个Residence实例，并为其rooms数组添加一些Room实例，然后将Residence实例赋值给john.residence，那就可以通过可选链和下标来访问数组中的元素：
<pre>
let johnsHouse = Residence()
johnsHouse.rooms.append(Room(name: "Living Room"))
johnsHouse.rooms.append(Room(name: "Kitchen"))
john.residence = johnsHouse

if let firstRoomName = john.residence?[0].name {
    print("The first room name is \(firstRoomName).")
} else {
    print("Unable to retrieve the first room name.")
}
// 打印 “The first room name is Living Room.”
</pre>

访问可选类型的下标
如果下标返回可选类型值，比如 Swift 中Dictionary类型的键的下标，可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用：
<pre>
var testScores = ["Dave": [86, 82, 84], "Bev": [79, 94, 81]]
testScores["Dave"]?[0] = 91
testScores["Bev"]?[0]++
testScores["Brian"]?[0] = 72
// "Dave" 数组现在是 [91, 82, 84]，"Bev" 数组现在是 [80, 94, 81]
</pre>
上面的例子中定义了一个testScores数组，包含了两个键值对，把String类型的键映射到一个Int值的数组。这个例子用可选链式调用把"Dave"数组中第一个元素设为91，把"Bev"数组的第一个元素+1，然后尝试把"Brian"数组中的第一个元素设为72。前两个调用成功，因为testScores字典中包含"Dave"和"Bev"这两个键。但是testScores字典中没有"Brian"这个键，所以第三个调用失败。

连接多层可选链式调用
可以通过连接多个可选链式调用在更深的模型层级中访问属性、方法以及下标。然而，多层可选链式调用不会增加返回值的可选层级。
也就是说：
如果访问的值不是可选的，可选链式调用将会返回可选值。
如果访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。
因此：
通过可选链式调用访问一个Int值，将会返回Int?，无论使用了多少层可选链式调用。
类似的，通过可选链式调用访问Int?值，依旧会返回Int?值，并不会返回Int??。
下面的例子尝试访问john中的residence属性中的address属性中的street属性。这里使用了两层可选链式调用，residence以及address都是可选值：
<pre>
if let johnsStreet = john.residence?.address?.street {
    print("John's street name is \(johnsStreet).")
} else {
    print("Unable to retrieve the address.")
}
// 打印 “Unable to retrieve the address.”
</pre>
john.residence现在包含一个有效的Residence实例。然而，john.residence.address的值当前为nil。因此，调用john.residence?.address?.street会失败。
需要注意的是，上面的例子中，street的属性为String?。john.residence?.address?.street的返回值也依然是String?，即使已经使用了两层可选链式调用。
如果为john.residence.address赋值一个Address实例，并且为address中的street属性设置一个有效值，我们就能过通过可选链式调用来访问street属性：
<pre>
let johnsAddress = Address()
johnsAddress.buildingName = "The Larches"
johnsAddress.street = "Laurel Street"
john.residence?.address = johnsAddress

if let johnsStreet = john.residence?.address?.street {
    print("John's street name is \(johnsStreet).")
} else {
    print("Unable to retrieve the address.")
}
// 打印 “John's street name is Laurel Street.”
</pre>
在上面的例子中，因为john.residence包含一个有效的Residence实例，所以对john.residence的address属性赋值将会成功。

在方法的可选返回值上进行可选链式调用
上面的例子展示了如何在一个可选值上通过可选链式调用来获取它的属性值。我们还可以在一个可选值上通过可选链式调用来调用方法，并且可以根据需要继续在方法的可选返回值上进行可选链式调用。

在下面的例子中，通过可选链式调用来调用Address的buildingIdentifier()方法。这个方法返回String?类型的值。如上所述，通过可选链式调用来调用该方法，最终的返回值依旧会是String?类型：
<pre>
if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
    print("John's building identifier is \(buildingIdentifier).")
}
// 打印 “John's building identifier is The Larches.”
</pre>

如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可：
<pre>
if let beginsWithThe =
    john.residence?.address?.buildingIdentifier()?.hasPrefix("The") {
        if beginsWithThe {
            print("John's building identifier begins with \"The\".")
        } else {
            print("John's building identifier does not begin with \"The\".")
        }
}
// 打印 “John's building identifier begins with "The".”
</pre>
注意：在上面的例子中，在方法的圆括号后面加上问号是因为要在buildingIdentifier()方法的可选返回值上进行可选链式调用，而不是方法本身。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>101</wp:post_id>
		<wp:post_date><![CDATA[2015-12-13 17:22:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-13 09:22:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b017%ef%bc%9a%e5%8f%af%e9%80%89%e9%93%be%e5%bc%8f%e8%b0%83%e7%94%a8%ef%bc%88optional-chaining%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e9%80%89%e9%93%be%e5%bc%8f%e8%b0%83%e7%94%a8"><![CDATA[可选链式调用]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记18：错误处理（Error Handling）</title>
		<link>http://www.autoref.cn/?p=103</link>
		<pubDate>Tue, 15 Dec 2015 06:15:34 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=103</guid>
		<description></description>
		<content:encoded><![CDATA[错误处理（Error handling）是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一流支持。
在Swift中，错误用符合ErrorType协议的类型的值来表示。这个空协议表明该类型可以用于错误处理。
Swift的枚举类型尤为适合构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息。例如，可以这样表示在一个游戏中操作自动贩卖机时可能会出现的错误状态：
<pre>
enum VendingMachineError: ErrorType {
    case InvalidSelection                    //选择无效
    case InsufficientFunds(coinsNeeded: Int) //金额不足
    case OutOfStock                          //缺货
}
</pre>
抛出一个错误表明有意外情况发生，导致正常的执行流程无法继续执行。抛出错误使用throws关键字。例如，下面的代码抛出一个错误，提示贩卖机还需要5个硬币：
<pre>
throw VendingMachineError.InsufficientFunds(coinsNeeded: 5)
</pre>

处理错误
Swift中有4种处理错误的方式。可以把函数抛出的错误传递给调用此函数的代码、用do-catch语句处理错误、将错误作为可选类型处理、或者断言此错误根本不会发生。
Swift 中的错误处理和其他语言中用try，catch和throw进行异常处理很像。和其他语言中（包括 Objective-C ）的异常处理不同的是，Swift 中的错误处理并不涉及解除调用栈，这是一个计算代价高昂的过程。就此而言，throw语句的性能特性是可以和return语句相媲美的。

用 throwing 函数传递错误
为了表示一个函数、方法或构造器可以抛出错误，在函数声明的参数列表之后加上throws关键字。一个标有throws关键字的函数被称作throwing函数。如果这个函数指明了返回值类型，throws关键词需要写在箭头（->）的前面。
<pre>
func canThrowErrors() throws -> String
func cannotThrowErrors() -> String
</pre>
一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。

只有 throwing 函数可以传递错误。任何在某个非 throwing 函数内部抛出的错误只能在函数内部处理。
下面的例子中，VendingMechine类有一个vend(itemNamed:)方法，如果请求的物品不存在、缺货或者花费超过了投入金额，该方法就会抛出一个相应的VendingMachineError：
<pre>
struct Item {
    var price: Int
    var count: Int
}

class VendingMachine {
    var inventory = [
        "Candy Bar": Item(price: 12, count: 7),
        "Chips": Item(price: 10, count: 4),
        "Pretzels": Item(price: 7, count: 11)
    ]
    var coinsDeposited = 0
    func dispenseSnack(snack: String) {
        print("Dispensing \(snack)")
    }

    func vend(itemNamed name: String) throws {
        guard var item = inventory[name] else {
            throw VendingMachineError.InvalidSelection
        }

        guard item.count > 0 else {
            throw VendingMachineError.OutOfStock
        }

        guard item.price <= coinsDeposited else {
            throw VendingMachineError.InsufficientFunds(coinsNeeded: item.price - coinsDeposited)
        }

        coinsDeposited -= item.price
        --item.count
        inventory[name] = item
        dispenseSnack(name)
    }
}
</pre>

因为vend(itemNamed:)方法会传递出它抛出的任何错误，在代码中调用此方法的地方，必须要么直接处理这些错误——使用do-catch语句，try?或try!；要么继续将这些错误传递下去。例如下面例子中，buyFavoriteSnack(_:vendingMachine:)同样是一个 throwing 函数，任何由vend(itemNamed:)方法抛出的错误会一直被传递到buyFavoriteSnack(_:vendingMachine:)函数被调用的地方。
<pre>
let favoriteSnacks = [
    "Alice": "Chips",
    "Bob": "Licorice",
    "Eve": "Pretzels",
]
func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
    let snackName = favoriteSnacks[person] ?? "Candy Bar"
    try vendingMachine.vend(itemNamed: snackName)
}
// 因为vend(itemNamed:)方法能抛出错误，所以在调用的它时候在它前面加了try关键字。
</pre>

用 Do-Catch 处理错误
可以使用一个do-catch语句运行一段闭包代码来处理错误。如果在do子句中的代码抛出了一个错误，这个错误会与catch子句做匹配，从而决定哪条子句能处理它。
下面是do-catch语句的一般形式：
<pre>
do {
    try expression
    statements
} catch pattern 1 {
    statements
} catch pattern 2 where condition {
    statements
}
</pre>
在catch后面写一个匹配模式来表明这个子句能处理什么样的错误。如果一条catch子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为error的局部常量。
catch子句不必将do子句中的代码所抛出的每一个可能的错误都作处理。如果所有catch子句都未处理错误，错误就会传递到周围的作用域。然而，错误还是必须要被某个周围的作用域处理的——要么是一个外围的do-catch错误处理语句，要么是一个 throwing 函数的内部。举例来说，下面的代码处理了VendingMachineError枚举类型的全部枚举值，但是所有其它的错误就必须由它周围的作用域处理：
<pre>
var vendingMachine = VendingMachine()
vendingMachine.coinsDeposited = 8
do {
    try buyFavoriteSnack("Alice", vendingMachine: vendingMachine)
} catch VendingMachineError.InvalidSelection {
    print("Invalid Selection.")
} catch VendingMachineError.OutOfStock {
    print("Out of Stock.")
} catch VendingMachineError.InsufficientFunds(let coinsNeeded) {
    print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
}
// 打印 “Insufficient funds. Please insert an additional 2 coins.”
</pre>
上面的例子中，buyFavoriteSnack(_:vendingMachine:)函数在一个try表达式中调用，因为它能抛出错误。如果错误被抛出，相应的执行会马上转移到catch子句中，并判断这个错误是否要被继续传递下去。如果没有错误抛出，do子句中余下的语句就会被执行。

将错误转换成可选值
可以使用try?通过将错误转换成一个可选值来处理错误。如果在评估try?表达式时一个错误被抛出，那么表达式的值就是nil。例如下面代码中的x和y具有相同的值：
<pre>
func someThrowingFunction() throws -> Int {
    // ...
}

let x = try? someThrowingFunction()

let y: Int?
do {
    y = try someThrowingFunction()
} catch {
    y = nil
}
</pre>
如果someThrowingFunction()抛出一个错误，x和y的值是nil。否则x和y的值就是该函数的返回值。注意，无论someThrowingFunction()的返回值类型是什么类型，x和y都是这个类型的可选类型。例子中此函数返回一个整型，所以x和y是可选整型。

如果想对所有的错误都采用同样的方式来处理，用try?就可以写出简洁的错误处理代码。例如，下面的代码用几种方式来获取数据，如果所有方式都失败了则返回nil：
<pre>
func fetchData() -> Data? {
    if let data = try? fetchDataFromDisk() { return data }
    if let data = try? fetchDataFromServer() { return data }
    return nil
}
</pre>

禁用错误传递
有时知道某个 throwing 函数实际上在运行时是不会抛出错误的，在这种情况下，可以在表达式前面写try!来禁用错误传递，这会把调用包装在一个断言不会有错误抛出的运行时断言中。如果实际上抛出了错误，会得到一个运行时错误。
例如，下面的代码使用了loadImage(_:)函数，该函数从给定的路径加载图片资源，如果图片无法载入则抛出一个错误。在这种情况下，因为图片是和应用绑定的，运行时不会有错误抛出，所以适合禁用错误传递：
<pre>
let photo = try! loadImage("./Resources/John Appleseed.jpg")
</pre>

指定清理操作
可以使用defer语句在即将离开当前代码块时执行一系列语句。该语句能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如return或者break的语句。例如，可以用defer语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。
defer语句将代码的执行延迟到当前的作用域退出之前。该语句由defer关键字和要被延迟执行的语句组成。延迟执行的语句不能包含任何控制转移语句，例如break或是return语句，或是抛出一个错误。延迟执行的操作会按照它们被指定时的顺序的相反顺序执行——也就是说，第一条defer语句中的代码会在第二条defer语句中的代码被执行之后才执行，以此类推。
<pre>
func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }
        while let line = try file.readline() {
            // 处理文件。
        }
        // close(file) 会在这里被调用，即作用域的最后。
    }
}
</pre>
上面的代码使用一条defer语句来确保open(_:)函数有一个相应的对close(_:)函数的调用。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>103</wp:post_id>
		<wp:post_date><![CDATA[2015-12-15 14:15:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-15 06:15:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b018%ef%bc%9a%e9%94%99%e8%af%af%e5%a4%84%e7%90%86%ef%bc%88error-handling%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e9%94%99%e8%af%af%e5%a4%84%e7%90%86"><![CDATA[错误处理]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记19：类型转换（Type Casting）</title>
		<link>http://www.autoref.cn/?p=105</link>
		<pubDate>Thu, 17 Dec 2015 10:05:19 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=105</guid>
		<description></description>
		<content:encoded><![CDATA[类型转换在Swift中使用is和as操作符实现，这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型。也可以用它来检查一个类型是否实现了某个协议。

定义一个类层次作为例子
可以将类型转换用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。下面的代码定义了一个类层次和一个包含了这些类实例的数组，作为类型转换的例子。
<pre>
// 这个类为任何出现在数字媒体库的媒体项提供基础功能
class MediaItem {
    var name: String
    init(name: String) {
        self.name = name
    }
}

// 子类 Movie 封装了与电影相关的额外信息
class Movie: MediaItem {
    var director: String
    init(name: String, director: String) {
        self.director = director
        super.init(name: name)
    }
}

// 增加了一个 artist（艺术家）属性，和相应的初始化器
class Song: MediaItem {
    var artist: String
    init(name: String, artist: String) {
        self.artist = artist
        super.init(name: name)
    }
}

let library = [
    Movie(name: "Casablanca", director: "Michael Curtiz"),
    Song(name: "Blue Suede Shoes", artist: "Elvis Presley"),
    Movie(name: "Citizen Kane", director: "Orson Welles"),
    Song(name: "The One And Only", artist: "Chesney Hawkes"),
    Song(name: "Never Gonna Give You Up", artist: "Rick Astley")
]
// Swift 的类型检测器能够推断出 Movie 和 Song 有共同的父类 MediaItem，数组 library 的类型被推断为 [MediaItem]
</pre>

检查类型（Checking Type）
用类型检查操作符（is）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 true，否则返回 false。

下面的例子定义了两个变量，movieCount 和 songCount，用来计算数组 library 中 Movie 和 Song 类型的实例数量：
<pre>
var movieCount = 0
var songCount = 0

for item in library {
    if item is Movie {
        ++movieCount
    } else if item is Song {
        ++songCount
    }
}
print("Media library contains \(movieCount) movies and \(songCount) songs")
// 打印 “Media library contains 2 movies and 3 songs”
</pre>

向下转型（Downcasting）
某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，可以尝试向下转到它的子类型，用类型转换操作符（as? 或 as!）。
因为向下转型可能会失败，类型转型操作符带有两种不同形式。条件形式（conditional form）as? 返回一个试图向下转成的类型的可选值（optional value）。强制形式 as! 把试图向下转型和强制解包（force-unwraps）转换结果结合为一个操作。

在这个示例中，数组中的每一个 item 可能是 Movie 或 Song。事前不知道每个 item 的真实类型，所以这里使用条件形式的类型转换（as?）去检查循环里的每次下转：
<pre>
for item in library {
    if let movie = item as? Movie {
        print("Movie: '\(movie.name)', dir. \(movie.director)")
    } else if let song = item as? Song {
        print("Song: '\(song.name)', by \(song.artist)")
    }
}

// Movie: 'Casablanca', dir. Michael Curtiz
// Song: 'Blue Suede Shoes', by Elvis Presley
// Movie: 'Citizen Kane', dir. Orson Welles
// Song: 'The One And Only', by Chesney Hawkes
// Song: 'Never Gonna Give You Up', by Rick Astley
</pre>

Any 和 AnyObject 的类型转换
Swift 为不确定类型提供了两种特殊的类型别名：
1、AnyObject可以表示任何类类型的实例。
2、Any可以表示任何类型，包括函数类型。

AnyObject 类型
定义一个 [AnyObject] 类型的数组并填入三个 Movie 类型的实例：
<pre>
let someObjects: [AnyObject] = [
    Movie(name: "2001: A Space Odyssey", director: "Stanley Kubrick"),
    Movie(name: "Moon", director: "Duncan Jones"),
    Movie(name: "Alien", director: "Ridley Scott")
]

// 因为知道这个数组只包含 Movie 实例，可以直接用（as!）下转并解包到非可选的 Movie 类型：
for object in someObjects {
    let movie = object as! Movie
    print("Movie: '\(movie.name)', dir. \(movie.director)")
}
// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick
// Movie: 'Moon', dir. Duncan Jones
// Movie: 'Alien', dir. Ridley Scott

// 为了变为一个更简短的形式，下转 someObjects 数组为 [Movie] 类型而不是下转数组中的每一项：
for movie in someObjects as! [Movie] {
    print("Movie: '\(movie.name)', dir. \(movie.director)")
}
// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick
// Movie: 'Moon', dir. Duncan Jones
// Movie: 'Alien', dir. Ridley Scott
</pre>

Any 类型
使用Any类型来和混合的不同类型一起工作，包括函数类型和非类类型。它创建了一个可以存储Any类型的数组things：
<pre>
var things = [Any]()
things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append("hello")
things.append((3.0, 5.0))
things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))
things.append({ (name: String) -> String in "Hello, \(name)" })

// 迭代 things 数组中的每一项，并用 switch 语句查找每一项的类型。
for thing in things {
    switch thing {
    case 0 as Int:
        print("zero as an Int")
    case 0 as Double:
        print("zero as a Double")
    case let someInt as Int:
        print("an integer value of \(someInt)")
    case let someDouble as Double where someDouble > 0:
        print("a positive double value of \(someDouble)")
    case is Double:
        print("some other double value that I don't want to print")
    case let someString as String:
        print("a string value of \"\(someString)\"")
    case let (x, y) as (Double, Double):
        print("an (x, y) point at \(x), \(y)")
    case let movie as Movie:
        print("a movie called '\(movie.name)', dir. \(movie.director)")
    case let stringConverter as String -> String:
        print(stringConverter("Michael"))
    default:
        print("something else")
    }
}

// zero as an Int
// zero as a Double
// an integer value of 42
// a positive double value of 3.14159
// a string value of "hello"
// an (x, y) point at 3.0, 5.0
// a movie called 'Ghostbusters', dir. Ivan Reitman
// Hello, Michael
</pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>105</wp:post_id>
		<wp:post_date><![CDATA[2015-12-17 18:05:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-17 10:05:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b019%ef%bc%9a%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%ef%bc%88type-casting%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2"><![CDATA[类型转换]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b020%ef%bc%9a%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%ef%bc%88type-casting%ef%bc%89]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记20：嵌套类型（Nested Types）</title>
		<link>http://www.autoref.cn/?p=107</link>
		<pubDate>Sat, 19 Dec 2015 03:17:05 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=107</guid>
		<description></description>
		<content:encoded><![CDATA[要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的{}内，而且可以根据需要定义多级嵌套。

嵌套类型实践
下面这个例子定义了一个结构体BlackjackCard（二十一点），用来模拟BlackjackCard中的扑克牌点数。BlackjackCard结构体包含两个嵌套定义的枚举类型Suit和Rank。在BlackjackCard中，Ace牌可以表示1或者11，Ace牌的这一特征通过一个嵌套在Rank枚举中的结构体Values来表示：
<pre>
struct BlackjackCard {
   // 嵌套的 Suit 枚举
   enum Suit: Character {
      case Spades = "♠", Hearts = "♡", Diamonds = "♢", Clubs = "♣"
   }

   // 嵌套的 Rank 枚举
   enum Rank: Int {
      case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten
      case Jack, Queen, King, Ace
      struct Values {
         let first: Int, second: Int?
      }
      var values: Values {
         switch self {
            case .Ace:
               return Values(first: 1, second: 11)
            case .Jack, .Queen, .King:
               return Values(first: 10, second: nil)
            default:
               return Values(first: self.rawValue, second: nil)
         }
      }
   }

   // BlackjackCard 的属性和方法
   let rank: Rank, suit: Suit
      var description: String {
      var output = "suit is \(suit.rawValue),"
      output += " value is \(rank.values.first)"
      if let second = rank.values.second {
         output += " or \(second)"
      }
      return output
   }
}
</pre>
Suit枚举用来描述扑克牌的四种花色，并用一个Character类型的原始值表示花色符号。
Rank枚举用来描述扑克牌从Ace~10，以及J、Q、K，这13种牌，并用一个Int类型的原始值表示牌的面值。（这个Int类型的原始值未用于Ace、J、Q、K这4种牌。）

因为BlackjackCard是一个没有自定义构造器的结构体，在结构体的逐一成员构造器中可知，结构体有默认的成员构造器，所以可以用默认的构造器去初始化新常量theAceOfSpades：
<pre>
let theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)
print("theAceOfSpades: \(theAceOfSpades.description)")
// 打印 “theAceOfSpades: suit is ♠, value is 1 or 11”
</pre>
尽管Rank和Suit嵌套在BlackjackCard中，但它们的类型仍可从上下文中推断出来，所以在初始化实例时能够单独通过成员名称（.Ace和.Spades）引用枚举实例。在上面的例子中，description属性正确地反映了黑桃A牌具有1和11两个值。

引用嵌套类型
在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀：
<pre>
let heartsSymbol = BlackjackCard.Suit.Hearts.rawValue
// 红心符号为 “♡”
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>107</wp:post_id>
		<wp:post_date><![CDATA[2015-12-19 11:17:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-19 03:17:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b020%ef%bc%9a%e5%b5%8c%e5%a5%97%e7%b1%bb%e5%9e%8b%ef%bc%88nested-types%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%b5%8c%e5%a5%97%e7%b1%bb%e5%9e%8b"><![CDATA[嵌套类型]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记21：扩展（Extensions）</title>
		<link>http://www.autoref.cn/?p=109</link>
		<pubDate>Mon, 21 Dec 2015 07:46:49 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=109</guid>
		<description></description>
		<content:encoded><![CDATA[扩展 就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即逆向建模 ）。
Swift 中的扩展可以：
1、添加计算型属性和计算型类型属性
2、定义实例方法和类型方法
3、提供新的构造器
4、定义下标
5、定义和使用新的嵌套类型
6、使一个已有类型符合某个协议
在 Swift 中，甚至可以对协议进行扩展，提供协议要求的实现，或者添加额外的功能，从而可以让符合协议的类型拥有这些功能。
注意：扩展可以为一个类型添加新的功能，但是不能重写已有的功能。

扩展语法（Extension Syntax）
使用关键字 extension 来声明扩展：
<pre>
extension SomeType {
    // 为 SomeType 添加的新功能写到这里
}
</pre>

可以通过扩展来扩展一个已有类型，使其采纳一个或多个协议。在这种情况下，无论是类还是结构体，协议名字的书写方式完全一样：
<pre>
extension SomeType: SomeProtocol, AnotherProctocol {
    // 协议实现写到这里
}
</pre>
注意：如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。

计算型属性（Computed Properties）
扩展可以为已有类型添加计算型实例属性和计算型类型属性。下面的例子为 Swift 的内建 Double 类型添加了五个计算型实例属性，从而提供与距离单位协作的基本支持：
<pre>
extension Double {
    var km: Double { return self * 1_000.0 }
    var m : Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}

let oneInch = 25.4.mm
print("One inch is \(oneInch) meters")
// 打印 “One inch is 0.0254 meters”
let threeFeet = 3.ft
print("Three feet is \(threeFeet) meters")
// 打印 “Three feet is 0.914399970739201 meters”

// 可以用于所有接受 Double 值的数学计算
let aMarathon = 42.km + 195.m
print("A marathon is \(aMarathon) meters long")
// 打印 “A marathon is 42195.0 meters long”
</pre>
扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。

构造器（Initializers）
扩展可以为已有类型添加新的构造器。这可以扩展其它类型，将定制类型作为其构造器参数，或者提供该类型的原始实现中未提供的额外初始化选项。
扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现来提供。

注意：如果你使用扩展为一个值类型添加构造器，且该值类型的原始实现中未定义任何定制的构造器时，你可以在扩展中的构造器里调用逐一成员构造器。如果该值类型为所有存储型属性提供了默认值，还可以在扩展中的构造器里调用默认构造器。
正如在值类型的构造器代理中描述的，如果把定制的构造器写在值类型的原始实现中，上述规则将不再适用。
下面的例子定义了一个用于描述几何矩形的结构体 Rect。这个例子同时定义了两个辅助结构体 Size 和 Point，它们都把 0.0 作为所有属性的默认值：
<pre>
struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
</pre>

因为结构体 Rect 未提供定制的构造器，因此它会获得一个逐一成员构造器。又因为它为所有存储型属性提供了默认值，它又会获得一个默认构造器。这些构造器可以用于构造新的 Rect 实例：
<pre>
let defaultRect = Rect()
let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),
    size: Size(width: 5.0, height: 5.0))

// 提供一个额外的接受指定中心点和大小的构造器来扩展 Rect 结构体：
extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}

// 调用该结构体的逐一成员构造器 init(origin:size:)
let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
    size: Size(width: 3.0, height: 3.0))
// centerRect 的原点是 (2.5, 2.5)，大小是 (3.0, 3.0)
</pre>

方法（Methods）
扩展可以为已有类型添加新的实例方法和类型方法。下面的例子为 Int 类型添加了一个名为 repetitions 的实例方法：
<pre>
extension Int {
    func repetitions(task: () -> Void) {
        for _ in 0..<self {
            task()
        }
    }
}

3.repetitions({
    print("Hello!")
})
// Hello!
// Hello!
// Hello!

// 可以使用尾随闭包让调用更加简洁
3.repetitions {
    print("Goodbye!")
}
// Goodbye!
// Goodbye!
// Goodbye!
</pre>

可变实例方法（Mutating Instance Methods）
通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改 self 或其属性的方法必须将该实例方法标注为 mutating，正如来自原始实现的可变方法一样。
下面的例子为 Swift 的 Int 类型添加了一个名为 square 的可变方法，用于计算原始值的平方值：
<pre>
extension Int {
    mutating func square() {
        self = self * self
    }
}

var someInt = 3
someInt.square()
// someInt 的值现在是 9
</pre>

下标（Subscripts）
扩展可以为已有类型添加新下标。这个例子为 Swift 内建类型 Int 添加了一个整型下标。该下标 [n] 返回十进制数字从右向左数的第 n 个数字：
123456789[0] 返回 9
123456789[1] 返回 8
……以此类推。
<pre>
extension Int {
    subscript(var digitIndex: Int) -> Int {
        var decimalBase = 1
        while digitIndex > 0 {
            decimalBase *= 10
            --digitIndex
        }
        return (self / decimalBase) % 10
    }
}

746381295[0]
// 返回 5
746381295[1]
// 返回 9
746381295[2]
// 返回 2
746381295[8]
// 返回 7
</pre>

如果该 Int 值没有足够的位数，即下标越界，那么上述下标实现会返回 0，犹如在数字左边自动补 0：
<pre>
746381295[9]
// 返回 0，即等同于：
0746381295[9]
</pre>

嵌套类型（Nested Types）
扩展可以为已有的类、结构体和枚举添加新的嵌套类型：
<pre>
extension Int {
    enum Kind {
        case Negative, Zero, Positive
    }
    var kind: Kind {
        switch self {
        case 0:
            return .Zero
        case let x where x > 0:
            return .Positive
        default:
            return .Negative
        }
    }
}

func printIntegerKinds(numbers: [Int]) {
    for number in numbers {
        switch number.kind {
        case .Negative:
            print("- ", terminator: "")
        case .Zero:
            print("0 ", terminator: "")
        case .Positive:
            print("+ ", terminator: "")
        }
    }
    print("")
}
printIntegerKinds([3, 19, -27, 0, -6, 0, 7])
// 打印 “+ + - 0 - 0 +”
</pre>
由于已知 number.kind 是 Int.Kind 类型，因此在 switch 语句中，Int.Kind 中的所有成员值都可以使用简写形式，例如使用 .Negative 而不是 Int.Kind.Negative。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>109</wp:post_id>
		<wp:post_date><![CDATA[2015-12-21 15:46:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-21 07:46:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b021%ef%bc%9a%e6%89%a9%e5%b1%95%ef%bc%88extensions%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e6%89%a9%e5%b1%95"><![CDATA[扩展]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记22：协议（Protocols）</title>
		<link>http://www.autoref.cn/?p=111</link>
		<pubDate>Wed, 23 Dec 2015 10:18:35 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=111</guid>
		<description></description>
		<content:encoded><![CDATA[协议语法
协议的定义方式与类、结构体和枚举的定义非常相似：
<pre>
protocol SomeProtocol {
    // 这里是协议的定义部分
}
</pre>

要让自定义类型采纳某个协议，在定义类型时，需要在类型名称后加上协议名称，中间以冒号（:）分隔。采纳多个协议时，各协议之间用逗号（,）分隔：
<pre>
struct SomeStructure: FirstProtocol, AnotherProtocol {
    // 这里是结构体的定义部分
}
</pre>

拥有父类的类在采纳协议时，应该将父类名放在协议名之前，以逗号分隔：
<pre>
class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {
    // 这里是类的定义部分
}
</pre>

属性要求
协议可以要求采纳协议的类型提供特定名称和类型的实例属性或类型属性。协议不指定属性是存储型属性还是计算型属性，它只指定属性的名称和类型。此外，协议还指定属性是只读的还是可读可写的。
如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是只读的，那么该属性不仅可以是只读的，如果代码需要的话，还可以是可写的。
协议通常用 var 关键字来声明变量属性，在类型声明后加上 { set get } 来表示属性是可读可写的，只读属性则用 { get } 来表示：
<pre>
protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
</pre>

在协议中定义类型属性时，总是使用 static 关键字作为前缀。当类类型采纳协议时，除了 static 关键字，还可以使用 class 关键字来声明类型属性：
<pre>
protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}
</pre>

如下所示，这是一个只含有一个实例属性要求的协议：
<pre>
protocol FullyNamed {
    var fullName: String { get }
}
</pre>
FullyNamed 协议除了要求采纳协议的类型提供 fullName 属性外，并没有其他特别的要求。这个协议表示，任何采纳 FullyNamed 的类型，都必须有一个只读的 String 类型的实例属性 fullName。
下面是一个采纳 FullyNamed 协议的简单结构体：
<pre>
struct Person: FullyNamed {
    var fullName: String
}
let john = Person(fullName: "John Appleseed")
// john.fullName 为 "John Appleseed"
</pre>
这个例子中定义了一个叫做 Person 的结构体，用来表示一个具有名字的人。从第一行代码可以看出，它采纳了 FullyNamed 协议。
Person 结构体的每一个实例都有一个 String 类型的存储型属性 fullName。这正好满足了 FullyNamed 协议的要求，也就意味着 Person 结构体正确地符合了协议。（如果协议要求未被完全满足，在编译时会报错。）

下面是一个更为复杂的类，它采纳并符合了 FullyNamed 协议：
<pre>
class Starship: FullyNamed {
    var prefix: String?
    var name: String
    init(name: String, prefix: String? = nil) {
        self.name = name
        self.prefix = prefix
    }
    var fullName: String {
        return (prefix != nil ? prefix! + " " : "") + name
    }
}
var ncc1701 = Starship(name: "Enterprise", prefix: "USS")
// ncc1701.fullName 是 "USS Enterprise"
</pre>
Starship 类把 fullName 属性实现为只读的计算型属性。每一个 Starship 类的实例都有一个名为 name 的非可选属性和一个名为 prefix 的可选属性。 当 prefix 存在时，计算型属性 fullName 会将 prefix 插入到 name 之前，从而为星际飞船构建一个全名。

方法要求
协议可以要求采纳协议的类型实现某些指定的实例方法或类方法。这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同。但是，不支持为协议中的方法的参数提供默认值。
正如属性要求中所述，在协议中定义类方法的时候，总是使用 static 关键字作为前缀。当类类型采纳协议时，除了 static 关键字，还可以使用 class 关键字作为前缀：
<pre>
protocol SomeProtocol {
    static func someTypeMethod()
}
</pre>
下面的例子定义了一个只含有一个实例方法的协议：
<pre>
protocol RandomNumberGenerator {
    func random() -> Double
}
</pre>
RandomNumberGenerator 协议要求采纳协议的类型必须拥有一个名为 random， 返回值类型为 Double 的实例方法。尽管这里并未指明，但是我们假设返回值在 [0.0,1.0) 区间内。
RandomNumberGenerator 协议并不关心每一个随机数是怎样生成的，它只要求必须提供一个随机数生成器。

如下所示，下边是一个采纳了 RandomNumberGenerator 协议的类。该类实现了一个叫做 线性同余生成器（linear congruential generator） 的伪随机数算法。
<pre>
class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -> Double {
        lastRandom = ((lastRandom * a + c) % m)
        return lastRandom / m
    }
}

let generator = LinearCongruentialGenerator()
print("Here's a random number: \(generator.random())")
// 打印 “Here's a random number: 0.37464991998171”
print("And another one: \(generator.random())")
// 打印 “And another one: 0.729023776863283”
</pre>

Mutating 方法要求
有时需要在方法中改变方法所属的实例。例如，在值类型（即结构体和枚举）的实例方法中，将 mutating 关键字作为方法的前缀，写在 func 关键字之前，表示可以在该方法中修改它所属的实例以及实例的任意属性的值。
如果在协议中定义了一个实例方法，该方法会改变采纳该协议的类型的实例，那么在定义协议时需要在方法前加 mutating 关键字。这使得结构体和枚举能够采纳此协议并满足此方法要求。
注意：实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。
如下所示，Togglable 协议只要求实现一个名为 toggle 的实例方法。根据名称的暗示，toggle() 方法将改变实例属性，从而切换采纳该协议类型的实例的状态。
toggle() 方法在定义的时候，使用 mutating 关键字标记，这表明当它被调用时，该方法将会改变采纳协议的类型的实例：
<pre>
protocol Togglable {
    mutating func toggle()
}
</pre>
当使用枚举或结构体来实现 Togglable 协议时，需要提供一个带有 mutating 前缀的 toggle() 方法。
下面定义了一个名为 OnOffSwitch 的枚举。这个枚举在两种状态之间进行切换，用枚举成员 On 和 Off 表示。枚举的 toggle() 方法被标记为 mutating，以满足 Togglable 协议的要求：
<pre>
enum OnOffSwitch: Togglable {
    case Off, On
    mutating func toggle() {
        switch self {
        case Off:
            self = On
        case On:
            self = Off
        }
    }
}
var lightSwitch = OnOffSwitch.Off
lightSwitch.toggle()
// lightSwitch 现在的值为 .On
</pre>

构造器要求
协议可以要求采纳协议的类型实现指定的构造器。可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体：
<pre>
protocol SomeProtocol {
    init(someParameter: Int)
}
</pre>

构造器要求在类中的实现
可以在采纳协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 required 修饰符：
<pre>
class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // 这里是构造器的实现部分
    }
}
</pre>
使用 required 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。

如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 required 和 override 修饰符：
<pre>
protocol SomeProtocol {
    init()
}

class SomeSuperClass {
    init() {
        // 这里是构造器的实现部分
    }
}

class SomeSubClass: SomeSuperClass, SomeProtocol {
    // 因为采纳协议，需要加上 required
    // 因为继承自父类，需要加上 override
    required override init() {
        // 这里是构造器的实现部分
    }
}
</pre>

可失败构造器要求
采纳协议的类型可以通过可失败构造器（init?）或非可失败构造器（init）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（init）或隐式解包可失败构造器（init!）来满足。

协议作为类型
尽管协议本身并未实现任何功能，但是协议可以被当做一个成熟的类型来使用。
协议可以像其他普通类型一样使用，使用场景如下：
1、作为函数、方法或构造器中的参数类型或返回值类型
2、作为常量、变量或属性的类型
3、作为数组、字典或其他容器中的元素类型
注意：协议是一种类型，因此协议类型的名称应与其他类型（例如 Int，Double，String）的写法相同，使用大写字母开头的驼峰式写法，例如（FullyNamed 和 RandomNumberGenerator）。
下面是将协议作为类型使用的例子：
<pre>
class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -> Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}

// 使用LinearCongruentialGenerator的实例作为随机数生成器来创建一个六面骰子
var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
for _ in 1...5 {
    print("Random dice roll is \(d6.roll())")
}
// Random dice roll is 3
// Random dice roll is 5
// Random dice roll is 4
// Random dice roll is 5
// Random dice roll is 4
</pre>

委托（代理）模式
委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保采纳协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。
下面的例子定义了两个基于骰子游戏的协议：
<pre>
protocol DiceGame {
    var dice: Dice { get }
    func play()
}

protocol DiceGameDelegate {
    func gameDidStart(game: DiceGame)
    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll:Int)
    func gameDidEnd(game: DiceGame)
}

// 使用 Dice 实例作为骰子，并且实现了 DiceGame 和 DiceGameDelegate 协议，后者用来记录游戏的过程
class SnakesAndLadders: DiceGame {
    let finalSquare = 25
    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
    var square = 0
    var board: [Int]
    init() {
        board = [Int](count: finalSquare + 1, repeatedValue: 0)
        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
    }
    var delegate: DiceGameDelegate?
    func play() {
        square = 0
        delegate?.gameDidStart(self)
        gameLoop: while square != finalSquare {
            let diceRoll = dice.roll()
            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)
            switch square + diceRoll {
            case finalSquare:
                break gameLoop
            case let newSquare where newSquare > finalSquare:
                continue gameLoop
            default:
                square += diceRoll
                square += board[square]
            }
        }
        delegate?.gameDidEnd(self)
    }
}
</pre>

如下示例定义了 DiceGameTracker 类，它采纳了 DiceGameDelegate 协议：
<pre>
class DiceGameTracker: DiceGameDelegate {
    var numberOfTurns = 0
    func gameDidStart(game: DiceGame) {
        numberOfTurns = 0
        if game is SnakesAndLadders {
            print("Started a new game of Snakes and Ladders")
        }
        print("The game is using a \(game.dice.sides)-sided dice")
    }
    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
        ++numberOfTurns
        print("Rolled a \(diceRoll)")
    }
    func gameDidEnd(game: DiceGame) {
        print("The game lasted for \(numberOfTurns) turns")
    }
}

let tracker = DiceGameTracker()
let game = SnakesAndLadders()
game.delegate = tracker
game.play()
// Started a new game of Snakes and Ladders
// The game is using a 6-sided dice
// Rolled a 3
// Rolled a 5
// Rolled a 4
// Rolled a 5
// The game lasted for 4 turns
</pre>

通过扩展添加协议一致性
即便无法修改源代码，依然可以通过扩展令已有类型采纳并符合协议。扩展可以为已有类型添加属性、方法、下标脚本以及构造器，因此可以符合协议中的相应要求。
注意：通过扩展令已有类型采纳并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。
例如下面这个 TextRepresentable 协议，任何想要通过文本表示一些内容的类型都可以实现该协议。这些想要表示的内容可以是实例本身的描述，也可以是实例当前状态的文本描述：
<pre>
protocol TextRepresentable {
    var textualDescription: String { get }
}

// 通过扩展，令先前提到的 Dice 类采纳并符合 TextRepresentable 协议
extension Dice: TextRepresentable {
    var textualDescription: String {
        return "A \(sides)-sided dice"
    }
}

// 现在所有 Dice 的实例都可以看做 TextRepresentable 类型
let d12 = Dice(sides: 12,generator: LinearCongruentialGenerator())
print(d12. textualDescription)
// 打印 “A 12-sided dice”

// SnakesAndLadders 类也可以通过扩展采纳并符合 TextRepresentable 协议
extension SnakesAndLadders: TextRepresentable {
    var textualDescription: String {
        return "A game of Snakes and Ladders with \(finalSquare) squares"
    }
}
print(game.textualDescription)
// 打印 “A game of Snakes and Ladders with 25 squares”
</pre>

通过扩展声明已采纳协议
当一个类型已经符合了某个协议中的所有要求，却还没有声明采纳该协议时，可以通过空扩展体的扩展来采纳该协议：
<pre>
struct Hamster {
    var name: String
    var textualDescription: String {
        return "A hamster named \(name)"
    }
}
extension Hamster: TextRepresentable {}

// 现在Hamster的实例可以作为 TextRepresentable 类型使用
let simonTheHamster = Hamster(name: "Simon")
let somethingTextRepresentable: TextRepresentable = simonTheHamster
print(somethingTextRepresentable.textualDescription)
// 打印 “A hamster named Simon”
</pre>
注意：即使满足了协议的所有要求，类型也不会自动采纳协议，必须显式地采纳协议。

协议类型的集合
协议类型可以在数组或者字典这样的集合中使用，在协议类型提到了这样的用法。下面的例子创建了一个元素类型为 TextRepresentable 的数组：
<pre>
let things: [TextRepresentable] = [game, d12, simonTheHamster]

// 遍历 things 数组，并打印每个元素的文本表示
for thing in things {
    print(thing.textualDescription)
}
// A game of Snakes and Ladders with 25 squares
// A 12-sided dice
// A hamster named Simon
</pre>

协议的继承
协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔：
<pre>
protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // 这里是协议的定义部分
}
</pre>

如下所示，PrettyTextRepresentable 协议继承了 TextRepresentable 协议：
<pre>
protocol PrettyTextRepresentable: TextRepresentable {
    var prettyTextualDescription: String { get }
}
</pre>

如下所示，扩展 SnakesAndLadders，使其采纳并符合 PrettyTextRepresentable 协议：
<pre>
extension SnakesAndLadders: PrettyTextRepresentable {
    var prettyTextualDescription: String {
        var output = textualDescription + ":\n"
        for index in 1...finalSquare {
            switch board[index] {
            case let ladder where ladder > 0:
                output += "▲ "
            case let snake where snake < 0:
                output += "▼ "
            default:
                output += "○ "
            }
        }
        return output
    }
}

print(game.prettyTextualDescription)
// A game of Snakes and Ladders with 25 squares:
// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○
</pre>

类类型专属协议
可以在协议的继承列表中，通过添加 class 关键字来限制协议只能被类类型采纳，而结构体或枚举不能采纳该协议。class 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前：
<pre>
protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {
    // 这里是类类型专属协议的定义部分
}
</pre>

协议合成
有时候需要同时采纳多个协议，你可以将多个协议采用 protocol<SomeProtocol, AnotherProtocol> 这样的格式进行组合，称为协议合成（protocol composition）。你可以在 <> 中罗列任意多个你想要采纳的协议，以逗号分隔。
下面的例子中，将 Named 和 Aged 两个协议按照上述语法组合成一个协议，作为函数参数的类型：
<pre>
protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}
func wishHappyBirthday(celebrator: protocol<Named, Aged>) {
    print("Happy birthday \(celebrator.name) - you're \(celebrator.age)!")
}
let birthdayPerson = Person(name: "Malcolm", age: 21)
wishHappyBirthday(birthdayPerson)
// 打印 “Happy birthday Malcolm - you're 21!”
</pre>
注意：协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个只在局部作用域有效的临时协议中。

检查协议一致性
你可以使用类型转换中描述的 is 和 as 操作符来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换到某个协议类型在语法上和类型的检查和转换完全相同：
1、is 用来检查实例是否符合某个协议，若符合则返回 true，否则返回 false。
2、as? 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil。
3、as! 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。
下面的例子定义了一个 HasArea 协议，该协议定义了一个 Double 类型的只读属性 area：
<pre>
protocol HasArea {
    var area: Double { get }
}

// Circle 类和 Country 类都采纳了 HasArea 协议
class Circle: HasArea {
    let pi = 3.1415927
    var radius: Double
    var area: Double { return pi * radius * radius }
    init(radius: Double) { self.radius = radius }
}
class Country: HasArea {
    var area: Double
    init(area: Double) { self.area = area }
}

// Animal 是一个未采纳 HasArea 协议的类
class Animal {
    var legs: Int
    init(legs: Int) { self.legs = legs }
}
</pre>
Circle，Country，Animal 并没有一个共同的基类，尽管如此，它们都是类，它们的实例都可以作为 AnyObject 类型的值，存储在同一个数组中：
<pre>
let objects: [AnyObject] = [
    Circle(radius: 2.0),
    Country(area: 243_610),
    Animal(legs: 4)
]

// 对迭代出的每一个元素进行检查，看它是否符合 HasArea 协议
for object in objects {
    if let objectWithArea = object as? HasArea {
        print("Area is \(objectWithArea.area)")
    } else {
        print("Something that doesn't have an area")
    }
}
// Area is 12.5663708
// Area is 243610.0
// Something that doesn't have an area
</pre>

可选的协议要求
协议可以定义可选要求，采纳协议的类型可以选择是否实现这些要求。在协议中使用 optional 关键字作为前缀来定义可选要求。使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 (Int) -> String 的方法会变成 ((Int) -> String)?。需要注意的是整个函数类型是可选的，而不是函数的返回值。
注意：可选的协议要求只能用在标记 @objc 特性的协议中。
该特性表示协议将暴露给 Objective-C 代码，即使不打算和 Objective-C 有什么交互，如果想要指定可选的协议要求，那么还是要为协议加上 @obj 特性。
还需要注意的是，标记 @objc 特性的协议只能被继承自 Objective-C 类的类或者 @objc 类采纳，其他类以及结构体和枚举均不能采纳这种协议。
下面的例子定义了一个名为 Counter 的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由 CounterDataSource 协议定义，包含两个可选要求：
<pre>
@objc protocol CounterDataSource {
    optional func incrementForCount(count: Int) -> Int
    optional var fixedIncrement: Int { get }
}
</pre>
注意：严格来讲，CounterDataSource 协议中的方法和属性都是可选的，因此采纳协议的类可以不实现这些要求，尽管技术上允许这样做，不过最好不要这样写。
Counter 类含有 CounterDataSource? 类型的可选属性 dataSource，如下所示：
<pre>
class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
        if let amount = dataSource?.incrementForCount?(count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement {
            count += amount
        }
    }
}
</pre>
这里使用了两层可选链式调用。首先，由于 dataSource 可能为 nil，因此在 dataSource 后边加上了 ?，以此表明只在 dataSource 非空时才去调用 incrementForCount(_:) 方法。其次，即使 dataSource 存在，也无法保证其是否实现了 incrementForCount(_:) 方法，因为这个方法是可选的。因此，incrementForCount(_:) 方法同样使用可选链式调用进行调用，只有在该方法被实现的情况下才能调用它，所以在 incrementForCount(_:) 方法后边也加上了 ?。

调用 incrementForCount(_:) 方法在上述两种情形下都有可能失败，所以返回值为 Int? 类型。虽然在 CounterDataSource 协议中，incrementForCount(_:) 的返回值类型是非可选 Int。另外，即使这里使用了两层可选链式调用，最后的返回结果依旧是单层的可选类型，即 Int? 而不是 Int??。关于这一点的更多信息，请查阅连接多层可选链式调用

在调用 incrementForCount(_:) 方法后，Int? 型的返回值通过可选绑定解包并赋值给常量 amount。如果可选值确实包含一个数值，也就是说，数据源和方法都存在，数据源方法返回了一个有效值。之后便将解包后的 amount 加到 count 上，增量操作完成。

如果没有从 incrementForCount(_:) 方法获取到值，可能由于 dataSource 为 nil，或者它并没有实现 incrementForCount(_:) 方法，那么 increment() 方法将试图从数据源的 fixedIncrement 属性中获取增量。fixedIncrement 是一个可选属性，因此属性值是一个 Int? 值，即使该属性在 CounterDataSource 协议中的类型是非可选的 Int。

下面的例子展示了 CounterDataSource 的简单实现。ThreeSource 类采纳了 CounterDataSource 协议，它实现了可选属性 fixedIncrement，每次会返回 3：
<pre>
class ThreeSource: NSObject, CounterDataSource {
    let fixedIncrement = 3
}

//可以使用 ThreeSource 的实例作为 Counter 实例的数据源：
var counter = Counter()
counter.dataSource = ThreeSource()
for _ in 1...4 {
    counter.increment()
    print(counter.count)
}
// 3
// 6
// 9
// 12
</pre>

下面是一个更为复杂的数据源 TowardsZeroSource，它将使得最后的值变为 0：
<pre>
@objc class TowardsZeroSource: NSObject, CounterDataSource {
    func incrementForCount(count: Int) -> Int {
        if count == 0 {
            return 0
        } else if count < 0 {
            return 1
        } else {
            return -1
        }
    }
}

// 使用 TowardsZeroSource 实例将 Counter 实例来从 -4 增加到 0。一旦增加到 0，数值便不会再有变动
counter.count = -4
counter.dataSource = TowardsZeroSource()
for _ in 1...5 {
    counter.increment()
    print(counter.count)
}
// -3
// -2
// -1
// 0
// 0
</pre>

协议扩展
协议可以通过扩展来为采纳协议的类型提供属性、方法以及下标脚本的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个采纳协议的类型中都重复同样的实现，也无需使用全局函数。
例如，可以扩展 RandomNumberGenerator 协议来提供 randomBool() 方法。该方法使用协议中定义的 random() 方法来返回一个随机的 Bool 值：
<pre>
extension RandomNumberGenerator {
    func randomBool() -> Bool {
        return random() > 0.5
    }
}

// 通过协议扩展，所有采纳协议的类型，都能自动获得这个扩展所增加的方法实现，无需任何额外修改
let generator = LinearCongruentialGenerator()
print("Here's a random number: \(generator.random())")
// 打印 “Here's a random number: 0.37464991998171”
print("And here's a random Boolean: \(generator.randomBool())")
// 打印 “And here's a random Boolean: true”
</pre>

提供默认实现
可以通过协议扩展来为协议要求的属性、方法以及下标脚本提供默认的实现。如果采纳协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。
注意：通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，采纳协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。
例如，PrettyTextRepresentable 协议继承自 TextRepresentable 协议，可以为其提供一个默认的 prettyTextualDescription 属性，只是简单地返回 textualDescription 属性的值：
<pre>
extension PrettyTextRepresentable  {
    var prettyTextualDescription: String {
        return textualDescription
    }
}
</pre>

为协议扩展添加限制条件
在扩展协议的时候，可以指定一些限制条件，只有采纳协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 where 子句来描述，正如Where子句)中所描述的。
例如，可以扩展 CollectionType 协议，但是只适用于集合中的元素采纳了 TextRepresentable 协议的情况：
<pre>
extension CollectionType where Generator.Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return "[" + itemsAsText.joinWithSeparator(", ") + "]"
    }
}
// textualDescription 属性返回整个集合的文本描述，它将集合中的每个元素的文本描述以逗号分隔的方式连接起来，包在一对方括号中。

let murrayTheHamster = Hamster(name: "Murray")
let morganTheHamster = Hamster(name: "Morgan")
let mauriceTheHamster = Hamster(name: "Maurice")
let hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]
// 因为 Array 符合 CollectionType 协议，而数组中的元素又符合 TextRepresentable 协议，所以数组可以使用 textualDescription 属性得到数组内容的文本表示：
print(hamsters.textualDescription)
// 打印 “[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]”
</pre>
注意：如果多个协议扩展都为同一个协议要求提供了默认实现，而采纳协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>111</wp:post_id>
		<wp:post_date><![CDATA[2015-12-23 18:18:35]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-23 10:18:35]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b022%ef%bc%9a%e5%8d%8f%e8%ae%ae%ef%bc%88protocols%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e5%8d%8f%e8%ae%ae"><![CDATA[协议]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记23：泛型（Generics）</title>
		<link>http://www.autoref.cn/?p=113</link>
		<pubDate>Fri, 25 Dec 2015 01:19:17 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=113</guid>
		<description></description>
		<content:encoded><![CDATA[泛型代码可以让你写出根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型。

泛型所解决的问题
这里是一个标准的，非泛型函数swapTwoInts,用来交换两个Int值：
<pre>
func swapTwoInts(inout a: Int, inout _ b: Int) {
  let temporaryA = a
  a = b
  b = temporaryA
}

// 调用函数交换两个Int变量值
var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// 输出 "someInt is now 107, and anotherInt is now 3"
</pre>

swapTwoInts(_:_:)函数是非常有用的，但是它只能交换Int值，如果想要交换两个String或者Double，就不得不写更多的函数，如 swapTwoStrings和swapTwoDoubles(_:_:)，如同如下所示：
<pre>
func swapTwoStrings(inout a: String, inout _ b: String) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swapTwoDoubles(inout a: Double, inout _ b: Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</pre>

泛型函数
泛型函数可以工作于任何类型，这里是一个上面swapTwoInts(_:_:)函数的泛型版本，用于交换两个值：
<pre>
func swapTwoValues<T>(inout a: T, inout _ b: T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
</pre>
这个函数的泛型版本使用了占位类型名字（通常此情况下用字母T来表示）来代替实际类型名（如Int、String或Double）。占位类型名没有提示T必须是什么类型，但是它提示了a和b必须是同一类型T，而不管T表示什么类型。只有swapTwoValues(_:_:)函数在每次调用时所传入的实际类型才能决定T所代表的类型。
另外一个不同之处在于这个泛型函数名后面跟着的占位类型名字（T）是用尖括号括起来的（<T>）。这个尖括号告诉 Swift 那个T是swapTwoValues(_:_:)函数所定义的一个类型。因为T是一个占位命名类型，Swift 不会去查找命名为T的实际类型。
在下面的两个例子中,T分别代表Int和String：
<pre>
var someInt = 3
var anotherInt = 107
swapTwoValues(&someInt, &anotherInt)
// someInt 现在等于 107, anotherInt 现在等于 3

var someString = "hello"
var anotherString = "world"
swapTwoValues(&someString, &anotherString)
// someString 现在等于 "world", anotherString 现在等于 "hello"
</pre>

类型参数
在上面的swapTwoValues例子中，占位类型T是一种类型参数的示例。类型参数指定并命名为一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（如<T>），可支持多个类型参数，命名在尖括号中，用逗号分开。

命名类型参数
在简单的情况下，泛型函数或泛型类型需要指定一个占位类型（如上面的swapTwoValues泛型函数，或一个存储单一类型的泛型集，如数组），通常用一单个字母T来命名类型参数。不过，可以使用任何有效的标识符来作为类型参数名。
注意：始终使用大写字母开头的驼峰式命名法（例如T和Key）来给类型参数命名，以表明它们是类型的占位符，而非类型值。

泛型类型
这部分展示如何写一个泛型集类型--Stack（栈）。一个栈是一系列值域的集合，和Array（数组）类似，但其是一个比 Swift 的Array类型更多限制的集合。一个数组可以允许其里面任何位置的插入/删除操作，而栈，只允许在集合的末端添加新的项（如同push一个新值进栈）。同样的一个栈也只能从末端移除项（如同pop一个值出栈）。
这里展示了如何写一个非泛型版本的栈，Int值型的栈：
<pre>
struct IntStack {
    var items = [Int]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        return items.removeLast()
    }
}
</pre>
这里是一个相同代码的泛型版本：
<pre>
struct Stack<T> {
    var items = [T]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -> T {
        return items.removeLast()
    }
}
</pre>
由于Stack是泛型类型，所以在 Swift 中其可以用来创建任何有效类型的栈，这种方式如同Array和Dictionary。可以通过在尖括号里写出栈中需要存储的数据类型来创建并初始化一个Stack实例。比如，要创建一个strings的栈，可以写成Stack<String>()：
<pre>
var stackOfStrings = Stack<String>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// 现在栈已经有4个string了

// 从栈中pop并移除值"cuatro"：
let fromTheTop = stackOfStrings.pop()
// fromTheTop 等于 "cuatro", 现在栈中还有3个string
</pre>

扩展一个泛型类型
当扩展一个泛型类型的时候，并不需要在扩展的定义中提供类型参数列表。更加方便的是，原始类型定义中声明的类型参数列表在扩展里是可以使用的，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。

下面的例子扩展了泛型Stack类型，为其添加了一个名为topItem的只读计算属性，它将会返回当前栈顶端的元素而不会将其从栈中移除。
<pre>
extension Stack {
    var topItem: T? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}
</pre>
topItem属性会返回一个T类型的可选值。当栈为空的时候，topItem将会返回nil；当栈不为空的时候，topItem会返回items数组中的最后一个元素。注意这里的扩展并没有定义一个类型参数列表。相反的，Stack类型已有的类型参数名称，T被用在扩展中当做topItem计算属性的可选类型。
topItem计算属性现在可以被用来返回任意Stack实例的顶端元素而无需移除它：
<pre>
if let topItem = stackOfStrings.topItem {
    print("The top item on the stack is \(topItem).")
}
// 输出 "The top item on the stack is tres."
</pre>

类型约束
swapTwoValues(_:_:)函数和Stack类型可以作用于任何类型，不过，有的时候对使用在泛型函数和泛型类型上的类型强制约束为某种特定类型是非常有用的。类型约束指定了一个必须继承自指定类的类型参数，或者遵循一个特定的协议或协议构成。

例如，Swift 的Dictionary类型对作用于其键的类型做了些限制。在字典的描述中，字典的键类型必须是可哈希，也就是说，必须有一种方法可以使其被唯一的表示。Dictionary之所以需要其键是可哈希是为了以便于其检查其是否已经包含某个特定键的值。如无此需求，Dictionary既不会告诉是否插入或者替换了某个特定键的值，也不能查找到已经存储在字典里面的给定键值。

这个需求强制加上一个类型约束作用于Dictionary的键上，当然其键类型必须遵循Hashable协议（Swift 标准库中定义的一个特定协议）。所有的 Swift 基本类型（如String，Int， Double和 Bool）默认都是可哈希。

类型约束语法

你可以写一个在一个类型参数名后面的类型约束，通过冒号分割，来作为类型参数链的一部分。这种作用于泛型函数的类型约束的基础语法如下所示（和泛型类型的语法相同）：
<pre>
func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {
    // 这里是函数主体
}
</pre>

上面这个假定函数有两个类型参数。第一个类型参数T，有一个需要T必须是SomeClass子类的类型约束；第二个类型参数U，有一个需要U必须遵循SomeProtocol协议的类型约束。


类型约束实例

这里有个名为findStringIndex的非泛型函数，该函数功能是去查找包含一给定String值的数组。若查找到匹配的字符串，findStringIndex(_:_:)函数返回该字符串在数组中的索引值（Int），反之则返回nil：
<pre>
func findStringIndex(array: [String], _ valueToFind: String) -> Int? {
    for (index, value) in array.enumerate() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</pre>

findStringIndex(_:_:)函数可以作用于查找一字符串数组中的某个字符串:
<pre>
let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]
if let foundIndex = findStringIndex(strings, "llama") {
    print("The index of llama is \(foundIndex)")
}
// 输出 "The index of llama is 2"
</pre>

如果只是针对字符串而言查找在数组中的某个值的索引，用处不是很大，不过，你可以写出相同功能的泛型函数findIndex，用某个类型T值替换掉提到的字符串。

这里展示如何写一个你或许期望的findStringIndex的泛型版本findIndex。请注意这个函数仍然返回Int，是不是有点迷惑呢，而不是泛型类型?那是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数不会编译，原因在例子后面会说明：
<pre>
func findIndex<T>(array: [T], _ valueToFind: T) -> Int? {
    for (index, value) in array.enumerate() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</pre>

上面所写的函数不会编译。这个问题的位置在等式的检查上，“if value == valueToFind”。不是所有的 Swift 中的类型都可以用等式符（==）进行比较。例如，如果你创建一个你自己的类或结构体来表示一个复杂的数据模型，那么 Swift 没法猜到对于这个类或结构体而言“等于”的意思。正因如此，这部分代码不能可能保证工作于每个可能的类型T，当你试图编译这部分代码时估计会出现相应的错误。

不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个Equatable协议，该协议要求任何遵循的类型实现等式符（==）和不等符（!=）对任何两个该类型进行比较。所有的 Swift 标准类型自动支持Equatable协议。

任何Equatable类型都可以安全的使用在findIndex(_:_:)函数中，因为其保证支持等式操作。为了说明这个事实，当你定义一个函数时，你可以写一个Equatable类型约束作为类型参数定义的一部分：
<pre>
func findIndex<T: Equatable>(array: [T], _ valueToFind: T) -> Int? {
    for (index, value) in array.enumerate() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
</pre>

findIndex中这个单个类型参数写做：T: Equatable，也就意味着“任何T类型都遵循Equatable协议”。

findIndex(_:_:)函数现在则可以成功的编译过，并且作用于任何遵循Equatable的类型，如Double或String:
<pre>
let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)
// doubleIndex is an optional Int with no value, because 9.3 is not in the array
let stringIndex = findIndex(["Mike", "Malcolm", "Andrea"], "Andrea")
// stringIndex is an optional Int containing a value of 2
</pre>

关联类型(Associated Types)
当定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分是非常有用的。一个关联类型作为协议的一部分，给定了类型的一个占位名（或别名）。作用于关联类型上实际类型在协议被实现前是不需要指定的。关联类型被指定为typealias关键字。


关联类型实例
这里是一个Container协议的例子，定义了一个ItemType关联类型：
<pre>
protocol Container {
    typealias ItemType
    mutating func append(item: ItemType)
    var count: Int { get }
    subscript(i: Int) -> ItemType { get }
}
</pre>

Container协议定义了三个任何容器必须支持的兼容要求：

必须可以通过append(_:)方法添加一个新元素到容器里；
必须可以通过使用count属性获取容器里元素的数量，并返回一个Int值；
必须可以通过容器的Int索引值下标可以检索到每一个元素。
这个协议没有指定容器里的元素是如何存储的或何种类型是允许的。这个协议只指定三个任何遵循Container类型所必须支持的功能点。一个遵循的类型在满足这三个条件的情况下也可以提供其他额外的功能。

任何遵循Container协议的类型必须指定存储在其里面的值类型，必须保证只有正确类型的元素可以加进容器里，必须明确可以通过其下标返回元素类型。

为了定义这三个条件，Container协议需要一个方法指定容器里的元素将会保留，而不需要知道特定容器的类型。Container协议需要指定任何通过append(_:)方法添加到容器里的值和容器里元素是相同类型，并且通过容器下标返回的容器元素类型的值的类型是相同类型。

为了达到此目的，Container协议声明了一个ItemType的关联类型，写作typealias ItemType。这个协议不会定义ItemType是什么的别名，这个信息将由任何遵循协议的类型来提供。尽管如此，ItemType别名提供了一种识别Container中元素类型的方法，并且用于append(_:)方法和subscript方法的类型定义，以便保证任何Container期望的行为能够被执行。

这里是一个早前IntStack类型的非泛型版本，遵循Container协议：
<pre>
struct IntStack: Container {
    // IntStack的原始实现
    var items = [Int]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        return items.removeLast()
    }
    // 遵循Container协议的实现
    typealias ItemType = Int
    mutating func append(item: Int) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -> Int {
        return items[i]
    }
}
</pre>

IntStack类型实现了Container协议的所有三个要求，在IntStack类型的每个包含部分的功能都满足这些要求。

此外，IntStack指定了Container的实现，适用的ItemType被用作Int类型。对于这个Container协议实现而言，定义 typealias ItemType = Int，将抽象的ItemType类型转换为具体的Int类型。

感谢Swift类型参考，你不用在IntStack定义部分声明一个具体的Int的ItemType。由于IntStack遵循Container协议的所有要求，只要通过简单的查找append(_:)方法的item参数类型和下标返回的类型，Swift就可以推断出合适的ItemType来使用。确实，如果上面的代码中你删除了 typealias ItemType = Int这一行，一切仍旧可以工作，因为它清楚的知道ItemType使用的是何种类型。

你也可以生成遵循Container协议的泛型Stack类型：
<pre>
struct Stack<T>: Container {
    // original Stack<T> implementation
    var items = [T]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -> T {
        return items.removeLast()
    }
    // conformance to the Container protocol
    mutating func append(item: T) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -> T {
        return items[i]
    }
}
</pre>

这个时候，占位类型参数T被用作append(_:)方法的item参数和下标的返回类型。Swift 因此可以推断出被用作这个特定容器的ItemType的T的合适类型。


扩展一个存在的类型为一指定关联类型

在在扩展中添加协议成员中有描述扩展一个存在的类型添加遵循一个协议。这个类型包含一个关联类型的协议。

Swift的Array已经提供append(_:)方法，一个count属性和通过下标来查找一个自己的元素。这三个功能都达到Container协议的要求。也就意味着你可以扩展Array去遵循Container协议，只要通过简单声明Array适用于该协议而已。如何实践这样一个空扩展，在通过扩展补充协议声明中有描述这样一个实现一个空扩展的行为：
<pre>
extension Array: Container {}
</pre>

如同上面的泛型Stack类型一样，Array的append(_:)方法和下标保证Swift可以推断出ItemType所使用的适用的类型。定义了这个扩展后，你可以将任何Array当作Container来使用。


Where 语句
类型约束能够确保类型符合泛型函数或类的定义约束。

对关联类型定义约束是非常有用的。你可以在参数列表中通过where语句定义参数的约束。一个where语句能够使一个关联类型遵循一个特定的协议，以及（或）那个特定的类型参数和关联类型可以是相同的。你可以写一个where语句，紧跟在在类型参数列表后面，where语句后跟一个或者多个针对关联类型的约束，以及（或）一个或多个类型和关联类型间的等价(equality)关系。

下面的例子定义了一个名为allItemsMatch的泛型函数，用来检查两个Container实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回一个为true的Boolean值，反之则为false。

被检查的两个Container可以不是相同类型的容器（虽然它们可以是），但它们确实拥有相同类型的元素。这个需求通过一个类型约束和where语句结合来表示：
<pre>
func allItemsMatch<
    C1: Container, C2: Container
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable>
    (someContainer: C1, anotherContainer: C2) -> Bool {

        // 检查两个Container的元素个数是否相同
        if someContainer.count != anotherContainer.count {
            return false
        }

        // 检查两个Container相应位置的元素彼此是否相等
        for i in 0..<someContainer.count {
            if someContainer[i] != anotherContainer[i] {
                return false
            }
        }

        // 如果所有元素检查都相同则返回true
        return true

}
</pre>

这个函数用了两个参数：someContainer和anotherContainer。someContainer参数是类型C1，anotherContainer参数是类型C2。C1和C2是容器的两个占位类型参数，决定了这个函数何时被调用。

这个函数的类型参数列紧随在两个类型参数需求的后面：

C1必须遵循Container协议 (写作 C1: Container)。
C2必须遵循Container协议 (写作 C2: Container)。
C1的ItemType同样是C2的ItemType（写作 C1.ItemType == C2.ItemType）。
C1的ItemType必须遵循Equatable协议 (写作 C1.ItemType: Equatable)。
第三个和第四个要求被定义为一个where语句的一部分，写在关键字where后面，作为函数类型参数链的一部分。

这些要求意思是：

someContainer是一个C1类型的容器。 anotherContainer是一个C2类型的容器。 someContainer和anotherContainer包含相同的元素类型。 someContainer中的元素可以通过不等于操作(!=)来检查它们是否彼此不同。

第三个和第四个要求结合起来的意思是anotherContainer中的元素也可以通过 != 操作来检查，因为它们在someContainer中元素确实是相同的类型。

这些要求能够使allItemsMatch(_:_:)函数比较两个容器，即便它们是不同的容器类型。

allItemsMatch(_:_:)首先检查两个容器是否拥有同样数目的items，如果它们的元素数目不同，没有办法进行匹配，函数就会false。

检查完之后，函数通过for-in循环和半闭区间操作（..<）来迭代someContainer中的所有元素。对于每个元素，函数检查是否someContainer中的元素不等于对应的anotherContainer中的元素，如果这两个元素不等，则这两个容器不匹配，返回false。

如果循环体结束后未发现没有任何的不匹配，那表明两个容器匹配，函数返回true。

这里演示了allItemsMatch(_:_:)函数运算的过程：
<pre>
var stackOfStrings = Stack<String>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")

var arrayOfStrings = ["uno", "dos", "tres"]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
    print("All items match.")
} else {
    print("Not all items match.")
}
// 输出 "All items match."
</pre>

上面的例子创建一个Stack单例来存储String，然后压了三个字符串进栈。这个例子也创建了一个Array单例，并初始化包含三个同栈里一样的原始字符串。即便栈和数组是不同的类型，但它们都遵循Container协议，而且它们都包含同样的类型值。因此你可以调用allItemsMatch(_:_:)函数，用这两个容器作为它的参数。在上面的例子中，allItemsMatch(_:_:)函数正确的显示了这两个容器的所有元素都是相互匹配的。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>113</wp:post_id>
		<wp:post_date><![CDATA[2015-12-25 09:19:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-25 01:19:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b023%ef%bc%9a%e6%b3%9b%e5%9e%8b%ef%bc%88generics%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e6%b3%9b%e5%9e%8b"><![CDATA[泛型]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b024%ef%bc%9a%e6%b3%9b%e5%9e%8b%ef%bc%88generics%ef%bc%89]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记24：访问控制（Access Control）</title>
		<link>http://www.autoref.cn/?p=115</link>
		<pubDate>Sun, 27 Dec 2015 04:19:59 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=115</guid>
		<description></description>
		<content:encoded><![CDATA[访问控制可以限定其他源文件或模块中代码对你代码的访问级别。这个特性可以让我们隐藏功能实现的一些细节，并且可以明确的申明我们提供给其他人的接口中哪些部分是他们可以访问和使用的。

你可以明确地给单个类型（类、结构体、枚举）设置访问级别，也可以给这些类型的属性、函数、初始化方法、基本类型、下标索引等设置访问级别。协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。

在提供了不同访问级别的同时，Swift还为某些典型场景提供了默认的访问级别，这样就不需要我们在每段代码中都申明显式访问级别。其实，如果只是开发一个单目标应用程序，我们完全可以不用申明代码的显式访问级别。

注意：简单起见，代码中可以设置访问级别的特性（属性、基本类型、函数等），在下面的章节中我们会以“实体”代替。

模块和源文件
Swift 中的访问控制模型基于模块和源文件这两个概念。

模块指的是以独立单元构建和发布的Framework或Application。在Swift 中的一个模块可以使用import关键字引入另外一个模块。

在 Swift 中，Xcode的每个构建目标（比如Framework或app bundle）都被当作模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的Framework，这个Framework在 Swift 中就被称为模块。当它被引入到某个 app 工程或者另外一个Framework时，它里面的一切（属性、函数等）仍然属于这个独立的模块。

源文件指的是 Swift 中的Swift File，就是编写 Swift 源代码的文件，它通常属于一个模块。尽管一般我们将不同的类 分别定义在不同的源文件中，但是同一个源文件可以包含多个类和函数 的定义。


访问级别
Swift 为代码中的实体提供了三种不同的访问级别。这些访问级别不仅与源文件中定义的实体相关，同时也与源文件所属的模块相关。

public：可以访问自己模块中源文件里的任何实体，别人也可以通过引入该模块来访问源文件里的所有实体。通常情况下，Framework 中的某个接口是可以被任何人使用时，你可以将其设置为public级别。
internal：可以访问自己模块中源文件里的任何实体，但是别人不能访问该模块中源文件里的实体。通常情况下，某个接口或Framework作为内部结构使用时，你可以将其设置为internal级别。
private：只能在当前源文件中使用的实体，称为私有实体。使用private级别，可以用作隐藏某些功能的实现细节。
public为最高级访问级别，private为最低级访问级别。

注意：Swift中的private访问和其他语言中的private访问不太一样，它的范围限于整个源文件，而不是声明。这就意味着，一个类 可以访问定义该类 的源文件中定义的所有private实体，但是如果一个类 的扩展是定义在独立的源文件中，那么就不能访问这个类 的private成员。

访问级别的使用原则

Swift 中的访问级别遵循一个使用原则：访问级别统一性。 比如说：

一个public访问级别的变量，不能将它的类型定义为internal和private。因为变量可以被任何人访问，但是定义它的类型不可以，所以这样就会出现错误。
函数的访问级别不能高于它的参数、返回类型的访问级别。因为如果函数定义为public而参数或者返回类型定义为internal或private，就会出现函数可以被任何人访问，但是它的参数和返回类型确不可以，同样会出现错误。

默认访问级别

如果你不为代码中的所有实体定义显式访问级别，那么它们默认为internal级别。在大多数情况下，我们不需要设置实体的显式访问级别。因为我们一般都是在开发一个app bundle。


单目标应用程序的访问级别

当你编写一个单目标应用程序时，该应用的所有功能都是为该应用服务，不需要提供给其他应用或者模块使用，所以我们不需要明确设置访问级别，使用默认的访问级别internal即可。但是如果你愿意，你也可以使用private级别，用于隐藏一些功能的实现细节。


Framework的访问级别

当你开发Framework时，就需要把一些对外的接口定义为public级别，以便其他人导入该Framework后可以正常使用其功能。这些被你定义为public的接口，就是这个Framework的API。

注意：Framework的内部实现细节依然可以使用默认的internal级别，或者也可以定义为private级别。只有当你想把它作为 API 的一部分的时候，才将其定义为public级别。

单元测试目标的访问级别

当你的app有单元测试目标时，为了方便测试，测试模块需要能访问到你app中的代码。默认情况下只有public级别的实体才可以被其他模块访问。然而，如果在引入一个生产模块时使用@testable注解，然后用带测试的方式编译这个生产模块，单元测试目标就可以访问所有internal级别的实体。


访问控制语法
通过修饰符public、internal、private来声明实体的访问级别：
<pre>
public class SomePublicClass {}
internal class SomeInternalClass {}
private class SomePrivateClass {}

public var somePublicVariable = 0
internal let someInternalConstant = 0
private func somePrivateFunction() {}
</pre>

除非有特殊的说明，否则实体都使用默认的访问级别internal，可以查阅默认访问级别这一节。这意味着在不使用修饰符声明显式访问级别的情况下，SomeInternalClass和someInternalConstant仍然拥有隐式的访问级别internal：
<pre>
class SomeInternalClass {}              // 隐式访问级别 internal
var someInternalConstant = 0            // 隐式访问级别 internal
</pre>

自定义类型
如果想为一个自定义类型申明显式访问级别，那么要明确一点。那就是你要确保新类型的访问级别和它实际的作用域相匹配。比如说，如果你定义了一个private类，那这个类就只能在定义它的源文件中当作属性类型、函数参数或者返回类型使用。

类的访问级别也可以影响到类成员（属性、函数、初始化方法等）的默认访问级别。如果你将类申明为private类，那么该类的所有成员的默认访问级别也会成为private。如果你将类申明为public或者internal类（或者不明确的申明访问级别，而使用默认的internal访问级别），那么该类的所有成员的访问级别是internal。

注意：上面提到，一个public类的所有成员的访问级别默认为internal级别，而不是public级别。如果你想将某个成员申明为public级别，那么你必须使用修饰符明确的声明该成员。这样做的好处是，在你定义公共接口API的时候，可以明确的选择哪些属性或方法是需要公开的，哪些是内部使用的，可以避免将内部使用的属性方法公开成公共API的错误。
<pre>
public class SomePublicClass {          // 显式的 public 类
    public var somePublicProperty = 0    // 显式的 public 类成员
    var someInternalProperty = 0         // 隐式的 internal 类成员
    private func somePrivateMethod() {}  // 显式的 private 类成员
}

class SomeInternalClass {               // 隐式的 internal 类
    var someInternalProperty = 0         // 隐式的 internal 类成员
    private func somePrivateMethod() {}  // 显式的 private 类成员
}

private class SomePrivateClass {        // 显式的 private 类
    var somePrivateProperty = 0          // 隐式的 private 类成员
    func somePrivateMethod() {}          // 隐式的 private 类成员
}
</pre>

元组类型

元组的访问级别使用是所有类型的访问级别使用中最为严谨的。比如说，如果你构建一个包含两种不同类型元素的元组，其中一个元素类型的访问级别为internal，另一个为private级别，那么这个元组的访问级别为private。也就是说元组的访问级别与元组中访问级别最低的类型一致。

注意：元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推导出的，而不是明确的申明。

函数类型

函数的访问级别需要根据该函数的参数类型和返回类型的访问级别得出。如果根据参数类型和返回类型得出的函数访问级别不符合默认上下文，那么就需要明确地申明该函数的访问级别。

下面的例子定义了一个名为someFunction全局函数，并且没有明确地申明其访问级别。也许你会认为该函数应该拥有默认的访问级别internal，但事实并非如此。事实上，如果按下面这种写法，代码是无法编译通过的：
<pre>
func someFunction() -> (SomeInternalClass, SomePrivateClass) {
    // function implementation goes here
}
</pre>

我们可以看到，这个函数的返回类型是一个元组，该元组中包含两个自定义的类（可查阅自定义类型）。其中一个类的访问级别是internal，另一个的访问级别是private，所以根据元组访问级别的原则，该元组的访问级别是private（元组的访问级别与元组中访问级别最低的类型一致）。

因为该函数返回类型的访问级别是private，所以你必须使用private修饰符，明确的声明该函数：
<pre>
private func someFunction() -> (SomeInternalClass, SomePrivateClass) {
    // function implementation goes here
}
</pre>

将该函数申明为public或internal，或者使用默认的访问级别internal都是错误的，因为如果把该函数当做public或internal级别来使用的话，是无法得到private级别的返回值的。


枚举类型

枚举中成员的访问级别继承自该枚举，你不能为枚举中的成员单独申明不同的访问级别。

比如下面的例子，枚举CompassPoint被明确的申明为public级别，那么它的成员North，South，East，West的访问级别同样也是public：
<pre>
public enum CompassPoint {
    case North
    case South
    case East
    case West
}
</pre>

原始值和关联值

枚举定义中的任何原始值或关联值的类型都必须有一个访问级别，这个级别至少要不低于枚举的访问级别。比如说，你不能在一个internal访问级别的枚举中定义private级别的原始值类型。


嵌套类型

如果在private级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有private访问级别。如果在public或者internal级别的类型中定义嵌套类型，那么该嵌套类型自动拥有internal访问级别。如果想让嵌套类型拥有public访问级别，那么需要明确地申明该嵌套类型的访问级别。


子类
子类的访问级别不得高于父类的访问级别。比如说，父类的访问级别是internal，子类的访问级别就不能申明为public。

此外，在满足子类不高于父类访问级别以及遵循各访问级别作用域（即模块或源文件）的前提下，你可以重写任意类成员（方法、属性、初始化方法、下标索引等）。

如果我们无法直接访问某个类中的属性或函数等，那么可以继承该类，从而可以更容易的访问到该类的类成员。下面的例子中，类A的访问级别是public，它包含一个函数someMethod，访问级别为private。类B继承类A，并且访问级别申明为internal，但是在类B中重写了类A中访问级别为private的方法someMethod，并重新申明为internal级别。通过这种方式，我们就可以访问到某类中private级别的类成员，并且可以重新申明其访问级别，以便其他人使用：
<pre>
public class A {
    private func someMethod() {}
}

internal class B: A {
    override internal func someMethod() {}
}
</pre>

只要满足子类不高于父类访问级别以及遵循各访问级别作用域的前提下（即private的作用域在同一个源文件中，internal的作用域在同一个模块下），我们甚至可以在子类中，用子类成员访问父类成员，哪怕父类成员的访问级别比子类成员的要低：
<pre>
public class A {
    private func someMethod() {}
}

internal class B: A {
    override internal func someMethod() {
        super.someMethod()
    }
}
</pre>

因为父类A和子类B定义在同一个源文件中，所以在类B中可以在重写的someMethod方法中调用super.someMethod()。


常量、变量、属性、下标
常量、变量、属性不能拥有比它们的类型更高的访问级别。比如说，你定义一个public级别的属性，但是它的类型是private级别的，这是编译器所不允许的。同样，下标也不能拥有比索引类型或返回类型更高的访问级别。

如果常量、变量、属性、下标索引的定义类型是private级别的，那么它们必须要明确的申明访问级别为private：
<pre>
private var privateInstance = SomePrivateClass()
</pre>

Getter 和 Setter

常量、变量、属性、下标索引的Getters和Setters的访问级别继承自它们所属成员的访问级别。

Setter的访问级别可以低于对应的Getter的访问级别，这样就可以控制变量、属性或下标索引的读写权限。在var或subscript定义作用域之前，你可以通过private(set)或internal(set)先为它们的写权限申明一个较低的访问级别。

注意：这个规定适用于用作存储的属性或用作计算的属性。即使你不明确地申明存储属性的Getter、Setter，Swift也会隐式的为其创建Getter和Setter，用于对该属性进行读取操作。使用private(set)和internal(set)可以改变Swift隐式创建的Setter的访问级别。这对计算属性也同样适用。
下面的例子中定义了一个名为TrackedString的结构体，它记录了value属性被修改的次数：
<pre>
struct TrackedString {
    private(set) var numberOfEdits = 0
    var value: String = "" {
    didSet {
        numberOfEdits++
    }
    }
}
</pre>

TrackedString结构体定义了一个用于存储String类型的属性value，并将初始化值设为""（即一个空字符串）。该结构体同时也定义了另一个用于存储Int类型的属性名numberOfEdits，它用于记录属性value被修改的次数。这个功能的实现通过属性value的didSet方法实现，每当给value赋新值时就会调用didSet方法，然后将numberOfEdits的值加一。

结构体TrackedString和它的属性value均没有申明显式访问级别，所以它们都拥有默认的访问级别internal。但是该结构体的numberOfEdits属性使用private(set)修饰符进行申明，这意味着numberOfEdits属性只能在定义该结构体的源文件中赋值。numberOfEdits属性的Getter依然是默认的访问级别internal，但是Setter的访问级别是private，这表示该属性只有在当前的源文件中是可读写的，而在当前源文件所属的模块中它只是一个可读的属性。

如果你实例化TrackedString结构体，并且多次对value属性的值进行修改，你就会看到numberOfEdits的值会随着修改次数进行变化：
<pre>
var stringToEdit = TrackedString()
stringToEdit.value = "This string will be tracked."
stringToEdit.value += " This edit will increment numberOfEdits."
stringToEdit.value += " So will this one."
print("The number of edits is \(stringToEdit.numberOfEdits)")
// prints "The number of edits is 3"
</pre>

虽然你可以在其他的源文件中实例化该结构体并且获取到numberOfEdits属性的值，但是你不能对其进行赋值。这样就能很好的告诉使用者，你只管使用，而不需要知道其实现细节。

如果有必要你可以为Getter和Setter方法设定显式访问级别。下面的例子就是明确申明了public访问级别的TrackedString结构体。结构体的成员（包括numberOfEdits属性）拥有默认的访问级别internal。你可以结合public和private(set)修饰符把结构体中的numberOfEdits属性Getter方法的访问级别设置为public，而Setter方法的访问级别设置为private：
<pre>
public struct TrackedString {
    public private(set) var numberOfEdits = 0
    public var value: String = "" {
        didSet {
            numberOfEdits++
        }
    }
    public init() {}
}
</pre>

初始化
我们可以给自定义的初始化方法申明访问级别，但是要不高于它所属类的访问级别。但必要构造器例外，它的访问级别必须和所属类的访问级别相同。

如同函数或方法参数，初始化方法参数的访问级别也不能低于初始化方法的访问级别。


默认初始化方法

Swift为结构体、类都提供了一个默认的无参初始化方法，用于给它们的所有属性提供赋值操作，但不会给出具体值。默认初始化方法可以参阅默认构造器。默认初始化方法的访问级别与所属类型的访问级别相同。

注意：如果一个类型被申明为public级别，那么默认的初始化方法的访问级别为internal。如果你想让无参的初始化方法在其他模块中可以被使用，那么你必须提供一个具有public访问级别的无参初始化方法。

结构体的默认成员初始化方法

如果结构体中的任一存储属性的访问级别为private，那么它的默认成员初始化方法访问级别就是private。尽管如此，结构体的初始化方法的访问级别依然是internal。

如果你想在其他模块中使用该结构体的默认成员初始化方法，那么你需要提供一个访问级别为public的默认成员初始化方法。


协议
如果想为一个协议明确的申明访问级别，那么需要注意一点，就是你要确保该协议只在你申明的访问级别作用域中使用。

协议中的每一个必须要实现的函数都具有和该协议相同的访问级别。这样才能确保该协议的使用者可以实现它所提供的函数。

注意：如果你定义了一个public访问级别的协议，那么实现该协议提供的必要函数也会是public的访问级别。这一点不同于其他类型，比如，public访问级别的其他类型，他们成员的访问级别为internal。

协议继承

如果定义了一个新的协议，并且该协议继承了一个已知的协议，那么新协议拥有的访问级别最高也只和被继承协议的访问级别相同。比如说，你不能定义一个public的协议而去继承一个internal的协议。


协议一致性

类可以采用比自身访问级别低的协议。比如说，你可以定义一个public级别的类，可以让它在其他模块中使用，同时它也可以采用一个internal级别的协议，并且只能在定义了该协议的模块中使用。

采用了协议的类的访问级别取它本身和所采用协议中最低的访问级别。也就是说如果一个类是public级别，采用的协议是internal级别，那么采用了这个协议后，该类的访问级别也是internal。

如果你采用了协议，那么实现了协议所必须的方法后，该方法的访问级别遵循协议的访问级别。比如说，一个public级别的类，采用了internal级别的协议，那么该类实现协议的方法至少也得是internal。

注意：Swift和Objective-C一样，协议的一致性保证了一个类不可能在同一个程序中用不同的方法采用同一个协议。

扩展
你可以在条件允许的情况下对类、结构体、枚举进行扩展。扩展成员应该具有和原始类成员一致的访问级别。比如你扩展了一个公共类型，那么你新加的成员应该具有和原始成员一样的默认的internal访问级别。

或者，你可以明确申明扩展的访问级别（比如使用private extension）给该扩展内所有成员申明一个新的默认访问级别。这个新的默认访问级别仍然可以被单独成员所申明的访问级别所覆盖。


协议的扩展

如果一个扩展采用了某个协议，那么你就不能对该扩展使用访问级别修饰符来申明了。该扩展中实现协议的方法都会遵循该协议的访问级别。


泛型
泛型类型或泛型函数的访问级别取泛型类型、函数本身、泛型类型参数三者中的最低访问级别。


类型别名
任何你定义的类型别名都会被当作不同的类型，以便于进行访问控制。一个类型别名的访问级别不可高于原类型的访问级别。比如说，一个private级别的类型别名可以设定给一个public、internal、private的类型，但是一个public级别的类型别名只能设定给一个public级别的类型，不能设定给internal或private 级别的类型。

注意：这条规则也适用于为满足协议一致性而给相关类型命名别名的情况。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>115</wp:post_id>
		<wp:post_date><![CDATA[2015-12-27 12:19:59]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-27 04:19:59]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b024%ef%bc%9a%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%ef%bc%88access-control%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6"><![CDATA[访问控制]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b025%ef%bc%9a%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%ef%bc%88access-control%ef%bc%89]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>swift学习笔记25：高级运算符（Advanced Operators）</title>
		<link>http://www.autoref.cn/?p=117</link>
		<pubDate>Tue, 29 Dec 2015 10:20:51 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=117</guid>
		<description></description>
		<content:encoded><![CDATA[除了在之前介绍过的基本运算符，Swift 中还有许多可以对数值进行复杂操作的高级运算符。这些高级运算符包含了在 C 和 Objective-C 中已经被大家所熟知的位运算符和移位运算符。

与C语言中的算术运算符不同，Swift 中的算术运算符默认是不会溢出的。所有溢出行为都会被捕获并报告为错误。如果想让系统允许溢出行为，可以选择使用 Swift 中另一套默认支持溢出的运算符，比如溢出加法运算符(&+)。所有的这些溢出运算符都是以 & 开头的。

在定义自有的结构体、类和枚举时，最好也同时为它们提供标准Swift运算符的实现。Swift简化了运算符的自定义实现，也使判断不同类型所对应的行为更为简单。

我们不用被预定义的运算符所限制。在 Swift 当中可以自由地定义中缀、前缀、后缀和赋值运算符，以及相应的优先级与结合性。这些运算符在代码中可以像预设的运算符一样使用，我们甚至可以扩展已有的类型以支持自定义的运算符。


位运算符
位运算符(Bitwise operators)可以操作一个数据结构中每个独立的位。它们通常被用在底层开发中，比如图形编程和创建设备驱动。位运算符在处理外部资源的原始数据时也十分有用，比如对自定义通信协议传输的数据进行编码和解码。

Swift 支持C语言中的全部位运算符，具体如下：


按位取反运算符(Bitwise NOT Operator)

按位取反操作符是一个前置运算符，需要直接放在操作数的之前，并且它们之间不能添加任何空格。
<pre>
let initialBits: UInt8 = 0b00001111
let invertedBits = ~initialBits  // 等于 0b11110000
</pre>

UInt8 类型的整数有 8 个比特位，可以存储 0 ~ 255之间的任意整数。这个例子初始化了一个 UInt8 类型的整数，并赋值为二进制的 00001111，它的前 4 位都为0，后 4 位都为1。这个值等价于十进制的 15 。

接着使用按位取反运算符创建了一个名为 invertedBits 的常量，这个常量的值与全部位取反后的 initialBits 相等。即所有的 0 都变成了 1，同时所有的 1 都变成 0。invertedBits 的二进制值为 11110000，等价于无符号十进制数的 240。


按位与运算符(Bitwise AND Operator)

按位与运算符(&)可以对两个数的比特位进行合并。它返回一个新的数，只有当两个操作数的对应位都为 1 的时候，该数的对应位才为 1。

在下面的示例当中，firstSixBits 和 lastSixBits 中间 4 个位的值都为 1 。按位与运算符对它们进行了运算，得到二进制数值 00111100，等价于无符号十进制数的 60：
<pre>
let firstSixBits: UInt8 = 0b11111100
let lastSixBits: UInt8  = 0b00111111
let middleFourBits = firstSixBits & lastSixBits  // 等于 00111100
</pre>

按位或运算符(Bitwise OR Operator)

按位或运算符(|)可以对两个数的比特位进行比较。它返回一个新的数，只要两个操作数的对应位中有任意一个为 1 时，该数的对应位就为 1。

在下面的示例当中，someBits 和 moreBits 将不同的位设置为 1。接位或运算符对它们进行了运算，得到二进制数值 11111110，等价于无符号十进制数的 254：
<pre>
let someBits: UInt8 = 0b10110010
let moreBits: UInt8 = 0b01011110
let combinedbits = someBits | moreBits  // 等于 11111110
</pre>

按位异或运算符(Bitwise XOR Opoerator)

按位异或运算符(^)可以对两个数的比特位进行比较。它返回一个新的数，当两个操作数的对应位不相同时，该数的对应位就为 1：

在下面的示例当中，firstBits 和 otherBits 都有一个自己设置为 1 而对方设置为 0 的位。 按位异或运算符将这两个位都设置为 1，同时将其它位都设置为 0：
<pre>
let firstBits: UInt8 = 0b00010100
let otherBits: UInt8 = 0b00000101
let outputBits = firstBits ^ otherBits  // 等于 00010001
</pre>

按位左移/右移运算符(Bitwise Left and Right Shift Operators)

按位左移运算符(<<)和按位右移运算符(>>)可以对一个数进行指定位数的左移和右移，但是需要遵守下面定义的规则。

对一个数进行按位左移或按位右移，相当于对这个数进行乘以 2 或除以 2 的运算。将一个整数左移一位，等价于将这个数乘以 2，同样地，将一个整数右移一位，等价于将这个数除以 2。


无符号整型的移位操作

对无符号整型进行移位的规则如下：

已经存在的比特位按指定的位数进行左移和右移。
任何移动超出整型存储边界的位都会被丢弃。
用 0 来填充移动后产生的空白位。
这种方法称为逻辑移位(logical shift)。

以下这张图展示了 11111111 << 1(即把 11111111 向左移动 1 位)，和 11111111 >> 1(即把 11111111 向右移动 1 位) 的结果。蓝色的部分是被移位的，灰色的部分是被抛弃的，橙色的部分则是被填充进来的。

下面的代码演示了 Swift 中的移位操作：
<pre>
let shiftBits: UInt8 = 4   // 即二进制的00000100
shiftBits << 1             // 00001000
shiftBits << 2             // 00010000
shiftBits << 5             // 10000000
shiftBits << 6             // 00000000
shiftBits >> 2             // 00000001
</pre>

可以使用移位操作对其他的数据类型进行编码和解码：
<pre>
let pink: UInt32 = 0xCC6699
let redComponent = (pink & 0xFF0000) >> 16    // redComponent 是 0xCC, 即 204
let greenComponent = (pink & 0x00FF00) >> 8   // greenComponent 是 0x66, 即 102
let blueComponent = pink & 0x0000FF           // blueComponent 是 0x99, 即 153
</pre>

这个示例使用了一个命名为 pink 的 UInt32 型常量来存储层叠样式表(CSS)中粉色的颜色值。该 CSS 的十六进制颜色值 #CC6699， 在 Swift 中表示为 0xCC6699。然后利用按位与运算符(&)和按位右移运算符(>>)从这个颜色值中分解出红(CC)、绿(66)以及蓝(99)三个部分。

红色部分是通过对 0xCC6699 和 0xFF0000 进行按位与运算后得到的。0xFF0000 中的 0 部分作为掩码，掩盖了 OxCC6699 中的第二和第三个字节，使得数值中的 6699 被忽略，只留下 0xCC0000。

然后，再将这个数按向右移动 16 位(>> 16)。十六进制中每两个字符表示 8 个比特位，所以移动 16 位后 0xCC0000 就变为 0x0000CC。这个数和0xCC是等同的，也就是十进制数值的 204。

同样的，绿色部分通过对 0xCC6699 和 0x00FF00 进行按位与运算得到 0x006600。然后将这个数向右移动 8 位，得到 0x66，也就是十进制数值的 102。

最后，蓝色部分通过对 0xCC6699 和 0x0000FF 进行按位与运算得到 0x000099。并且不需要进行向右移位，所以结果为 0x99 ，也就是十进制数值的 153。


有符号整型的移位操作

对比无符号整型来说，有符整型的移位操作相对复杂得多，这种复杂性源于有符号整数的二进制表现形式。(为了简单起见，以下的示例都是基于 8 位有符号整数的，但是其中的原理对任何位数的有符号整数都是通用的。)

有符号整数使用第 1 个比特位(通常被称为符号位)来表示这个数的正负。符号位为 0 代表正数，为 1 代表负数。

其余的比特位(通常被称为数值位)存储了这个数的真实值。有符号正整数和无符号数的存储方式是一样的，都是从 0 开始算起。

符号位为 0，说明这是一个正数，另外 7 位则代表了十进制数值 4 的二进制表示。

负数的存储方式略有不同。它存储的是 2 的 n 次方减去它的真实值绝对值，这里的 n 为数值位的位数。一个 8 位的数有 7 个数值位，所以是 2 的 7 次方，即 128。

这次的符号位为 1，说明这是一个负数，另外 7 个位则代表了数值 124(即 128 - 4) 的二进制表示。

负数的表示通常被称为二进制补码(two's complement)表示法。用这种方法来表示负数乍看起来有点奇怪，但它有几个优点。

首先，如果想对 -1 和 -4 进行加法操作，我们只需要将这两个数的全部 8 个比特位进行相加，并且将计算结果中超出 8 位的数值丢弃

其次，使用二进制补码可以使负数的按位左移和右移操作得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 2，每向右一位就将自身的数值除以 2。要达到此目的，对有符号整数的右移有一个额外的规则：

当对正整数进行按位右移操作时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是用 0。

这个行为可以确保有符号整数的符号位不会因为右移操作而改变，这通常被称为算术移位(arithmetic shift)。

由于正数和负数的特殊存储方式，在对它们进行右移的时候，会使它们越来越接近 0。在移位的过程中保持符号位不变，意味着负整数在接近 0 的过程中会一直保持为负。


溢出运算符
在默认情况下，当向一个整数赋超过它容量的值时，Swift 默认会报错，而不是生成一个无效的数。这个行为给我们操作过大或着过小的数的时候提供了额外的安全性。

例如，Int16 型整数能容纳的有符号整数范围是 -32768 到 32767，当为一个 Int16 型变量赋的值超过这个范围时，系统就会报错：
<pre>
var potentialOverflow = Int16.max
// potentialOverflow 的值是 32767, 这是 Int16 能容纳的最大整数

potentialOverflow += 1
// 这里会报错
</pre>

为过大或者过小的数值提供错误处理，能让我们在处理边界值时更加灵活。

然而，也可以选择让系统在数值溢出的时候采取截断操作，而非报错。可以使用 Swift 提供的三个溢出操作符(overflow operators)来让系统支持整数溢出运算。这些操作符都是以 & 开头的：

溢出加法 &+
溢出减法 &-
溢出乘法 &*

数值溢出

数值有可能出现上溢或者下溢。

这个示例演示了当我们对一个无符号整数使用溢出加法(&+)进行上溢运算时会发生什么：
<pre>
var unsignedOverflow = UInt8.max
// unsignedOverflow 等于 UInt8 所能容纳的最大整数 255

unsignedOverflow = unsignedOverflow &+ 1
// 此时 unsignedOverflow 等于 0
</pre>

unsignedOverflow 被初始化为 UInt8 所能容纳的最大整数(255，以二进制表示即 11111111)。然后使用了溢出加法运算符(&+)对其进行加 1 操作。这使得它的二进制表示正好超出 UInt8 所能容纳的位数，也就导致了数值的溢出，如下图所示。数值溢出后，留在 UInt8 边界内的值是 00000000，也就是十进制数值的 0。

同样地，当我们对一个无符号整数使用溢出减法(&-)进行下溢运算时也会产生类似的现象：
<pre>
var unsignedOverflow = UInt8.min
// unsignedOverflow 等于 UInt8 所能容纳的最小整数 0

unsignedOverflow = unsignedOverflow &- 1
// 此时 unsignedOverflow 等于 255
</pre>

UInt8 型整数能容纳的最小值是 0，以二进制表示即 00000000。当使用溢出减法运算符对其进行减 1 操作时，数值会产生下溢并被截断为 11111111， 也就是十进制数值的 255。

溢出也会发生在有符号整型数值上。在对有符号整型数值进行溢出加法或溢出减法运算时，符号位也需要参与计算，正如按位左移/右移运算符所描述的。
<pre>
var signedOverflow = Int8.min
// signedOverflow 等于 Int8 所能容纳的最小整数 -128

signedOverflow = signedOverflow &- 1
// 此时 signedOverflow 等于 127
</pre>

Int8 型整数能容纳的最小值是 -128，以二进制表示即 10000000。当使用溢出减法操作符对其进行减 1 操作时，符号位被翻转，得到二进制数值 01111111，也就是十进制数值的 127，这个值也是 Int8 型整数所能容纳的最大值。

对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大的数。


优先级和结合性
运算符的优先级(precedence)使得一些运算符优先于其他运算符，高优先级的运算符会先被计算。

结合性(associativity)定义了相同优先级的运算符是如何结合（或关联）的 —— 是与左边结合为一组，还是与右边结合为一组。可以将这意思理解为“它们是与左边的表达式结合的”或者“它们是与右边的表达式结合的”。

在复合表达式的运算顺序中，运算符的优先级和结合性是非常重要的。举例来说，为什么下面这个表达式的运算结果是 4？

2 + 3 * 4 % 5
// 结果是 4
如果严格地从左到右进行运算，则运算的过程是这样的：

2 + 3 = 5
5 * 4 = 20
20 % 5 = 0
但是正确答案是 4 而不是 0。优先级高的运算符要先于优先级低的运算符进行计算。与C语言类似，在 Swift 当中，乘法运算符(*)与取余运算符(%)的优先级高于加法运算符(+)。因此，它们的计算顺序要先于加法运算。

而乘法与取余的优先级相同。这时为了得到正确的运算顺序，还需要考虑结合性。乘法与取余运算都是左结合的。可以将这考虑成为这两部分表达式都隐式地加上了括号：

2 + ((3 * 4) % 5)
(3 * 4) = 12，所以表达式相当于：

2 + (12 % 5)
12 % 5 = 2，所以表达式相当于：

2 + 2
此时可以容易地看出计算的结果为 4。

如果想查看完整的 Swift 运算符优先级和结合性规则，请参考表达式。如果想查看 Swift 标准库提供所有的操作符，请查看Swift Standard Library Operators Reference

注意：
对于C语言和 Objective-C 来说，Swift 的运算符优先级和结合性规则是更加简洁和可预测的。但是，这也意味着它们于那些基于C的语言不是完全一致的。在对现有的代码进行移植的时候，要注意确保运算符的行为仍然是按照你所想的那样去执行。

运算符函数
类和结构可以为现有的操作符提供自定义的实现，这通常被称为运算符重载(overloading)。

下面的例子展示了如何为自定义的结构实现加法操作符(+)。算术加法运算符是一个两目运算符(binary operator)，因为它可以对两个目标进行操作，同时它还是中缀(infix)运算符，因为它出现在两个目标中间。

例子中定义了一个名为 Vector2D 的结构体用来表示二维坐标向量(x, y)，紧接着定义了一个可以对两个 Vector2D 结构体进行相加的运算符函数(operator function)：
<pre>
struct Vector2D {
    var x = 0.0, y = 0.0
}

func + (left: Vector2D, right: Vector2D) -> Vector2D {
    return Vector2D(x: left.x + right.x, y: left.y + right.y)
}
</pre>

该运算符函数被定义为一个全局函数，并且函数的名字与它要进行重载的 + 名字一致。因为算术加法运算符是双目运算符，所以这个运算符函数接收两个类型为 Vector2D 的输入参数，同时有一个 Vector2D 类型的返回值。

在这个实现中，输入参数分别被命名为 left 和 right，代表在 + 运算符左边和右边的两个 Vector2D 对象。函数返回了一个新的 Vector2D 的对象，这个对象的 x 和 y 分别等于两个参数对象的 x 和 y 的值之和。

这个函数被定义成全局的，而不是 Vector2D 结构的成员方法，所以任意两个 Vector2D 对象都可以使用这个中缀运算符：
<pre>
let vector = Vector2D(x: 3.0, y: 1.0)
let anotherVector = Vector2D(x: 2.0, y: 4.0)
let combinedVector = vector + anotherVector
// combinedVector 是一个新的Vector2D, 值为 (5.0, 5.0)
</pre>

这个例子实现两个向量 (3.0，1.0) 和 (2.0，4.0) 的相加，并得到新的向量 (5.0，5.0)。

前缀和后缀运算符

上个例子演示了一个双目中缀运算符的自定义实现。类与结构体也能提供标准单目运算符(unary operators)的实现。单目运算符只有一个操作目标。当运算符出现在操作目标之前时，它就是前缀(prefix)的(比如 -a)，而当它出现在操作目标之后时，它就是后缀(postfix)的(比如 i++)。

要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 func 关键字之前指定 prefix 或者 postfix 限定符：
<pre>
prefix func - (vector: Vector2D) -> Vector2D {
    return Vector2D(x: -vector.x, y: -vector.y)
}
</pre>

这段代码为 Vector2D 类型实现了单目减运算符(-a)。由于单目减运算符是前缀运算符，所以这个函数需要加上 prefix 限定符。

对于简单数值，单目减运算符可以对它们的正负性进行改变。对于 Vector2D 来说，单目减运算将其 x 和 y 属性的正负性都进行了改变。
<pre>
let positive = Vector2D(x: 3.0, y: 4.0)
let negative = -positive
// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例

let alsoPositive = -negative
// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例
</pre>

复合赋值运算符

复合赋值运算符(Compound assignment operators)将赋值运算符(=)与其它运算符进行结合。比如，将加法与赋值结合成加法赋值运算符(+=)。在实现的时候，需要把运算符的左参数设置成 inout 类型，因为这个参数的值会在运算符函数内直接被修改。
<pre>
func += (inout left: Vector2D, right: Vector2D) {
    left = left + right
}
</pre>

因为加法运算在之前已经定义过了，所以在这里无需重新定义。在这里可以直接利用现有的加法运算符函数，用它来对左值和右值进行相加，并再次赋值给左值：
<pre>
var original = Vector2D(x: 1.0, y: 2.0)
let vectorToAdd = Vector2D(x: 3.0, y: 4.0)
original += vectorToAdd
// original 的值现在为 (4.0, 6.0)
</pre>

还可以将赋值与 prefix 或 postfix 限定符结合起来，下面的代码为 Vector2D 实例实现了前缀自增运算符(++a)：
<pre>
prefix func ++ (inout vector: Vector2D) -> Vector2D {
    vector += Vector2D(x: 1.0, y: 1.0)
    return vector
}
</pre>

这个前缀自增运算符使用了前面定义的加法赋值操作。它对 Vector2D 的 x 和 y 属性都进行了加 1 操作，再将结果返回：
<pre>
var toIncrement = Vector2D(x: 3.0, y: 4.0)
let afterIncrement = ++toIncrement
// toIncrement 的值现在为 (4.0, 5.0)
// afterIncrement 的值同样为 (4.0, 5.0)
</pre>

注意： 不能对默认的赋值运算符(=)进行重载。只有组合赋值符可以被重载。同样地，也无法对三目条件运算符 a ? b : c 进行重载。

等价操作符

自定义的类和结构体没有对等价操作符(equivalence operators)进行默认实现，等价操作符通常被称为“相等”操作符(==)与“不等”操作符(!=)。对于自定义类型，Swift 无法判断其是否“相等”，因为“相等”的含义取决于这些自定义类型在你的代码中所扮演的角色。

为了使用等价操作符来对自定义的类型进行判等操作，需要为其提供自定义实现，实现的方法与其它中缀运算符一样：
<pre>
func == (left: Vector2D, right: Vector2D) -> Bool {
    return (left.x == right.x) && (left.y == right.y)
}
func != (left: Vector2D, right: Vector2D) -> Bool {
    return !(left == right)
}
</pre>

上述代码实现了“相等”运算符(==)来判断两个 Vector2D 对象是否有相等。对于 Vector2D 类型来说，“相等”意味“两个实例的 x属性 和 y 属性都相等”，这也是代码中用来进行判等的逻辑。示例里同时也实现了“不等”操作符(!=)，它简单地将“相等”操作符进行取反后返回。

现在我们可以使用这两个运算符来判断两个 Vector2D 对象是否相等。
<pre>
let twoThree = Vector2D(x: 2.0, y: 3.0)
let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)
if twoThree == anotherTwoThree {
    print("These two vectors are equivalent.")
}
// prints "These two vectors are equivalent."
</pre>

自定义运算符
除了实现标准运算符，在 Swift 当中还可以声明和实现自定义运算符(custom operators)。可以用来自定义运算符的字符列表请参考操作符

新的运算符要在全局作用域内，使用 operator 关键字进行声明，同时还要指定 prefix、infix 或者 postfix 限定符：
<pre>
prefix operator +++ {}
</pre>

上面的代码定义了一个新的名为 +++ 的前缀运算符。对于这个运算符，在 Swift 中并没有意义，因为我们针对 Vector2D 的实例来定义它的意义。对这个示例来讲，+++ 被实现为“前缀双自增”运算符。它使用了前面定义的复合加法操作符来让矩阵对自身进行相加，从而让 Vector2D 实例的 x 属性和 y属性的值翻倍：
<pre>
prefix func +++ (inout vector: Vector2D) -> Vector2D {
    vector += vector
    return vector
}
</pre>

Vector2D 的 +++ 的实现和 ++ 的实现很相似, 唯一不同的是前者对自身进行相加, 而后者是与另一个值为 (1.0, 1.0) 的向量相加.
<pre>
var toBeDoubled = Vector2D(x: 1.0, y: 4.0)
let afterDoubling = +++toBeDoubled
// toBeDoubled 现在的值为 (2.0, 8.0)
// afterDoubling 现在的值也为 (2.0, 8.0)
</pre>

自定义中缀运算符的优先级和结合性

自定义的中缀(infix)运算符也可以指定优先级(precedence)和结合性(associativity)。优先级和结合性中详细阐述了这两个特性是如何对中缀运算符的运算产生影响的。

结合性(associativity)可取的值有left，right 和 none。当左结合运算符跟其他相同优先级的左结合运算符写在一起时，会跟左边的操作数进行结合。同理，当右结合运算符跟其他相同优先级的右结合运算符写在一起时，会跟右边的操作数进行结合。而非结合运算符不能跟其他相同优先级的运算符写在一起。

结合性(associativity)的默认值是 none，优先级(precedence)如果没有指定，则默认为 100。

以下例子定义了一个新的中缀运算符 +-，此操作符是左结合的，并且它的优先级为 140：
<pre>
infix operator +- { associativity left precedence 140 }
func +- (left: Vector2D, right: Vector2D) -> Vector2D {
    return Vector2D(x: left.x + right.x, y: left.y - right.y)
}
let firstVector = Vector2D(x: 1.0, y: 2.0)
let secondVector = Vector2D(x: 3.0, y: 4.0)
let plusMinusVector = firstVector +- secondVector
// plusMinusVector 是一个 Vector2D 类型，并且它的值为 (4.0, -2.0)
</pre>

这个运算符把两个向量的 x 值相加，同时用第一个向量的 y 值减去第二个向量的 y 值。因为它本质上是属于“加型”运算符，所以将它的结合性和优先级被设置为(left 和 140)，这与 + 和 - 等默认的中缀加型操作符是相同的。完整的 Swift 操作符默认结合性与优先级请参考Swift Standard Library Operators Reference。

注意： 当定义前缀与后缀操作符的时候，我们并没有指定优先级。然而，如果对同一个操作数同时使用前缀与后缀操作符，则后缀操作符会先被执行。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>117</wp:post_id>
		<wp:post_date><![CDATA[2015-12-29 18:20:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-29 10:20:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b025%ef%bc%9a%e9%ab%98%e7%ba%a7%e8%bf%90%e7%ae%97%e7%ac%a6%ef%bc%88advanced-operators%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<category domain="category" nicename="swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><![CDATA[swift学习笔记]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e7%ba%a7%e8%bf%90%e7%ae%97%e7%ac%a6"><![CDATA[高级运算符]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
			<wp:meta_value><![CDATA[swift%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b026%ef%bc%9a%e9%ab%98%e7%ba%a7%e8%bf%90%e7%ae%97%e7%ac%a6%ef%bc%88advanced-operators%ef%bc%89]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Xcode，Could not insert new outlet connection: Could not find any information for the class named &quot;xxx&quot;</title>
		<link>http://www.autoref.cn/?p=168</link>
		<pubDate>Mon, 14 Dec 2015 03:44:56 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=168</guid>
		<description></description>
		<content:encoded><![CDATA[在Xcode中，更改界面对应的代码文件名后，在StoryBoard编辑界面中通过“Control键+拖拽“的方式将某个界面元素和对应的代码文件连接创建outlet时报：
Could not insert new outlet connection: Could not find any information for the class named "xxx".
“xxx”是目标代码文件中的类名。

这是因为在更改类名后需要更新对应的“Target”。选中需要操作的类的文件，在“File inspector”界面的“Target Membership”中确认对应的“Target”有没有选中，如果没有选中就勾选上，如果选中了，取消重新勾选一下。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>168</wp:post_id>
		<wp:post_date><![CDATA[2015-12-14 11:44:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2015-12-14 03:44:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[xcode%ef%bc%8ccould-not-insert-new-outlet-connection-could-not-find-any-information-for-the-class-named-xxx]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="post_tag" nicename="ios"><![CDATA[iOS]]></category>
		<category domain="category" nicename="ios-issues"><![CDATA[iOS issues]]></category>
		<category domain="post_tag" nicename="outlet"><![CDATA[outlet]]></category>
		<category domain="post_tag" nicename="storyboard"><![CDATA[StoryBoard]]></category>
		<category domain="post_tag" nicename="swift"><![CDATA[swift]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Android Studio：基于Gradle构建Android项目</title>
		<link>http://www.autoref.cn/?p=194</link>
		<pubDate>Sun, 10 Jan 2016 09:23:34 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://120.25.204.37/?p=194</guid>
		<description></description>
		<content:encoded><![CDATA[Gradle跟Ant/Maven一样，是一种依赖管理/自动化构建工具。跟Ant/Maven使用xml语言不一样，Gradle是基于Groovy的内部领域特定（DSL）语言，更简洁、灵活，并完全兼容Maven和ivy。
Android Studio中的项目通常至少包含两个build.gradle文件，一个是Project范围的，另一个是Module范围的，一个Project可以有多个Module，每个Module下都会对应一个build.gradle。

以下是一个Project下build.gradle的配置：
<pre>// Gradle脚本依赖的仓库
buildscript {
    // 构建过程依赖的仓库
    repositories {
        jcenter()   // 表示依赖从 Bintary’s JCenter Maven 仓库中获取
    }

    // 构建过程需要依赖的库
    dependencies {
        // gradle插件的版本
        classpath 'com.android.tools.build:gradle:1.5.0'
    }
}

// 整个项目依赖的仓库
allprojects {
    repositories {
        jcenter()
    }
}

// 删除编译目录
task clean(type: Delete) {
    delete rootProject.buildDir
}
</pre>
可以为repositories设置多个库，Gradle会根据依赖定义的顺序依次在各个库里找。
&nbsp;
再来看看一个Module下build.gradle的配置：
<pre>// 表示使用com.android.application插件，当Module为一个android库时使用com.android.library
apply plugin: 'com.android.application'

// 配置Android构建过程需要的参数
android {
    // 编译的SDK版本
    compileSdkVersion 21
    // ADT版本
    buildToolsVersion "23.0.2"

    // Android项目的默认设置
    defaultConfig {
        // 应用程序包名
        applicationId "com.example.nikovinci.myapplication"
        // 最低支持Android版本
        minSdkVersion 15
        // 目标版本
        targetSdkVersion 21
        // 版本号
        versionCode 1
        // 版本名称
        versionName "1.0"
    }

    // 编译类型，默认有release和debug
    buildTypes {
        release {
            // 是否使用混淆(老版本中为runProguard)
            minifyEnabled false
            // 使用的混淆文件，可以使用多个混淆文件，使用了SDK中的proguard-android.txt文件以及当前Module*下的proguard-rules.pro文件
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'

            // 配置签名
            signingConfig signingConfigs.release
        }
    }

    // 声明编译的java版本
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }

    // 配置签名
    signingConfigs {
        // debug版本的签名配置，通常不用配
        // debug的默认签名为：signingConfig android.signingCongfigs.debug
        // 位置为：${Home}\.android\debug.keystore
        debug {
        }
        release {
            storeFile file("storeFile.jks")
            storePassword "123456"
            keyAlias "keyAlias"
            keyPassword "123456"
        }
    }
}

// 用于配制引用的依赖
dependencies {
    // 引用当前Module下libs文件夹中的所有.jar文件。
    compile fileTree(dir: 'libs', include: ['*.jar'])
    // 单元测试JUnit的依赖（test模式下依赖某一个库，该库不会在正式发布时打包到程序中，和debugCompile类似）
    testCompile 'junit:junit:4.12'
    // 引用21.0.3版本的appcompat-v7
    compile 'com.android.support:appcompat-v7:21.0.3'
}
</pre>
&nbsp;
Project下的settings.gradle文件：
<pre>include ':app' //表示当前project下有一个名称为app的module
</pre>
如果一个Module不是Project根目录下，可以设置为：
<pre>include ':app2'
project(':app2').projectDir = new File('{$Home}/path/app2')
</pre>
如果有一个模块app3，并且app模块是依赖app3的，这时候要在app模块的build.gradle中的dependencies结点下配置依赖：
<pre>compile project(':app3')
</pre>
并且在settings.gradle中把app3模块包含进来：
<pre>include ':app', ':app3'
</pre>
&nbsp;
Project下的gradle.properties文件是一个配置文件，定义一些常量供build.gradle使用，比如配置签名相关信息如keystore位置、密码、keyalias等：
<pre>
RELEASE_STOREFILE=storeFile.jks
RELEASE_STORE_PASSWORD=123456
RELEASE_KEY_ALIAS=keyAlias
RELEASE_KEY_PASSWORD=123456
</pre>
在模块的build.gradle中直接引用：
<pre>
storeFile file(RELEASE_STOREFILE)
storePassword RELEASE_STORE_PASSWORD
keyAlias RELEASE_KEY_ALIAS
keyPassword RELEASE_KEY_PASSWORD
</pre>
&nbsp;
Project下的gradlew和gradlew.bat是linux下的shell脚本和windows下的批处理文件，它们会根据gradle-wrapper.properties文件中的distributionUrl下载对应的gradle版本。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>194</wp:post_id>
		<wp:post_date><![CDATA[2016-01-10 17:23:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-10 09:23:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[android-studio%ef%bc%9a%e5%9f%ba%e4%ba%8egradle%e6%9e%84%e5%bb%baandroid%e9%a1%b9%e7%9b%ae]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android-studio"><![CDATA[android studio]]></category>
		<category domain="post_tag" nicename="android-studio"><![CDATA[android studio]]></category>
		<category domain="post_tag" nicename="gradle"><![CDATA[gradle]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Android网络通信框架Volley解析1：基本网络通信请求</title>
		<link>http://www.autoref.cn/?p=204</link>
		<pubDate>Fri, 08 Jan 2016 15:51:03 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=204</guid>
		<description></description>
		<content:encoded><![CDATA[Volley是Google在2013年I/O大会上推出的一个新的网络通信框架，使用简单、代码轻量、通信速度快、并发量大，非常适合数据量不大，但通信频繁的网络操作，Volley不适合用于大数据量的网络操作，比如说下载文件等。
&nbsp;
初始化请求队列
<pre>RequestQueue mRequestQueue = Volley.newRequestQueue(context);
</pre>
RequestQueue是一个请求队列对象，可以缓存所有的HTTP请求，不必为每一次HTTP请求都创建一个RequestQueue对象，一般习惯用法是在Application中全局初始化。
&nbsp;
ObjectRequest需要根据自己请求返回的数据来定制，继承抽象类Request，Vollay已经实现了StringRequest、JsonArrayRequest、JsonObjectRequest、ImageRequest请求。
&nbsp;
StringRequest：通过URL请求，并获取字符串响应体。请求类型通常有GET和POST两种，默认为GET。
<pre>
StringRequest stringRequest = new StringRequest("www.autoref.cn",
      new Response.Listener<String>() {
           @Override
           public void onResponse(String response) {
               Log.d("TAG", response);
           }
      }, new Response.ErrorListener() {
           @Override
           public void onErrorResponse(VolleyError error) {
               Log.e("TAG", error.getMessage());
           }
      });
// 将StringRequest对象添加到RequestQueue里
requestQueue.add(stringRequest);
</pre>
StringRequest中还提供了另外一种四个参数的构造函数，其中第一个参数就是指定请求类型的，但是StringRequest中并没有提供设置POST参数的方法，我们可以通过StringRequest的父类Request中的getParams()方法来获取POST参数，只需要在StringRequest的匿名类中重写getParams()方法设置POST参数：
<pre>
StringRequest stringRequest = new StringRequest(Request.Method.POST, url, listener, errorListener) {
      @Override
      protected Map<String, String> getParams() throws AuthFailureError {
           Map<String, String> map = new HashMap<String, String>();
           map.put("params1", "value1");
           map.put("params2", "value2");
           return map;
      }
};
</pre>
另外我们可以重写parseNetworkResponse方法来改变返回的头参数
<pre>
StringRequest stringRequest = new StringRequest(Request.Method.GET, url, listener, errorListener) {
      protected final String TYPE_UTF8_CHARSET = "charset=UTF-8";

      @Override
      protected Response<String> parseNetworkResponse(NetworkResponse response) {
           try {
               // 如果编码不是UTF-8的话就转换，解决乱码问题
               String type = response.headers.get(HTTP.CONTENT_TYPE);
               if (type == null) {
                   type = TYPE_UTF8_CHARSET;
                   response.headers.put(HTTP.CONTENT_TYPE, type);
               } else if (!type.contains("UTF-8")) {
                   type += ";" + TYPE_UTF8_CHARSET;
                   response.headers.put(HTTP.CONTENT_TYPE, type);
               }
           } catch (Exception e) {}
           return super.parseNetworkResponse(response);
      }
};
</pre>
&nbsp;
JsonRequest：JsonRequest也继承自Request类的，不过JsonRequest是一个抽象类，JsonRequest有两个直接的子类，JsonObjectRequest和JsonArrayRequest，一个是用于请求JSON数据，一个是用于请求JSON数组，用法和StringRequest类似。
<pre>
JsonObjectRequest jsonObjectRequest = new JsonObjectRequest("www.autoref.cn", null,  
        new Response.Listener<JSONObject>() {  
            @Override  
            public void onResponse(JSONObject response) {  
                Log.d("TAG", response.toString());  
            }  
        }, new Response.ErrorListener() {  
            @Override  
            public void onErrorResponse(VolleyError error) {  
                Log.e("TAG", error.getMessage(), error);  
            }  
        }); 
requestQueue.add(jsonObjectRequest);  
</pre>
&nbsp;
ImageRequest：图片请求
<pre>
    /**
     *
     * @param url
     *            图片地址
     * @param listener
     *            回调，返回一个Bitmap
     * @param maxWidth
     *            允许图片最大的宽度，网络图片的宽度大于最大值，会对图片进行压缩，0表示不压缩
     * @param maxHeight
     *            允许图片最大的高度，网络图片的高度大于最大值，会对图片进行压缩，0表示不压缩
     * @param scaleType
     *            图片伸缩方式，不传默认为ScaleType.CENTER_INSIDE
     * @param decodeConfig
     *            图片的颜色属性
     * @param errorListener
     *            错误回调
     */

ImageRequest imageRequest = new ImageRequest(url, new Response.Listener<Bitmap>() {
            @Override
            public void onResponse(Bitmap bitmap) {
                imageView.setImageBitmap(bitmap);
            }
        }, 60, 60, scaleType, Bitmap.Config.ARGB_8888, null);
</pre>
ImageLoader：也用于加载网络图片，内部是使用ImageRequest来实现的，不过ImageLoader不仅可以对图片进行缓存，还可以过滤掉重复的链接，避免重复发送请求。
<pre>
/**
  *
  * @param requestQueue
  *            RequestQueue对象
  * @param imageCache
  *            作为一级缓存
  */
ImageLoader imageLoader = new ImageLoader(requestQueue, new ImageLoader.ImageCache() {
            @Override
            public void putBitmap(String url, Bitmap bitmap) {
            }

            @Override
            public Bitmap getBitmap(String url) {
                return null;
            }
        });

/**
 * 获取到一个ImageListener对象
 *
 * @param imageView
 * @param defaultImageResId
 *            默认图片，0为不设置
 * @param errorImageResId
 *            请求错误时的图片，0为不设置
 */
ImageLoader.ImageListener listener = ImageLoader.getImageListener(imageView,
                R.drawable.default_image, R.drawable.failure_image);

// 获取图片
imageLoader.get("www.autoref.cn/xxx.jpg", listener);
// 获取图片时也可以指定图片允许的最大宽度和高度
imageLoader.get("www.autoref.cn/xxx.jpg", listener, 200, 200);
</pre>
上面创建的ImageCache对象是一个空的实现，现在我们借助Android提供的LruCache功能，来写一个简单的ImageCache，实现图片的缓存。
<pre>
public class BitmapCache implements ImageCache {  
  
    private LruCache<String, Bitmap> mCache;  
  
    public BitmapCache() {  
        // 将缓存图片的大小设置为5M
        int maxSize = 5 * 1024 * 1024;  
        mCache = new LruCache<String, Bitmap>(maxSize) {  
            @Override  
            protected int sizeOf(String key, Bitmap bitmap) {  
                return bitmap.getRowBytes() * bitmap.getHeight();  
            }  
        };  
    }  
  
    @Override  
    public Bitmap getBitmap(String url) {  
        return mCache.get(url);  
    }  
  
    @Override  
    public void putBitmap(String url, Bitmap bitmap) {  
        mCache.put(url, bitmap);  
    }  
  
}  
</pre>
&nbsp;
NetworkImageView：NetworkImageView继承自ImageView，在原生的基础之上加入了加载网络图片的功能。NetworkImageView在被从父控件detach的时候，会自动取消网络请求，还会根据图片设置的width和heigh自动压缩该图片。
布局XML文件：
<pre>
<com.android.volley.toolbox.NetworkImageView  
    android:id="@+id/network_image_view"  
    android:layout_width="100dp"  
    android:layout_height="100dp" />  
</pre>
代码实现：
<pre>
ImageLoader imageLoader = new ImageLoader(requestQueue, new BitmapCache());
NetworkImageView networkImageView = (NetworkImageView) findViewById(R.id.network_image_view); 
networkImageView.setDefaultImageResId(R.drawable.default_image);  
networkImageView.setErrorImageResId(R.drawable.failure_image);  
networkImageView.setImageUrl("www.autoref.cn/xxx.jpg", imageLoader);  
</pre>
&nbsp;
最后来说说如何取消请求，我们可以给某个请求设置一个标签：
<pre>
request.setTag("Request_Tag");
</pre>
然后在需要的地方取消所有指定标签的请求：
<pre>
request.cancelAll("Request_Tag"); 
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>204</wp:post_id>
		<wp:post_date><![CDATA[2016-01-08 23:51:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-08 15:51:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[android%e7%bd%91%e7%bb%9c%e9%80%9a%e4%bf%a1%e6%a1%86%e6%9e%b6volley%e8%a7%a3%e6%9e%901%ef%bc%9a%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="post_tag" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91"><![CDATA[android应用开发]]></category>
		<category domain="post_tag" nicename="volley"><![CDATA[volley]]></category>
		<category domain="post_tag" nicename="%e6%a1%86%e6%9e%b6"><![CDATA[框架]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e9%80%9a%e4%bf%a1"><![CDATA[网络通信]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Android实现不规则图形按钮非透明区的点击事件</title>
		<link>http://www.autoref.cn/?p=206</link>
		<pubDate>Mon, 11 Jan 2016 14:28:45 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=206</guid>
		<description></description>
		<content:encoded><![CDATA[<pre>
/**
 * 不规则"图形按钮控件"
 *
 */
public class TrapezoidImageButton extends ImageButton {

    public TrapezoidImageButton(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    public TrapezoidImageButton(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public TrapezoidImageButton(Context context) {
        super(context);
    }
    
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (isTouchPointInView(event.getX(),event.getY())||
                event.getAction() != MotionEvent.ACTION_DOWN){
            return super.onTouchEvent(event);
        }else{
            return false;
        }
    }

    protected boolean isTouchPointInView(float localX, float localY){
        Bitmap bitmap = Bitmap.createBitmap(getWidth(), getHeight(), Config.ARGB_8888);
        Canvas canvas = new Canvas(bitmap);
        draw(canvas);
        int x = (int)localX;
        int y = (int)localY;
        if (x < 0 || x >= getWidth())
            return false;
        if (y < 0 || y >= getHeight())
            return false;
        int pixel = bitmap.getPixel(x,y);
        if ((pixel&0xff000000) != 0){ //点在非透明区
            return true;
        }else{
            return false;
        }
    }
}
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>206</wp:post_id>
		<wp:post_date><![CDATA[2016-01-11 22:28:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-11 14:28:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[android%e5%ae%9e%e7%8e%b0%e4%b8%8d%e8%a7%84%e5%88%99%e5%9b%be%e5%bd%a2%e6%8c%89%e9%92%ae%e9%9d%9e%e9%80%8f%e6%98%8e%e5%8c%ba%e7%9a%84%e7%82%b9%e5%87%bb%e4%ba%8b%e4%bb%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="post_tag" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91"><![CDATA[android应用开发]]></category>
		<category domain="post_tag" nicename="imagebutton"><![CDATA[ImageButton]]></category>
		<category domain="post_tag" nicename="%e8%87%aa%e5%ae%9a%e4%b9%89%e6%8e%a7%e4%bb%b6"><![CDATA[自定义控件]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Android网络通信框架Volley解析2：自定义Request</title>
		<link>http://www.autoref.cn/?p=214</link>
		<pubDate>Sat, 09 Jan 2016 03:42:21 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=214</guid>
		<description></description>
		<content:encoded><![CDATA[Volley提供了非常强的扩展机制，使得能够很轻松地定制出任意类型的Request，我们可以模仿StringRequest来自定义其他类型的Request。
&nbsp;
自定义XMLRequest：
<pre>
public class XMLRequest extends Request<XmlPullParser> {
    private final Listener<XmlPullParser> mListener;  
  
    public XMLRequest(int method, String url, Listener<XmlPullParser> listener,  
            ErrorListener errorListener) {  
        super(method, url, errorListener);  
        mListener = listener;  
    }
  
    public XMLRequest(String url, Listener<XmlPullParser> listener, ErrorListener errorListener) {  
        this(Method.GET, url, listener, errorListener);  
    }
  
    @Override  
    protected Response<XmlPullParser> parseNetworkResponse(NetworkResponse response) {  
        try {  
            String xmlString = new String(response.data,  
                    HttpHeaderParser.parseCharset(response.headers));  
            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();  
            XmlPullParser xmlPullParser = factory.newPullParser();  
            xmlPullParser.setInput(new StringReader(xmlString));  
            return Response.success(xmlPullParser, HttpHeaderParser.parseCacheHeaders(response));  
        } catch (UnsupportedEncodingException e) {  
            return Response.error(new ParseError(e));  
        } catch (XmlPullParserException e) {  
            return Response.error(new ParseError(e));  
        }  
    }
  
    @Override  
    protected void deliverResponse(XmlPullParser response) {  
        mListener.onResponse(response);  
    }
}  
</pre>
使用方法跟StringRequest类似：
<pre>
XMLRequest xmlRequest = new XMLRequest(  
        "http://www.autoref.cn/xxx.xml",  
        new Response.Listener<XmlPullParser>() {  
            @Override  
            public void onResponse(XmlPullParser response) {  
                try {  
                    int eventType = response.getEventType();  
                    while (eventType != XmlPullParser.END_DOCUMENT) {  
                        switch (eventType) {  
                        case XmlPullParser.START_TAG:  
                            String nodeName = response.getName();  
                            Log.d("TAG", "NodeName：" + nodeName);
                            break;  
                        }  
                        eventType = response.next();  
                    }  
                } catch (XmlPullParserException e) {  
                    e.printStackTrace();  
                } catch (IOException e) {  
                    e.printStackTrace();  
                }  
            }  
        }, new Response.ErrorListener() {  
            @Override  
            public void onErrorResponse(VolleyError error) {  
                Log.e("TAG", error.getMessage());  
            }  
        });  
mRequestQueue.add(xmlRequest); 
</pre>
&nbsp;
自定义GsonRequest：JsonRequest的数据解析是利用Android自带的JSONObject和JSONArray来实现的，我们可以通过导入Gson包来定义GsonRequest。
<pre>
public class GsonRequest<T> extends Request<T> {  
    private final Listener<T> mListener;
    private Gson mGson;
    private Class<T> mClass;  
  
    public GsonRequest(int method, String url, Class<T> clazz, Listener<T> listener,  
            ErrorListener errorListener) {  
        super(method, url, errorListener);  
        mGson = new Gson();  
        mClass = clazz;  
        mListener = listener;  
    }  
  
    public GsonRequest(String url, Class<T> clazz, Listener<T> listener,  
            ErrorListener errorListener) {  
        this(Method.GET, url, clazz, listener, errorListener);  
    }  
  
    @Override  
    protected Response<T> parseNetworkResponse(NetworkResponse response) {  
        try {  
            String jsonString = new String(response.data,  
                    HttpHeaderParser.parseCharset(response.headers));  
            return Response.success(mGson.fromJson(jsonString, mClass),  
                    HttpHeaderParser.parseCacheHeaders(response));  
        } catch (UnsupportedEncodingException e) {  
            return Response.error(new ParseError(e));  
        }  
    }  
  
    @Override  
    protected void deliverResponse(T response) {  
        mListener.onResponse(response);  
    }  
}
</pre>
使用时需要传入对象类型，如UserInfo对象类型：
<pre>
GsonRequest<UserInfo> gsonRequest = new GsonRequest<UserInfo>(  
        "http://www.autoref.cn", UserInfo.class,  
        new Response.Listener<UserInfo>() {  
            @Override  
            public void onResponse(UserInfo userInfo) {
                Log.d("TAG", "UserInfo");
            }  
        }, new Response.ErrorListener() {  
            @Override  
            public void onErrorResponse(VolleyError error) {  
                Log.e("TAG", error.getMessage());  
            }  
        });  
mRequestQueue.add(gsonRequest);  
</pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>214</wp:post_id>
		<wp:post_date><![CDATA[2016-01-09 11:42:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-09 03:42:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[android%e7%bd%91%e7%bb%9c%e9%80%9a%e4%bf%a1%e6%a1%86%e6%9e%b6volley%e8%a7%a3%e6%9e%902%ef%bc%9a%e8%87%aa%e5%ae%9a%e4%b9%89request]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="post_tag" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91"><![CDATA[android应用开发]]></category>
		<category domain="post_tag" nicename="http"><![CDATA[http]]></category>
		<category domain="post_tag" nicename="volley"><![CDATA[volley]]></category>
		<category domain="post_tag" nicename="%e6%a1%86%e6%9e%b6"><![CDATA[框架]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e9%80%9a%e4%bf%a1"><![CDATA[网络通信]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>android数组资源arrays.xml</title>
		<link>http://www.autoref.cn/?p=217</link>
		<pubDate>Wed, 13 Jan 2016 04:29:57 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=217</guid>
		<description></description>
		<content:encoded><![CDATA[在values目录下创建arrays.xml文件，&lt;string-array&gt;定义字符数组，&lt;integer-array&gt;定义整数数组：
<pre>
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="string_values">
        <item>Alice</item>
        <item>Bob</item>
        <item>Carmon</item>
        <item>David</item>
        <item>Eva</item>
    </string-array>

    <integer-array name="integer_values" translatable="false">
        <item>1</item>
        <item>2</item>
        <item>3</item>
    </integer-array>
</resources>
</pre>
代码引用数组资源：
<pre>String[] stringValues = getResources().getStringArray(R.array.string_values);
Int[] integerValues = getResources().getIntArray(R.array.integer_values);
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>217</wp:post_id>
		<wp:post_date><![CDATA[2016-01-13 12:29:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-13 04:29:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[android%e6%95%b0%e7%bb%84%e8%b5%84%e6%ba%90arrays-xml]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="post_tag" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91"><![CDATA[android应用开发]]></category>
		<category domain="post_tag" nicename="arrays"><![CDATA[arrays]]></category>
		<category domain="post_tag" nicename="xml"><![CDATA[xml]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>MAC中Android Studio配置SVN的Ignore文件</title>
		<link>http://www.autoref.cn/?p=222</link>
		<pubDate>Tue, 12 Jan 2016 10:05:11 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=222</guid>
		<description></description>
		<content:encoded><![CDATA[我们在Android Studio使用SVN管理代码时，需要先添加Ignored，不提交自动生成的文件或文件夹。选择Preferences -&gt; Version Control -&gt; Ignored Files，点击加号，会弹出三个选项：

1、Ignore specified file

2、Ignore all files under

3、Ignore all files matching

首先选择第一个选项添加local.properties后确认，接着选择第二个选项分别添加.gradle、.idea和每个模块下的build目录（如app/build）后确认，最后选择第三个选项添加*.iml后确认。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>222</wp:post_id>
		<wp:post_date><![CDATA[2016-01-12 18:05:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-12 10:05:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[mac%e4%b8%adandroid-studio%e9%85%8d%e7%bd%aesvn%e7%9a%84ignore%e6%96%87%e4%bb%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="post_tag" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android-studio"><![CDATA[android studio]]></category>
		<category domain="post_tag" nicename="android-studio"><![CDATA[android studio]]></category>
		<category domain="post_tag" nicename="ignore"><![CDATA[ignore]]></category>
		<category domain="post_tag" nicename="svn"><![CDATA[svn]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Android数据库开源框架LitePal的使用1、基本配置</title>
		<link>http://www.autoref.cn/?p=224</link>
		<pubDate>Wed, 13 Jan 2016 16:23:05 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=224</guid>
		<description></description>
		<content:encoded><![CDATA[LitePal是一个开源Android库，使开发者可以在不写一句SQL语句下，很简单的使用SQLite数据库，而且在项目中集成配置也简单。

先来看看LitePal的几个特点：
<ul>
	<li>使用对象关系映射（ORM）模式</li>
	<li>几乎零配置</li>
	<li>自动维护表，包括创建、修改、删除</li>
	<li>封装APIs，避免写SQL语句</li>
	<li>令人惊叹的簇查询函数</li>
	<li>仍旧可以选择使用SQL，但比原始的要简单好用</li>
	<li>开源</li>
</ul>
&nbsp;
1、<a href="https://github.com/LitePalFramework/LitePal/raw/master/downloads/litepal-1.3.0.jar" target="_blank">点击下载</a>并引入jar包
Eclipse项目：将jar包导入libs文件夹
Android Studio项目：直接配置build.gradle文件
<pre>dependencies {
    compile 'org.litepal.android:core:1.3.0'
}
</pre>
&nbsp;
2、配置litepal.xml文件
在项目的assets文件夹中创建litepal.xml文件：
<pre>
<?xml version="1.0" encoding="utf-8"?>
<litepal>
    <dbname value="demo" ></dbname>

    <version value="1" ></version>

    <list>
    </list>
</litepal>
</pre>
这是唯一的文件：
<ul>
	<li>dbname 配置项目的数据库名字。名字后面如果没有写.db，LitePal会自动添加。</li>
</ul>
<ul>
	<li>version 配置数据库版本号。每次更新数据库后，版本号加1。</li>
</ul>
<ul>
	<li>list 配置映射类。包名+类名，如&lt;mapping class="cn.autoref.UserInfo"&gt;&lt;/mapping&gt;</li>
</ul>
&nbsp;
3、配置LitePalApplication
LitePal需要在AndroidManifest.xml中配置一下LitePalApplication：
<pre>
<manifest>
    <application
        android:name="org.litepal.LitePalApplication"
        ...
    >
    ...
    </application>
</manifest>
</pre>
如果有自己的MyApplication，并在上面配置过了。只需要让MyApplication继承LitePalApplication类：
<pre>public class MyApplication extends LitePalApplication {  
    ...  
}  
</pre>
另一种情况是，MyApplication继承另外一个AnotherApplication，并且这个AnotherApplication还是在jar包当中，不能修改它的源码的，我们可以调用LitePalApplication.initialize(context)方法代替继承：
<pre>public class MyOwnApplication extends AnotherApplication {

    @Override
    public void onCreate() {
        super.onCreate();
        LitePalApplication.initialize(this);
    }
    ...
}
</pre>
LitePalApplication.initialize(context)中的context，要用application级别的，不能使用activity或者service的实例，否则可能会造成内存泄露。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>224</wp:post_id>
		<wp:post_date><![CDATA[2016-01-14 00:23:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-13 16:23:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[android%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e6%ba%90%e6%a1%86%e6%9e%b6litepal%e7%9a%84%e4%bd%bf%e7%94%a81%e3%80%81%e5%9f%ba%e6%9c%ac%e9%85%8d%e7%bd%ae]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="post_tag" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91"><![CDATA[android应用开发]]></category>
		<category domain="post_tag" nicename="litepal"><![CDATA[LitePal]]></category>
		<category domain="post_tag" nicename="%e5%bc%80%e6%ba%90%e6%a1%86%e6%9e%b6"><![CDATA[开源框架]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e5%ba%93"><![CDATA[数据库]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>2</wp:comment_id>
			<wp:comment_author><![CDATA[Android数据库开源框架LitePal的使用2、增删改查 | 小宝的技术锅]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.autoref.cn/?p=226</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[120.25.204.37]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2015-12-16 02:33:33]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2015-12-15 18:33:33]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] Android数据库开源框架LitePal的使用1、基本配置 [&#8230;]]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[pingback]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>Android数据库开源框架LitePal的使用2、增删改查</title>
		<link>http://www.autoref.cn/?p=226</link>
		<pubDate>Fri, 15 Jan 2016 10:53:24 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=226</guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://www.autoref.cn/?p=224" target="_blank">前面介绍了LitePal的配置</a>，现在来看看怎么使用。
&nbsp;
1、创建表
先添加两个Model，Album和Song，都继承DataSupport类
<pre>public class Album extends DataSupport {

    @Column(unique = true, defaultValue = "unknown")
    private String name;

    private float price;

    private List songs = new ArrayList();

    // generated getters and setters.
}
</pre>
&nbsp;
<pre>public class Song extends DataSupport {

    @Column(nullable = false)
    private String name;

    private int duration;

    @Column(ignore = true)
    private String uselessField;

    private Album album;

    // generated getters and setters.
}
</pre>
然后把它们添加到litepal.xml文件：
<pre>
<list>
    <mapping class="cn.autoref.litepalsample.model.Album"></mapping>
    <mapping class="cn.autoref.litepalsample.model.Song"></mapping>
</list>
</pre>
现在数据表会在下次数据库操作时自动生成，比如获取SQLiteDatabase实例：
<pre>SQLiteDatabase db = Connector.getDatabase();
</pre>
相当于下面两条SQL语句：
<pre>CREATE TABLE album (
    id integer primary key autoincrement,
    name text unique default 'unknown',
    price real 
);

CREATE TABLE song (
    id integer primary key autoincrement,
    name text not null,
    duration integer,
    album_id integer
);
</pre>
2、更新数据表
例如在Album中忽略字段price，增加时间字段releaseDate：
<pre>public class Album extends DataSupport {

    @Column(unique = true, defaultValue = "unknown")
    private String name;

    @Column(ignore = true)
    private float price;

    private Date releaseDate;

    private List songs = new ArrayList();

    // generated getters and setters.
}
</pre>
接着在litepal.xml文件中将版本号加1，那么在下次数据库操作时，会在表中增加releasedate字段，并删除原来的price字段。
但是一些操作LitePal处理不了，会直接清除所有数据，比如：
<ul>
	<li>增加一个注解为unique = true的字段</li>
	<li>改变一个字段的注解为unique = true</li>
	<li>改变一个字段的注解为nullable = false</li>
</ul>
&nbsp;
3、保存数据
所有的Model都会继承自DataSupport，直接使用save()方法保存数据
<pre>
Album album = new Album();
album.setName("album");
album.setPrice(10.99f);
album.save();

Song song1 = new Song();
song1.setName("song1");
song1.setDuration(320);
song1.setAlbum(album);
song1.save();

Song song2 = new Song();
song2.setName("song2");;
song2.setDuration(356);
song2.setAlbum(album);
song2.save();
</pre>
&nbsp;
4、更新数据
根据指定ID更新一条记录：
<pre>
Album albumToUpdate = new Album();
albumToUpdate.setPrice(20.99f); // raise the price
albumToUpdate.update(id);
</pre>
使用where条件语句更新多条记录：
<pre>
Album albumToUpdate = new Album();
albumToUpdate.setPrice(20.99f); // raise the price
albumToUpdate.updateAll("name = ?", "album");
</pre>
&nbsp;
5、删除数据
<pre>
// 删除指定ID的一条记录
DataSupport.delete(Song.class, id);

// 根据条件删除记录
DataSupport.deleteAll(Song.class, "duration > ?" , "350");
</pre>
&nbsp;
6、查询数据
<pre>
// 查询指定ID的一条记录
Song song = DataSupport.find(Song.class, id);

// 查询表所有数据
List<Song> allSongs = DataSupport.findAll(Song.class);

// 约束复杂查询
List<Song> songs = DataSupport.where("name like ?", "song%").order("duration").find(Song.class);
</pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>226</wp:post_id>
		<wp:post_date><![CDATA[2016-01-15 18:53:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-15 10:53:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[android%e6%95%b0%e6%8d%ae%e5%ba%93%e5%bc%80%e6%ba%90%e6%a1%86%e6%9e%b6litepal%e7%9a%84%e4%bd%bf%e7%94%a82%e3%80%81%e5%a2%9e%e5%88%a0%e6%94%b9%e6%9f%a5]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="post_tag" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91"><![CDATA[android应用开发]]></category>
		<category domain="post_tag" nicename="litepal"><![CDATA[LitePal]]></category>
		<category domain="post_tag" nicename="%e5%bc%80%e6%ba%90%e6%a1%86%e6%9e%b6"><![CDATA[开源框架]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e5%ba%93"><![CDATA[数据库]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Android设置软键盘的回车键为搜索</title>
		<link>http://www.autoref.cn/?p=253</link>
		<pubDate>Sat, 16 Jan 2016 09:26:19 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=253</guid>
		<description></description>
		<content:encoded><![CDATA[在布局中添加android:imeOptions="actionSearch"，也可以在代码中设置imeOptions：editText.setImeOptions(EditorInfo.IME_ACTION_SEND);

然后添加代码：
<pre>editText.setOnEditorActionListener(new OnEditorActionListener() {
	@Override
	public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
		// TODO Auto-generated method stub
		if (actionId == EditorInfo.IME_ACTION_SEARCH ||
				(event != null &amp;&amp; event.getKeyCode() == KeyEvent.KEYCODE_ENTER)){
			// do
		}
		return false;
	}
});
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>253</wp:post_id>
		<wp:post_date><![CDATA[2016-01-16 17:26:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-16 09:26:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[android%e8%ae%be%e7%bd%ae%e8%bd%af%e9%94%ae%e7%9b%98%e7%9a%84%e5%9b%9e%e8%bd%a6%e9%94%ae%e4%b8%ba%e6%90%9c%e7%b4%a2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="post_tag" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91"><![CDATA[android应用开发]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e8%bd%af%e9%94%ae%e7%9b%98"><![CDATA[软键盘]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>HTML常用转义字符对照表</title>
		<link>http://www.autoref.cn/?p=229</link>
		<pubDate>Sun, 17 Jan 2016 07:15:37 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=229</guid>
		<description></description>
		<content:encoded><![CDATA[<h2><strong>1、特殊字符</strong></h2>
<div>
<table border="0">
<tbody>
<tr>
<td>©</td>
<td>&amp;copy;</td>
<td>©</td>
<td>版权标志</td>
</tr>
<tr>
<td>|</td>
<td></td>
<td>|</td>
<td>竖线，常用作菜单或导航中的分隔符</td>
</tr>
<tr>
<td>·</td>
<td>&amp;middot;</td>
<td>·</td>
<td>圆点，有时被用来作为菜单分隔符</td>
</tr>
<tr>
<td>↑</td>
<td>&amp;uarr;</td>
<td>↑</td>
<td>上箭头，常用作网页“返回页面顶部”标识</td>
</tr>
<tr>
<td>€</td>
<td>&amp;euro;</td>
<td>€</td>
<td>欧元标识</td>
</tr>
<tr>
<td>²</td>
<td>&amp;sup2;</td>
<td>²</td>
<td>上标2，数学中的平方，在数字处理中常用到，例如：<strong>1000²</strong></td>
</tr>
<tr>
<td>½</td>
<td>&amp;frac12;</td>
<td>½</td>
<td>二分之一</td>
</tr>
<tr>
<td>♥</td>
<td>&amp;hearts;</td>
<td>♥</td>
<td>心型，用来表达你的心</td>
</tr>
</tbody>
</table>
</div>
<div></div>
<h2><strong>2、常用字符</strong></h2>
<div>
<table border="0">
<tbody>
<tr>
<td></td>
<td>&amp;nbsp;</td>
<td></td>
<td>空格</td>
</tr>
<tr>
<td>&amp;</td>
<td>&amp;amp;</td>
<td>&amp;</td>
<td>and符号，与</td>
</tr>
<tr>
<td>"</td>
<td>&amp;quot;</td>
<td>"</td>
<td>引号</td>
</tr>
<tr>
<td>©</td>
<td>&amp;copy;</td>
<td>©</td>
<td>版权标志</td>
</tr>
<tr>
<td>®</td>
<td>&amp;reg;</td>
<td>»</td>
<td>注册标志</td>
</tr>
<tr>
<td>™</td>
<td>&amp;trade;</td>
<td>™</td>
<td>商标标志</td>
</tr>
<tr>
<td>“</td>
<td>&amp;ldquo;</td>
<td>“</td>
<td>左双引号</td>
</tr>
<tr>
<td>”</td>
<td>&amp;rdquo;</td>
<td>”</td>
<td>右双引号</td>
</tr>
<tr>
<td>‘</td>
<td>&amp;lsquo;</td>
<td>‘</td>
<td>做单引号</td>
</tr>
<tr>
<td>’</td>
<td>&amp;rsquo;</td>
<td>’</td>
<td>右单引号</td>
</tr>
<tr>
<td>«</td>
<td>&amp;laquo;</td>
<td>«</td>
<td>左三角双引号</td>
</tr>
<tr>
<td>»</td>
<td>&amp;raquo;</td>
<td>»</td>
<td>右三角双引号</td>
</tr>
<tr>
<td>‹</td>
<td>&amp;lsaquo;</td>
<td>‹</td>
<td>左三角单引号</td>
</tr>
<tr>
<td>›</td>
<td>&amp;rsaquo;</td>
<td>›</td>
<td>右三角单引号</td>
</tr>
<tr>
<td>§</td>
<td>&amp;sect;</td>
<td>§</td>
<td>章节标志</td>
</tr>
<tr>
<td>¶</td>
<td>&amp;para;</td>
<td>¶</td>
<td>段落标志</td>
</tr>
<tr>
<td>•</td>
<td>&amp;bull;</td>
<td>•</td>
<td>列表圆点（大）</td>
</tr>
<tr>
<td>·</td>
<td>&amp;middot;</td>
<td>·</td>
<td>列表圆点（中）</td>
</tr>
<tr>
<td>…</td>
<td>&amp;hellip;</td>
<td>…</td>
<td>省略号</td>
</tr>
<tr>
<td>|</td>
<td></td>
<td>|</td>
<td>竖线</td>
</tr>
<tr>
<td>¦</td>
<td>&amp;brvbar;</td>
<td>¦</td>
<td>断的竖线</td>
</tr>
<tr>
<td>–</td>
<td>&amp;ndash;</td>
<td>–</td>
<td>短破折号</td>
</tr>
<tr>
<td>—</td>
<td>&amp;mdash;</td>
<td>—</td>
<td>长破折号</td>
</tr>
</tbody>
</table>
</div>
<div></div>
<h2><strong>3、货币</strong></h2>
<div>
<table border="0">
<tbody>
<tr>
<td>¤</td>
<td>&amp;curren;</td>
<td>¤</td>
<td>一般货币符号</td>
</tr>
<tr>
<td>$</td>
<td></td>
<td>$</td>
<td>美元符号</td>
</tr>
<tr>
<td>¢</td>
<td>&amp;cent;</td>
<td>¢</td>
<td>分</td>
</tr>
<tr>
<td>£</td>
<td>&amp;pound;</td>
<td>£</td>
<td>英镑</td>
</tr>
<tr>
<td>¥</td>
<td>&amp;yen;</td>
<td>¥</td>
<td>日元</td>
</tr>
<tr>
<td>€</td>
<td>&amp;euro;</td>
<td>€</td>
<td>欧元</td>
</tr>
</tbody>
</table>
</div>
<div></div>
<h2><strong>4、数学符号</strong></h2>
<div>
<table border="0">
<tbody>
<tr>
<td>&lt;</td>
<td>&amp;lt;</td>
<td>&lt;</td>
<td>小于号</td>
</tr>
<tr>
<td>&gt;</td>
<td>&amp;gt;</td>
<td>&gt;</td>
<td>大于号</td>
</tr>
<tr>
<td>≤</td>
<td>&amp;le;</td>
<td>≤</td>
<td>小于等于号</td>
</tr>
<tr>
<td>≥</td>
<td>&amp;ge;</td>
<td>≥</td>
<td>大于等于号</td>
</tr>
<tr>
<td>×</td>
<td>&amp;times;</td>
<td>×</td>
<td>乘号</td>
</tr>
<tr>
<td>÷</td>
<td>&amp;divide;</td>
<td>÷</td>
<td>除号</td>
</tr>
<tr>
<td>−</td>
<td>&amp;minus;</td>
<td>−</td>
<td>减号</td>
</tr>
<tr>
<td>±</td>
<td>&amp;plusmn;</td>
<td>±</td>
<td>加/减 号</td>
</tr>
<tr>
<td>≠</td>
<td>&amp;ne;</td>
<td>≠</td>
<td>不等于号</td>
</tr>
<tr>
<td>¹</td>
<td>&amp;sup1;</td>
<td>¹</td>
<td>上标1</td>
</tr>
<tr>
<td>²</td>
<td>&amp;sup2;</td>
<td>²</td>
<td>上标2</td>
</tr>
<tr>
<td>³</td>
<td>&amp;sup3;</td>
<td>³</td>
<td>上标3</td>
</tr>
<tr>
<td>½</td>
<td>&amp;frac12;</td>
<td>½</td>
<td>二分之一</td>
</tr>
<tr>
<td>¼</td>
<td>&amp;frac14;</td>
<td>¼</td>
<td>四分之一</td>
</tr>
<tr>
<td>¾</td>
<td>&amp;frac34;</td>
<td>¾</td>
<td>四分之三</td>
</tr>
<tr>
<td>‰</td>
<td>&amp;permil;</td>
<td>‰</td>
<td>千分率</td>
</tr>
<tr>
<td>°</td>
<td>&amp;deg;</td>
<td>°</td>
<td>度</td>
</tr>
<tr>
<td>√</td>
<td>&amp;radic;</td>
<td>√</td>
<td>平方根</td>
</tr>
<tr>
<td>∞</td>
<td>&amp;infin;</td>
<td>∞</td>
<td>无限大</td>
</tr>
</tbody>
</table>
</div>
<div></div>
<h2><strong>5、方向</strong></h2>
<div>
<table border="0">
<tbody>
<tr>
<td>←</td>
<td>&amp;larr;</td>
<td>←</td>
<td>左箭头</td>
</tr>
<tr>
<td>↑</td>
<td>&amp;uarr;</td>
<td>↑</td>
<td>上箭头</td>
</tr>
<tr>
<td>→</td>
<td>&amp;rarr;</td>
<td>→</td>
<td>右箭头</td>
</tr>
<tr>
<td>↓</td>
<td>&amp;darr;</td>
<td>↓</td>
<td>下箭头</td>
</tr>
<tr>
<td>↔</td>
<td>&amp;harr;</td>
<td>↔</td>
<td>左右箭头</td>
</tr>
<tr>
<td>↵</td>
<td>&amp;crarr;</td>
<td>↵</td>
<td>回车箭头</td>
</tr>
<tr>
<td>⌈</td>
<td>&amp;lceil;</td>
<td>⌈</td>
<td>左上限</td>
</tr>
<tr>
<td><strong>⌉</strong></td>
<td>&amp;rceil;</td>
<td>⌉</td>
<td>右上限</td>
</tr>
<tr>
<td><strong>⌊</strong></td>
<td>&amp;lfloor;</td>
<td>⌊</td>
<td>左下限</td>
</tr>
<tr>
<td><strong>⌋</strong></td>
<td>&amp;rfloor;</td>
<td>⌋</td>
<td>右下限</td>
</tr>
</tbody>
</table>
</div>
<div></div>
<h2><strong>6、</strong><strong>其它</strong></h2>
<table border="0">
<tbody>
<tr>
<td>♠</td>
<td>&amp;spades;</td>
<td>♠</td>
<td>黑桃</td>
</tr>
<tr>
<td>♣</td>
<td>&amp;clubs;</td>
<td>♣</td>
<td>梅花</td>
</tr>
<tr>
<td>♥</td>
<td>&amp;hearts;</td>
<td>♥</td>
<td>红桃，心</td>
</tr>
<tr>
<td>♦</td>
<td>&amp;diams;</td>
<td>♦</td>
<td>方块牌</td>
</tr>
<tr>
<td>◊</td>
<td>&amp;loz;</td>
<td>◊</td>
<td>菱形</td>
</tr>
<tr>
<td>†</td>
<td>&amp;dagger;</td>
<td>†</td>
<td>匕首</td>
</tr>
<tr>
<td>‡</td>
<td>&amp;Dagger;</td>
<td>‡</td>
<td>双剑号</td>
</tr>
<tr>
<td>¡</td>
<td>&amp;iexcl;</td>
<td>¡</td>
<td>反向感叹号</td>
</tr>
<tr>
<td>¿</td>
<td>&amp;iquest;</td>
<td>¿</td>
<td>反向问号</td>
</tr>
</tbody>
</table>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>229</wp:post_id>
		<wp:post_date><![CDATA[2016-01-17 15:15:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-17 07:15:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[html%e5%b8%b8%e7%94%a8%e8%bd%ac%e4%b9%89%e5%ad%97%e7%ac%a6%e5%af%b9%e7%85%a7%e8%a1%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="html5"><![CDATA[HTML5]]></category>
		<category domain="post_tag" nicename="html5"><![CDATA[html5]]></category>
		<category domain="category" nicename="html%e5%9f%ba%e7%a1%80"><![CDATA[HTML基础]]></category>
		<category domain="post_tag" nicename="%e8%bd%ac%e4%b9%89%e5%ad%97%e7%ac%a6"><![CDATA[转义字符]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Mac版Android Studio常用快捷键</title>
		<link>http://www.autoref.cn/?p=235</link>
		<pubDate>Mon, 18 Jan 2016 08:46:23 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=235</guid>
		<description></description>
		<content:encoded><![CDATA[<h3 id="code"><a name="t0"></a>说明：</h3>
<strong>⌥  —&gt;  option|alt</strong>
<strong>⇧ —&gt;  shift</strong>
<strong>⌃  —&gt;  control</strong>
<strong>⌘  —&gt;  command</strong>
<strong>⎋  —&gt;  esc</strong>
<h3 id="code"><a name="t0"></a>快捷键：</h3>
<table border="1">
<tbody>
<tr>
<td>alt+F7</td>
<td>Find usage</td>
</tr>
<tr>
<td>alt+command+L</td>
<td>格式化代码</td>
</tr>
<tr>
<td> alt+command+O</td>
<td> 优化import（去掉无用的import）</td>
</tr>
<tr>
<td> command+O</td>
<td> Override Methods</td>
</tr>
<tr>
<td> command+I</td>
<td> Implement Methods</td>
</tr>
<tr>
<td> command+B</td>
<td> Declaration查看定义</td>
</tr>
<tr>
<td> alt+command+B</td>
<td> Implementations查看其实现</td>
</tr>
<tr>
<td> command+U</td>
<td> Super Method（Class）</td>
</tr>
<tr>
<td> control+上下方向键</td>
<td> Previous/Next Method</td>
</tr>
<tr>
<td> (shift+)F2</td>
<td> 快递定位并高亮错误（deprecate，unused）</td>
</tr>
<tr>
<td> command+Z</td>
<td> Undo撤销</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
shift+command+Z：Redo Typing
alt+enter：引入包，添加注释…
control+enter：generate setter，getter…
shift+command+T：添加Test
command+W：Extend Selection
shift+command+W：Shrink Selection
command+P：参数提示
command+Y（X）：删除当前行（剪切当前行）
command+F11：添加/取消bookmark
shift+F11：显示bookmark列表
command++/-：展开收缩代码
shift+command+上下方向键：Move Line Up/Move Line Down
<h3 id="search"><a name="t1"></a><strong>Search</strong></h3>
command+F：Find
command+R：Replace
control+shift+F：Find in Path
control+shiftÏ+R：Replace in Path
alt+command+左右方向键：Back/Forward操作
command+E：Recent File
shift+command+E：Recently Change Files
shift+shift：Search Method或者Class (Search Everywhere：command+N,shift+command+N,shift+alt+command+N)
command+N：Search Class
shift+command+N：Search File
shift+alt+command+N：Search Symbol
<h3 id="rundebug"><a name="t2"></a><strong>Run/Debug</strong></h3>
shift+F10：Run
shift+F9：Debug
command+F9：Make Project
shift+command+F9：Make Module
command+F2：关闭当前的执行的task
command+F8：添加/取消断点
shift+command+F8：查看所有断点
Debug：
F7：Step Into
F8：Step Over
shift+F8：Step out
F9：resume
alt+F9：Run to Cursor
<h3 id="refactor"><a name="t3"></a><strong>Refactor</strong></h3>
shift+F6：重命名
command+F6：快速修改函数的参数，返回值或者类添加泛型等
F6：Move快速的移动方法或者类
F5：Copy快速的移动类
alt+command+C：提取Constant变量
alt+command+V：提取Variable（Local变量）
alt+command+F：提取Field变量
alt+command+M：提取Method
<h3 id="window"><a name="t4"></a><strong>Window</strong></h3>
control+左右方向键：tab切换
alt+F4：关闭当前tab
esc+command：切换当前的窗口
shift+esc：隐藏侧栏
<h3 id="vcs"><a name="t5"></a><strong>VCS</strong></h3>
command+K：Commit Changes
shift+command+K：Push Commit Changes
command+T：Update Project
<h3 id="setting"><a name="t6"></a><strong>Setting</strong></h3>
command+，：Android Studio Preferences
command+；：Project Structure]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>235</wp:post_id>
		<wp:post_date><![CDATA[2016-01-18 16:46:23]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-18 08:46:23]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[mac%e7%89%88android-studio%e5%b8%b8%e7%94%a8%e5%bf%ab%e6%8d%b7%e9%94%ae]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="post_tag" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android-studio"><![CDATA[android studio]]></category>
		<category domain="post_tag" nicename="android-studio"><![CDATA[android studio]]></category>
		<category domain="post_tag" nicename="%e5%bf%ab%e6%8d%b7%e9%94%ae"><![CDATA[快捷键]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>4</wp:comment_id>
			<wp:comment_author><![CDATA[babsabtabkap]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[dsggsdrggss@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://brothosonkonlonwon.ru</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[46.28.66.2]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2016-01-15 21:27:46]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2016-01-15 13:27:46]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[IBdrE2 http://brothosonkonlonwon.ru]]></wp:comment_content>
			<wp:comment_approved><![CDATA[0]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>Android多分辨率屏幕适配</title>
		<link>http://www.autoref.cn/?p=238</link>
		<pubDate>Wed, 20 Jan 2016 07:55:41 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=238</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>1、使用"wrap_content"和"match_parent"设置宽高</h3>
为了保证界面灵活适配不同的屏幕大小，应该使用"wrap_content"和"match_parent"设置宽高，而不是硬编码大小。
<h3>2、使用相对布局（RelativeLayout）</h3>
相对布局会比其他布局更灵活。
<h3>3、使用大小来修饰</h3>
有时候通过上面两种方法也不能很好的适配不同的屏幕大小，比如像TV或平板这种大屏可以显示两块面板，但对于手机来说只能显示一块面板，我们可以为不同大小的屏幕提供指定的界面布局。默认情况，Android项目的res下只有layout布局文件夹，我们可以新建一个文件夹layout-large来适配大屏。

res/layout/main.xml：默认布局

res/layout-large/main.xml：适配大屏，比如7英寸或以上的平板
<h3>4、使用最小宽度来修饰</h3>
有时候我们需要给5英寸和7英寸的设备显示不同的布局，但它们都归类为大屏幕，怎么区分它们呢？Android 3.2开始引入了最小宽度（Smallest-width），允许我们以dp为单位规定一个确切的最小宽度。比如，7英寸的平板最小宽度为600dp，定义为layout-sw600dp。

res/layout/main.xml：默认布局

res/layout-sw600dp/main.xml：适配最小宽度为600dp的大屏

这意味着宽度大于或等于600dp的屏幕选选择layout-sw600dp/main.xml布局，但是在Android 3.2之前的版本不起作用，因为不能识别sw600dp标记，而会适配到layout-large/main.xml布局。
<h3>5、使用布局别名</h3>
为了兼容第4点中的layout-large和layout-sw600dp，避免平板和TV出现两份相同布局内容的文件，可以使用别名文件。比如，先在layout中准备两份分别适配大小屏的文件：

res/layout/main.xml

res/layout/main_twopanes.xml

然后分别创建values-large和values-sw600dp文件夹，接着分别创建layout.xml文件，内容如下：

<code>res/values-large/layout.xml</code>:
<span class="tag">&lt;resources&gt;</span>

<span class="tag">          &lt;item</span> <span class="atn">name</span><span class="pun">=</span><span class="atv">"main"</span> <span class="atn">type</span><span class="pun">=</span><span class="atv">"layout"</span><span class="tag">&gt;</span><span class="pln">@layout/main_twopanes</span><span class="tag">&lt;/item&gt;</span>

<span class="tag">&lt;/resources&gt;</span>

<code>res/values-sw600dp/layout.xml</code>:
<span class="tag"><span class="tag">&lt;resources&gt;</span> </span>

<span class="tag"><span class="tag">           &lt;item</span> <span class="atn">name</span><span class="pun">=</span><span class="atv">"main"</span> <span class="atn">type</span><span class="pun">=</span><span class="atv">"layout"</span><span class="tag">&gt;</span><span class="pln">@layout/main_twopanes</span><span class="tag">&lt;/item&gt;</span></span>

<span class="tag"> <span class="tag">&lt;/resources&gt;</span></span>

这样，对于平板和TV，Android 3.2以前的版本会匹配到large，Android 3.2或以上的版本会匹配到sw600dp。
<h3>6、布局使用dp单位和文字大小使用sp单位</h3>
单位换算：px = dip * density / 160，则当屏幕密度为160时，1 px = 1 dip。
<h3>7、提供可选的位图</h3>
<ul>
	<li><code>xxhdpi </code>:  2.5                             <strong>屏幕密度为480</strong></li>
	<li><code>xhdpi  </code>:  2.0                             <strong>屏幕密度为320</strong></li>
	<li><code>hdpi   </code>:  1.5                              <strong>屏幕密度为240</strong></li>
	<li><code>mdpi   </code>:  1.0 (baseline)           <strong>屏幕密度为160</strong></li>
	<li><code>ldpi   </code>:  0.75                            <strong>屏幕密度为120</strong></li>
</ul>
也就是说在xhdpi放置一张200*200的图片，相应的应该在hdpi中放置150*150的图片，mdpi为100*100，ldpi为75*75。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>238</wp:post_id>
		<wp:post_date><![CDATA[2016-01-20 15:55:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-20 07:55:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[android%e5%a4%9a%e5%88%86%e8%be%a8%e7%8e%87%e5%b1%8f%e5%b9%95%e9%80%82%e9%85%8d]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="post_tag" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91"><![CDATA[android应用开发]]></category>
		<category domain="post_tag" nicename="%e5%88%86%e8%be%a8%e7%8e%87"><![CDATA[分辨率]]></category>
		<category domain="post_tag" nicename="%e5%a4%9a%e5%b1%8f%e5%b9%95"><![CDATA[多屏幕]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Android四种启动模式下的onNewIntent()方法</title>
		<link>http://www.autoref.cn/?p=257</link>
		<pubDate>Thu, 21 Jan 2016 10:02:39 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=257</guid>
		<description></description>
		<content:encoded><![CDATA[Activity四种启动模式下onNewIntent方法的调用情况：
<table>
<tbody>
<tr>
<td class="line-number"></td>
<td class="line-content">1. standard</td>
</tr>
<tr>
<td class="line-number"></td>
<td class="line-content">默认启动模式，每次都会创建新Activity，并放入任务栈中，不会调用onNewIntent()。</td>
</tr>
<tr>
<td class="line-number"></td>
<td class="line-content"></td>
</tr>
<tr>
<td class="line-number"></td>
<td class="line-content">2. singleTop</td>
</tr>
<tr>
<td class="line-number"></td>
<td class="line-content">如果在栈顶正好存在该Activity的实例， 就重用该实例，并调用其onNewIntent()，否者就会创建新的实例并放入栈顶(即使栈中已经存在该Activity实例，只要不在栈顶，都会创建实例，而不会调用onNewIntent()，此时就跟standard模式一样)。</td>
</tr>
<tr>
<td class="line-number"></td>
<td class="line-content"></td>
</tr>
<tr>
<td class="line-number"></td>
<td class="line-content">3. singleTask</td>
</tr>
<tr>
<td class="line-number"></td>
<td class="line-content">如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的onNewIntent())。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移除栈。如果栈中不存在该实例，将会创建新的实例放入栈中（此时不会调用onNewIntent()）。</td>
</tr>
<tr>
<td class="line-number"></td>
<td class="line-content"></td>
</tr>
<tr>
<td class="line-number"></td>
<td class="line-content">4. singleInstance</td>
</tr>
<tr>
<td class="line-number"></td>
<td class="line-content">在一个新栈中创建该Activity实例，并让多个应用共享改栈中的该Activity实例。一旦该模式的Activity的实例存在于某个栈中，任何应用再激活改Activity时都会重用该栈中的实例，其效果相当于多个应用程序共享一个应用，不管谁激活该Activity都会进入同一个应用中。</td>
</tr>
</tbody>
</table>
singleTask模式下，Activity第一启动的时候会执行onCreate()--&gt;onStart()--&gt;onResume()，不会执行到onNewIntent()。之后重新启动同一Activity的时候，会执行onNewIntent()--&gt;onResart()--&gt;onStart()--&gt;onResume()。

当调用到onNewIntent(intent)的时候，需要在onNewIntent() 中使用setIntent(intent)赋值给Activity的Intent。不然后续的getIntent()得到的是老的Intent。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>257</wp:post_id>
		<wp:post_date><![CDATA[2016-01-21 18:02:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-21 10:02:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[android%e5%9b%9b%e7%a7%8d%e5%90%af%e5%8a%a8%e6%a8%a1%e5%bc%8f%e4%b8%8b%e7%9a%84onnewintent%e6%96%b9%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="post_tag" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91"><![CDATA[android应用开发]]></category>
		<category domain="post_tag" nicename="onnewintent"><![CDATA[onNewIntent]]></category>
		<category domain="post_tag" nicename="singleinstance"><![CDATA[singleInstance]]></category>
		<category domain="post_tag" nicename="singletask"><![CDATA[singleTask]]></category>
		<category domain="post_tag" nicename="singletop"><![CDATA[singleTop]]></category>
		<category domain="post_tag" nicename="standard"><![CDATA[standard]]></category>
		<category domain="post_tag" nicename="%e5%90%af%e5%8a%a8%e6%a8%a1%e5%bc%8f"><![CDATA[启动模式]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>配置使用Charles监控android网络请求</title>
		<link>http://www.autoref.cn/?p=264</link>
		<pubDate>Mon, 25 Jan 2016 06:45:39 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=264</guid>
		<description></description>
		<content:encoded><![CDATA[1、从官网下载并安装软件，有30天的试用期:

<a href="http://www.charlesproxy.com/">http://www.charlesproxy.com/</a>

2、注意电脑和手机必须在同一网段

3、在Charles界面选择菜单Proxy-&gt;Proxy Settings，并勾选"Enable transparent HTTP proxying"，确定代理端口，默认"8888"就可以了

4、Android手机选择当前连接的WIFI网络，选择"修改网络"，勾选"显示高级选项"，填入代理主机的IP(也就是装了Charles的机器)，端口输入刚才填的"8888"

5、这时Charles客户端会跳一个框，点选允许]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>264</wp:post_id>
		<wp:post_date><![CDATA[2016-01-25 14:45:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-25 06:45:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%85%8d%e7%bd%ae%e4%bd%bf%e7%94%a8charles%e7%9b%91%e6%8e%a7android%e7%bd%91%e7%bb%9c%e8%af%b7%e6%b1%82]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="post_tag" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91"><![CDATA[android应用开发]]></category>
		<category domain="post_tag" nicename="charles"><![CDATA[Charles]]></category>
		<category domain="post_tag" nicename="%e7%bd%91%e7%bb%9c%e7%9b%91%e6%8e%a7"><![CDATA[网络监控]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Android中字体加粗</title>
		<link>http://www.autoref.cn/?p=266</link>
		<pubDate>Fri, 22 Jan 2016 10:16:55 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=266</guid>
		<description></description>
		<content:encoded><![CDATA[在xml文件中配置android:textStyle=”bold”，但是这样不能将中文设置成粗体，需要在代码中设置：
<pre>TextView textView = (TextView)findViewById(R.id.text_view); 
TextPaint textPaint = textView.getPaint(); 
textPaint.setFakeBoldText(true);</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>266</wp:post_id>
		<wp:post_date><![CDATA[2016-01-22 18:16:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-22 10:16:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[android%e4%b8%ad%e5%ad%97%e4%bd%93%e5%8a%a0%e7%b2%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="android"><![CDATA[android]]></category>
		<category domain="post_tag" nicename="android"><![CDATA[android]]></category>
		<category domain="category" nicename="android%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91"><![CDATA[android应用开发]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e4%bd%93%e5%8a%a0%e7%b2%97"><![CDATA[字体加粗]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Spring MVC请求参数获取的几种方法</title>
		<link>http://www.autoref.cn/?p=268</link>
		<pubDate>Thu, 28 Jan 2016 06:42:07 +0000</pubDate>
		<dc:creator><![CDATA[x4niko]]></dc:creator>
		<guid isPermaLink="false">http://www.autoref.cn/?p=268</guid>
		<description></description>
		<content:encoded><![CDATA[<h4>1、通过@PathVariabl获取路径中的参数</h4>
<pre>    @RequestMapping(value="user/{id}/{name}", method=RequestMethod.GET)
    public String printMessage1(@PathVariable String id, @PathVariable String name, ModelMap model) {
        model.addAttribute("domain", "www.autoref.cn");
        return "www.autoref.cn";
    }
</pre>
&nbsp;
<h4>2、@ModelAttribute获取POST请求的FORM表单数据</h4>
Java Pojo：
<pre>    public class Pojo{
        private String a;
        private int b;
    }
</pre>
Java Controller：
<pre>@RequestMapping(method = RequestMethod.POST) 
public String processSubmit(@ModelAttribute("pojo") Pojo pojo) { 
    
    return "www.autoref.cn"; 
}
</pre>
&nbsp;
<h4>3、直接用HttpServletRequest获取</h4>
<pre>@RequestMapping(method = RequestMethod.GET) 
public String get(HttpServletRequest request, HttpServletResponse response) { 
   System.out.println(request.getParameter("a")); 
   return "www.autoref.cn"; 
}
</pre>
&nbsp;
<h4>4、用注解@RequestParam绑定请求参数</h4>
<pre>@RequestMapping(value = "/requestParam", method = RequestMethod.GET) 
public String setupForm(@RequestParam("a") String a, ModelMap model) { 
   System.out.println(a); 
   return "www.autoref.cn";
}
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>268</wp:post_id>
		<wp:post_date><![CDATA[2016-01-28 14:42:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2016-01-28 06:42:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[spring-mvc%e8%af%b7%e6%b1%82%e5%8f%82%e6%95%b0%e8%8e%b7%e5%8f%96%e7%9a%84%e5%87%a0%e7%a7%8d%e6%96%b9%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="spring"><![CDATA[Spring]]></category>
		<category domain="post_tag" nicename="spring-mvc"><![CDATA[spring mvc]]></category>
		<category domain="post_tag" nicename="%e8%af%b7%e6%b1%82%e5%8f%82%e6%95%b0"><![CDATA[请求参数]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
</channel>
</rss>
